<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[WebServie集成]]></title>
      <url>%2Fblog%2F2017%2F03%2F07%2FWebServie%E9%9B%86%E6%88%90%2F</url>
      <content type="text"><![CDATA[WebService到底是什么？ 一言以蔽之：WebService是一种跨编程语言和跨操作系统平台的远程调用技术。 所谓跨编程语言和跨操作平台，就是说服务端程序采用java编写，客户端程序则可以采用其他编程语言编写，反之亦然！跨操作系统平台则是指服务端程序和客户端程序可以在不同的操作系统上运行。 所谓远程调用，就是一台计算机a上的一个程序可以调用到另外一台计算机b上的一个对象的方法，譬如，银联提供给商场的pos刷卡系统，商场的POS机转账调用的转账方法的代码其实是跑在银行服务器上。再比如，amazon，天气预报系统，淘宝网，校内网，百度等把自己的系统服务以webservice服务的形式暴露出来，让第三方网站和程序可以调用这些服务功能，这样扩展了自己系统的市场占有率，往大的概念上吹，就是所谓的SOA应用。 其实可以从多个角度来理解WebService，从表面上看，WebService就是一个应用程序向外界暴露出一个能通过Web进行调用的API，也就是说能用编程的方法通过Web来调用这个应用程序。我们把调用这个WebService的应用程序叫做客户端，而把提供这个WebService的应用程序叫做服务端。从深层次看，WebService是建立可互操作的分布式应用程序的新平台，是一个平台，是一套标准。它定义了应用程序如何在Web上实现互操作性，你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service ，只要我们可以通过Web service标准对这些服务进行查询和访问。 WebService平台技术 XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术。 XML+XSD： WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务对象的返回结果是什么）。XML是WebService平台中表示数据的格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关的。无关性是比技术优越性更重要的：软件厂商是不会选择一个由竞争对手所发明的技术的。 XML解决了数据表示的问题，但它没有定义一套标准的数据类型，更没有说怎么去扩展这套数据类型。例如，整形数到底代表什么？16位，32位，64位？这些细节对实现互操作性很重要。XML Schema(XSD)就是专门解决这个问题的一套标准。它定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。WebService平台就是用XSD来作为其数据类型系统的。当你用某种语言(如VB.NET或C#)来构造一个Web service时，为了符合WebService标准，所有你使用的数据类型都必须被转换为XSD类型。你用的工具可能已经自动帮你完成了这个转换，但你很可能会根据你的需要修改一下转换过程。 SOAP： WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议。SOAP提供了标准的RPC方法来调用Web Service。 SOAP协议 = HTTP协议 + XML数据格式 SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。打个比喻：HTTP就是普通公路，XML就是中间的绿色隔离带和两边的防护栏，SOAP就是普通公路经过加隔离带和防护栏改造过的高速公路。 WSDL： 好比我们去商店买东西，首先要知道商店里有什么东西可买，然后再来购买，商家的做法就是张贴广告海报。 WebService也一样，WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。 WSDL(Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。它是WebService客户端和服务器端都能理解的标准格式。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。一些最新的开发工具既能根据你的Web service生成WSDL文档，又能导入WSDL文档，生成调用相应WebService的代理类代码。 WSDL文件保存在Web服务器上，通过一个url地址就可以访问到它。客户端要调用一个WebService服务之前，要知道该服务的WSDL文件的地址。WebService服务提供商可以通过两种方式来暴露它的WSDL文件地址：1.注册到UDDI服务器，以便被人查找；2.直接告诉给客户端调用者。 WebService开发WebService开发可以分为服务器端开发和客户端开发两个方面： 服务端开发：把公司内部系统的业务方法发布成WebService服务，供远程合作单位和个人调用。(借助一些WebService框 架可以很轻松地把自己的业务对象发布成WebService服务，Java方面的典型WebService框架包括：axis，xfire，cxf等，java ee服务器通常也支持发布WebService服务，例如JBoss。) 客户端开发：调用别人发布的WebService服务，大多数人从事的开发都属于这个方面，例如，调用天气预报WebService服务。（使用厂商的WSDL2Java之类的工具生成静态调用的代理类代码；使用厂商提供的客户端编程API类；使用SUN公司早期标准的jax-rpc开发包；使用SUN公司最新标准的jax-ws开发包。当然SUN已被ORACLE收购) WebService的工作调用原理：对客户端而言，我们给这各类WebService客户端API传递wsdl文件的url地址，这些API就会创建出底层的代理类，我调用这些代理，就可以访问到webservice服务。代理类把客户端的方法调用变成soap格式的请求数据再通过HTTP协议发出去，并把接收到的soap数据变成返回值返回。对服务端而言，各类WebService框架的本质就是一个大大的Servlet，当远程调用客户端给它通过http协议发送过来soap格式的请求数据时，它分析这个数据，就知道要调用哪个java类的哪个方法，于是去查找或创建这个对象，并调用其方法，再把方法返回的结果包装成soap格式的数据，通过http响应消息回给客户端。 WebService框架1、Axis2是Apache下的一个重量级WebService框架，准确说它是一个Web Services / SOAP / WSDL 的引擎，是WebService框架的集大成者，它能不但能制作和发布WebService，而且可以生成Java和其他语言版WebService客户端和服务端代码。这是它的优势所在。但是，这也不可避免的导致了Axis2的复杂性，使用过的开发者都知道，它所依赖的包数量和大小都是很惊人的，打包部署发布都比较麻烦，不能很好的与现有应用整合为一体。但是如果你要开发Java之外别的语言客户端，Axis2提供的丰富工具将是你不二的选择。 2、XFire是一个高性能的WebService框架，在Java6之前，它的知名度甚至超过了Apache的Axis2，XFire的优点是开发方便，与现有的Web整合很好，可以融为一体，并且开发也很方便。但是对Java之外的语言，没有提供相关的代码工具。XFire后来被Apache收购了，原因是它太优秀了，收购后，随着Java6 JWS的兴起，开源的WebService引擎已经不再被看好，渐渐的都败落了。 3、CXF是Apache旗下一个重磅的SOA简易框架，它实现了ESB（企业服务总线）。CXF来自于XFire项目，经过改造后形成的，就像目前的Struts2来自WebWork一样。可以看出XFire的命运会和WebWork的命运一样，最终会淡出人们的视线。CXF不但是一个优秀的Web Services / SOAP / WSDL 引擎，也是一个不错的ESB总线，为SOA的实施提供了一种选择方案，当然他不是最好的，它仅仅实现了SOA架构的一部分。 Http接口和WebService接口的区别什么是web service？ soap请求是HTTP POST的一个专用版本，遵循一种特殊的xml消息格式Content-type设置为: text/xml任何数据都可以xml化。 为什么要学习web service？ 大多数对外接口会实现web service方法而不是http方法，如果你不会，那就没有办法对接。 web service相对http (post/get)有好处吗？ 1.接口中实现的方法和要求参数一目了然 2.不用担心大小写问题 3.不用担心中文urlencode问题 4.代码中不用多次声明认证(账号,密码)参数 5.传递参数可以为数组，对象等… web service相对http（post/get）快吗？ 由于要进行xml解析，速度可能会有所降低。 web service 可以被http（post/get）替代吗？ 完全可以，而且现在的开放平台都是用的HTTP（post/get）实现的。 如何通俗的解释什么是CxfCXF的目的是为了开发web service，web service是SOAP的具体实现，web service的一个主要作用是解决不同语言通信的问题。举个例子，现在iteye不是希望和csdn整合吗(iteye用的ruby语言，csdn用的asp.net)，你看iteye上的通告，以后可以用csdn帐号登录了。那么这个登录系统肯定是在iteye下的，但是帐号密码一定要发送给csdn验证，ruby怎么把帐号密码发给asp.net？不同语言怎么识别？这里就用到web service了，因为web service是一个统一标准，asp.net可以定义一个登录验证的web service接口，提供一个checkLogin方法，参数是传入帐号密码，具体实现是asp.net内部的事，如果验证成功则返回true即可：public bool checkLogin(string loginCode,string password); 因为web service本身规则比较多，为了减少我们程序员的负担，往往会有一些框架来实现web service，比如java的CXF，.net也会有自己的框架，最后web service编写成功后通过部署到服务器，ruby就可以通过web service的形式调用asp.net代码了，这样就实现了不同语言的通信。 Spring整合CXF在Java中实现webservice有多种方法，java本身在jdk1.7之后也对webservice有了默认的实现，但是在我们实际开发中一般还是会使用框架来，比如这里所提到的CXF就有着广泛的应用。以下配置依然依赖于之前那篇SSM框架整合的博客所搭建的框架。 pom.xml配置添加Mava依赖(这里我统一使用了3.0.0版本。使用高版本如3.1.6版本会出现异常，初步判定是因为jar包引起了冲突，目前还没有排查出具体的原因)： 1234567891011121314151617 &lt;!--cxf CXF是apache旗下的开源框架，由Celtix + XFire这两门经典的框架合成，是一套非常流行的web service框架。 start--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-core&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; &lt;!--cxf end--&gt; web.xml配置接着我们需要配置一个CXF的servlet： 123456789&lt;!--定义一个cxf的servlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/webservice/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 之后只要我们访问webservice/*这个地址就会进入CXF的servlet中。 整合Spring配置接下来是最重要的一部，用Spring整合CXF： 在这之前我有新建一个CXF的包，如下图： 这里有两个主要类 HelloWorld接口。 实现HelloWorld接口的HelloWorldImpl类。 代码如下：HelloWorld.java 12345678package com.zh.cxf;import javax.jws.WebService;@WebServicepublic interface HelloWorld &#123; public String say(String str);&#125; 其中就只定义了一个简单的say()方法。 HelloWorldImpl.java 1234567891011package com.crossoverJie.cxf.impl;import com.crossoverJie.cxf.HelloWorld;import org.springframework.stereotype.Component;import javax.jws.WebService;@Component("helloWorld")@WebServicepublic class HelloWorldImpl implements HelloWorld &#123; public String say(String str) &#123; return "Hello"+str; &#125;&#125; 这里就是对say()方法的简单实现。 接下来就是整合Spring了，由于需要使用到CXF的标签，所以我们需要添加额外的命名路径如下： 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd "&gt; &lt;!-- cxf整合Spring start--&gt; &lt;import resource="classpath:META-INF/cxf/cxf.xml"/&gt; &lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml"/&gt; &lt;!-- 自动扫描webService --&gt; &lt;context:component-scan base-package="com.zh.cxf" /&gt; &lt;!-- 定义webservice的发布接口 --&gt; &lt;jaxws:endpoint implementor="#helloWorld" address="/HelloWorld"&gt; &lt;/jaxws:endpoint&gt; &lt;!--cxf整合Spring end --&gt; 更加具体的配置可以查看官方给出的文档:传送门 #helloWorld指的是我们在HelloWorldImpl类中所自定义的名字，/HelloWorld则是我们需要访问的地址。之后我们运行项目输入该地址：http://127.0.0.1:8000/webservice/HelloWorld?wsdl如果出现如下界面： 则说明我们的webservice发布成功了。 客户端调用webservice接口客户端调用cxf webservice接口时可以分为静态调用和动态调用。 他们的区别：静态调用需要依赖service类，因为客户端调用cxf webservice接口的过程中需要服务器端提供service，很不方便，如果同一个项目中则没有区别。动态调用完全不依赖service类，服务器端只要提供接口名和路径就可以方便的调用。 静态调用代码：1234567891011121314151617181920212223242526272829package com.zh.cxf;import org.apache.cxf.interceptor.LoggingInInterceptor;import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;public class WebServiceUtil &#123; public static void main(String[] args) &#123; /**静态调用**/ // 创建WebService客户端代理工厂 JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean(); // 判断是否抛出异常 factory.getOutInterceptors().add(new LoggingInInterceptor()); // 注册webservice接口 factory.setServiceClass(HelloWorld.class); // 配置webservice地址 factory.setAddress("http://127.0.0.1:8000/webservice/HelloWorld?wsdl"); // 获得接口对象 HelloWorld service = (HelloWorld) factory.create(); // 调用接口方法 String result = service.say("111"); System.out.println("调用结果:" + result); // 关闭接口连接 System.exit(0); &#125; &#125; 启动项目服务，执行后控制台输出结果：1234log4j:WARN No appenders could be found for logger (org.apache.cxf.common.logging.LogUtils).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.调用结果:Hello111 动态调用代码： 1234567891011121314151617181920212223242526272829303132package com.zh.cxf;import javax.xml.namespace.QName;import org.apache.cxf.jaxws.endpoint.dynamic.JaxWsDynamicClientFactory;public class WebServiceUtil &#123; /**区别：静态调用需要依赖service类，因为客户端调用cxf webservice接口的过程中需要服务器端提供service，很不方便，如果同一个项目中则没有区别。 动态调用完全不依赖service类，服务器端只要提供接口名和路径就可以方便的调用。**/ public static void main(String[] args) &#123; /**动态调用**/ JaxWsDynamicClientFactory dcf = JaxWsDynamicClientFactory.newInstance(); org.apache.cxf.endpoint.Client client = dcf .createClient("http://127.0.0.1:8000/webservice/HelloWorld?wsdl"); // url为调用webService的wsdl地址 QName name = new QName("http://cxf.zh.com/", "say"); // namespace是命名空间，methodName是方法名 String xmlStr = "aaaaaaaa"; // paramvalue为参数值 Object[] objects; try &#123; objects = client.invoke(name, xmlStr); System.out.println(objects[0].toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 启动项目服务，执行后控制台输出结果： 1234log4j:WARN No appenders could be found for logger (org.apache.cxf.common.logging.LogUtils).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.Helloaaaaaaaa 总结以上是我总结的比较简单的一篇webService入门博客，从概念、原理、应用场景到实际的配置、调用、测试。是对自己所学知识的一次梳理，同时也希望对大家以后的面试、工作能有一些帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shiro安全框架集成]]></title>
      <url>%2Fblog%2F2017%2F03%2F03%2FShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90%2F</url>
      <content type="text"><![CDATA[做企业级开发必须要了解权限和安全相关的开发知识，之前的一个项目我采用的是建立用户表、角色表、权限表、用户角色表、角色权限表五张经典表。之后使用自定义注解+拦截器的方式，在拦截器中对每一个请求进行拦截，再到SESSION或者数据库中进行查询，判断当前用户是否有该权限，这样的设计能满足大多数中小型系统的需求。本文介绍的Shiro既能满足之前的所有需求，安全性高，不跟任何的框架或者容器捆绑，可以独立运行。对比SpringSecurity安全框架使用相对简单，易于理解。而且现在越来越的多企业都在使用Shiro，值得在项目中引用尝试。 本篇博客的框架搭建请参考我之前的文章《SSM框架整合Maven+Spring+SpringMVC+MyBatis》 在项目中添加依赖pom.xml 12345678910111213141516171819&lt;!-- Apache Shiro --&gt;&lt;!-- shiro 核心包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- shiro Web相关包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring 整合shiro需要的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt; 配置shiro过滤器web.xml 该filter最好放在字符编码filter下面: 123456789101112131415 &lt;!-- shiro过滤器定义 --&gt;&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;!-- 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 --&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;!-- 拦截所有请求 --&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 这样会过滤所有的请求。 创建自定义MyRealm类逻辑与表结构首先在使用Shiro的时候我们要考虑在什么样的环境下使用： 登录的验证 对指定角色的验证 对URL的验证 在本篇博客中，我们需要这三个方法： findUserByUserName(String username)根据username查询用户，之后Shiro会根据查询出来的User的密码来和提交上来的密码进行比对。 findRoles(String username)根据username查询该用户的所有角色，用于角色验证。 findPermissions(String username)根据username查询他所拥有的权限信息，用于权限判断。 由于本篇博客着重讲解shiro的配置和使用，在实际开发工作中，最好建立五张表，用户表、角色表、权限表、用户角色中间表、角色权限中间表，拓展性更强。 通过中间表来配置用户与角色的对应关系，角色与权限的对应关系，更灵活。 大概流程为：验证通过后，通过用户名从用户表中查询用户ID，根据用户ID从用户角色中间表中查询该用户所对应的所有角色ID，通过所有角色ID从角色权限中间表中查询各个角色都含有哪些权限，并进行权限的去重操作。 我的ShiroUserMapper.xml代码(Mybatis自动构建请参考我之前的文章SSM整合，可以节省掉很大一部分写重复代码的时间)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.zh.dao.ShiroUserMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.zh.model.ShiroUser" &gt; &lt;id column="id" property="id" jdbcType="INTEGER" /&gt; &lt;result column="userName" property="username" jdbcType="VARCHAR" /&gt; &lt;result column="roleId" property="roleid" jdbcType="INTEGER" /&gt; &lt;result column="password" property="password" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, userName, roleId, password &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from t_user where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from t_user where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.zh.model.ShiroUser" &gt; insert into t_user (id, userName, roleId, password) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;roleid,jdbcType=INTEGER&#125;, #&#123;password,jdbcType=VARCHAR&#125;) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.zh.model.ShiroUser" &gt; insert into t_user &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; id, &lt;/if&gt; &lt;if test="username != null" &gt; userName, &lt;/if&gt; &lt;if test="roleid != null" &gt; roleId, &lt;/if&gt; &lt;if test="password != null" &gt; password, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="username != null" &gt; #&#123;username,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="roleid != null" &gt; #&#123;roleid,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.zh.model.ShiroUser" &gt; update t_user &lt;set &gt; &lt;if test="username != null" &gt; userName = #&#123;username,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="roleid != null" &gt; roleId = #&#123;roleid,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.zh.model.ShiroUser" &gt; update t_user set userName = #&#123;username,jdbcType=VARCHAR&#125;, roleId = #&#123;roleid,jdbcType=INTEGER&#125;, password = #&#123;password,jdbcType=VARCHAR&#125; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;select id="findUserByUsername" parameterType="String" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List"/&gt; from t_user where userName=#&#123;userName&#125; &lt;/select&gt; &lt;select id="findRoles" parameterType="String" resultType="String"&gt; select r.roleName from t_user u,t_role r where u.roleId=r.id and u.userName=#&#123;userName&#125; &lt;/select&gt; &lt;select id="findPermissions" parameterType="String" resultType="String"&gt; select p.permissionName from t_user u,t_role r,t_permission p where u.roleId=r.id and p.roleId=r.id and u.userName=#&#123;userName&#125; &lt;/select&gt; &lt;/mapper&gt; 以上提到的三个方法，分别对应xml文件中最下面的三个方法。 所需的表结构(包含后面要用的测试数据)： MyRealm类创建自定义的MyRealm类，这个还是比较重要的。继承至Shiro的AuthorizingRealm类，用于处理自己的验证逻辑，下面贴一下我的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.zh.shiro;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import com.zh.model.ShiroUser;import com.zh.service.ShiroUserService;import javax.annotation.Resource;import java.util.Set;/** * Shiro自定义域 */public class MyRealm extends AuthorizingRealm &#123; @Resource private ShiroUserService t_userService; /** * 用于的权限的认证。 * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; String username = principalCollection.getPrimaryPrincipal().toString() ; SimpleAuthorizationInfo info = new SimpleAuthorizationInfo() ; //根据用户名获取角色名称 Set&lt;String&gt; roleName = t_userService.findRoles(username) ; //获取角色所对应的权限名称 Set&lt;String&gt; permissions = t_userService.findPermissions(username) ; info.setRoles(roleName); info.setStringPermissions(permissions); return info; &#125; /** * 首先执行这个登录验证 * @param token * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //获取用户账号 String username = token.getPrincipal().toString(); ShiroUser user = t_userService.findUserByUsername(username); if (user != null)&#123; //这里将查询出的用户名密码与用户输入的进行匹配，并存放到 authenticationInfo用于后面的权限判断。第三个参数随便放一个就行了。 AuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(user.getUsername(),user.getPassword(), "a") ; return authenticationInfo ; &#125;else&#123; return null ; &#125; &#125;&#125; 继承AuthorizingRealm类之后就需要覆写它的两个方法： doGetAuthorizationInfo (登录验证) 和 doGetAuthenticationInfo (用户权限的认证) doGetAuthenticationInfo是用于登录验证的，在请求controller层进行登录的时候需要将数据封装到Shiro的一个token中，执行shiro的login()方法，之后只要我们将MyRealm这个类配置到Spring中，登录的时候Shiro就会自动的调用doGetAuthenticationInfo()方法进行登录验证。 ShiroUserController.java代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zh.controller;import com.zh.model.ShiroUser;import com.zh.service.ShiroUserService;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.subject.Subject;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;/** * 后台Controller */@Controller@RequestMapping("/shiroUser")public class ShiroUserController &#123; @Resource private ShiroUserService t_userService ; @RequestMapping("/loginAdmin") public String login(ShiroUser user, Model model)&#123; Subject subject = SecurityUtils.getSubject() ; UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(),user.getPassword()) ; try &#123; subject.login(token); return "admin" ; &#125;catch (Exception e)&#123; //这里将异常打印关闭是因为如果登录失败的话会自动抛异常// e.printStackTrace(); model.addAttribute("error","用户名或密码错误") ; return "../../login" ; &#125; &#125; @RequestMapping("/admin") public String admin()&#123; return "admin"; &#125; @RequestMapping("/student") public String student()&#123; return "admin" ; &#125; @RequestMapping("/teacher") public String teacher()&#123; return "admin" ; &#125;&#125; 在请求的Controller层中，主要就是shiro的login()方法。 登录验证的时候不是直接查询数据库返回是否有用户了，而是调用subject的login()方法，调用login()方法时Shiro会自动调用我们自定义的MyRealm类中的doGetAuthenticationInfo()方法进行验证。 验证逻辑是先根据用户名从数据库中查询用户，如果查询到的话再将查询到的用户名和密码放到SimpleAuthenticationInfo对象中，Shiro会自动根据用户输入的密码和查询到的密码进行匹配，如果匹配不上就会抛出异常，匹配上之后就会执行doGetAuthorizationInfo()进行相应的权限验证。 doGetAuthorizationInfo()方法的处理逻辑也比较简单，根据用户名获取到他所拥有的角色以及权限，然后赋值到SimpleAuthorizationInfo对象中即可，Shiro就会按照我们配置的XX角色对应XX权限来进行判断，这个配置在下面的整合中会讲到。 整合Spring我是在之前的Spring SpringMVC Mybatis框架的基础上进行整合的。 spring-mybatis.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package="com.zh" /&gt; &lt;!-- 引入properties配置文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:config/jdbc.properties&lt;/value&gt; &lt;value&gt;classpath:config/redis.properties&lt;/value&gt; &lt;!--要是有多个配置文件，只需在这里继续添加即可 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- dbcp dataSource 配置 &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- druid dataSource 配置 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;" /&gt; &lt;property name="filters" value="$&#123;filters&#125;" /&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;" /&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;" /&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;" /&gt; &lt;!-- 用来检测连接是否有效的sql，要求是一个查询语句。 --&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;" /&gt; &lt;!-- 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。 --&gt; &lt;property name="testWhileIdle" value="$&#123;testWhileIdle&#125;" /&gt; &lt;!-- 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 --&gt; &lt;property name="testOnBorrow" value="$&#123;testOnBorrow&#125;" /&gt; &lt;!-- 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 --&gt; &lt;property name="testOnReturn" value="$&#123;testOnReturn&#125;" /&gt; &lt;!-- 要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100 --&gt; &lt;property name="maxOpenPreparedStatements" value="$&#123;maxOpenPreparedStatements&#125;" /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;" /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;" /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name="logAbandoned" value="$&#123;logAbandoned&#125;" /&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:com/zh/mapping/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zh.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置开始 --&gt; &lt;!-- jedis 配置 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig" &gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt; &lt;property name="maxWaitMillis" value="$&#123;redis.maxWait&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;" /&gt; &lt;/bean &gt; &lt;!-- redis服务器中心 --&gt; &lt;bean id="connectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;property name="poolConfig" ref="poolConfig" /&gt; &lt;property name="port" value="$&#123;redis.port&#125;" /&gt; &lt;property name="hostName" value="$&#123;redis.host&#125;" /&gt; &lt;!-- &lt;property name="password" value="$&#123;redis.password&#125;" /&gt; --&gt; &lt;property name="timeout" value="$&#123;redis.timeout&#125;" &gt;&lt;/property&gt; &lt;/bean &gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" &gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="keySerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="valueSerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;/bean &gt; &lt;!-- cache配置插入、更新数据时从redis中清除缓存 --&gt; &lt;bean id="putCache" class="com.zh.redis.cache.PutCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- cache配置从redis获取缓存数据 --&gt; &lt;bean id="getCache" class="com.zh.redis.cache.GetCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置结束 --&gt; &lt;!-- Shiro 开始 --&gt; &lt;!-- 配置自定义Realm --&gt; &lt;bean id="myRealm" class="com.zh.shiro.MyRealm"/&gt; &lt;!-- 安全管理器 --&gt; &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="myRealm"/&gt; &lt;/bean&gt; &lt;!-- Shiro过滤器 核心--&gt; &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;!-- Shiro的核心安全接口,这个属性是必须的 --&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;!-- 身份认证失败，则跳转到登录页面的配置 --&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;!-- 权限认证失败，则跳转到指定页面 --&gt; &lt;property name="unauthorizedUrl" value="/nopower.jsp"/&gt; &lt;!-- Shiro连接约束配置,即过滤链的定义 --&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--anon 表示匿名访问，不需要认证以及授权--&gt; /shiroUser/loginAdmin=anon &lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt; /shiroUser/admin*=authc /shiroUser/student=roles[teacher] /shiroUser/teacher=perms["user:create"] &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt; &lt;bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/&gt; &lt;!-- 开启Shiro注解 --&gt; &lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor"/&gt; &lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;/bean&gt; &lt;!-- Shiro 结束 --&gt;&lt;/beans&gt; 在这里配置了上文中自定义的myRealm,这样Shiro就可以按照我们自定义的逻辑来进行权限验证了。 着重讲解一下：12345678910&lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--anon 表示匿名访问，不需要认证以及授权--&gt; /shiroUser/loginAdmin=anon &lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt; /shiroUser/admin*=authc /shiroUser/student=roles[teacher] /shiroUser/teacher=perms["user:create"] &lt;/value&gt;&lt;/property&gt; /shiroUser/loginAdmin=anon的意思的意思是，发起/shiroUser/loginAdmin这个请求是不需要进行身份认证的，这个请求在这次项目中是一个登录请求，一般对于这样的请求都是不需要身份认证的。 /shiroUser/admin*=authc表示 /admin,/admin1,/admin2这样的请求都是需要进行身份认证的，不然是不能访问的。 /shiroUser/student=roles[teacher]表示访问/student请求的用户必须是teacher角色，不然是不能进行访问的。 /shiroUser/teacher=perms[“user:create”]表示访问/teacher请求是需要当前用户具有user:create权限才能进行访问的。 这里注意下，如果你的controller层配置了全局的@RequestMapping(“/xxxx”)，在上面进行权限配置的时候一定以这个格式进行配置(格式:/xxxx/loginAdmin=anon)，不然会拦截失效。 更多相关权限过滤的资料可以访问shiro的官方介绍：传送门 使用Shiro标签库Shiro还有着强大标签库，可以在前端帮我获取信息和做判断。我贴一下我这里登录完成之后显示的界面：1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ taglib prefix="shiro" uri="http://shiro.apache.org/tags" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;后台&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;shiro:hasRole name="admin"&gt; 这是admin角色登录：&lt;shiro:principal&gt;&lt;/shiro:principal&gt;&lt;/shiro:hasRole&gt;&lt;shiro:hasPermission name="user:create"&gt; 有user:create权限信息&lt;/shiro:hasPermission&gt;&lt;br&gt;登录成功&lt;/body&gt;&lt;/html&gt; 要想使用Shiro标签，只需要引入一下标签即可： &lt;%@ taglib prefix=”shiro” uri=”http://shiro.apache.org/tags“ %&gt; 具有admin角色才会显示标签内的信息。 获取用户信息。默认调用Subject.getPrincipal()获取，即Primary Principal。 用户拥有user:create这个权限才回显示标签内的信息。 更多的标签可以查看官网：传送门 （图片待续。。。） 首先来验证一下登录： 先输入一个错误的账号和密码： 接下来输入一个正确的： 可以看到我登录的用户是zhfeat他是有admin的角色，并且拥有user:*(ps:系统数据详见上面的数据库截图)的权限，所以在这里： 123456&lt;shiro:hasRole name="admin"&gt; 这是admin角色登录：&lt;shiro:principal&gt;&lt;/shiro:principal&gt;&lt;/shiro:hasRole&gt;&lt;shiro:hasPermission name="user:create"&gt; 有user:create权限信息&lt;/shiro:hasPermission&gt; 是能显示出标签内的信息，并把用户信息也显示出来了。 接着我们来访问一下/student这个请求，因为在Spring的配置文件中： 12345678910&lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--anon 表示匿名访问，不需要认证以及授权--&gt; /shiroUser/loginAdmin=anon &lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt; /shiroUser/admin*=authc /shiroUser/student=roles[teacher] /shiroUser/teacher=perms["user:create"] &lt;/value&gt;&lt;/property&gt; 只有teacher角色才能访问/student这个请求的： 果然，Shiro做了安全控制是不能进行访问的。 然后我们换aaa用户登录，他正好是teacher角色，看能不能访问/student。 果然是能访问的。 因为我在控制器里访问/student返回的是同一个界面所以看到的还是这个界面。 1234@RequestMapping("/teacher")public String teacher()&#123; return "admin" ;&#125; 并且没有显示之前Shiro标签内的内容。 其他的我就不测了，大家可以自己在数据库里加一些数据，或者是改下拦截的权限多试试，这样对Shiro的理解就会更加深刻。 MD5加密Shiro还封装了一个非常不错的功能，那就是MD5加密，代码如下：12345678910111213141516package com.crossoverJie.shiro;import org.apache.shiro.crypto.hash.Md5Hash;/** * Created with IDEA * 基于Shiro的MD5加密 * Created by $&#123;jie.chen&#125; on 2016/7/13. */public class MD5Util &#123; public static String md5(String str,String salt)&#123; return new Md5Hash(str,salt).toString() ; &#125; public static void main(String[] args) &#123; String md5 = md5("abc123","crossoverjie") ; System.out.println(md5); &#125;&#125; 只需要调用Md5Hash(str,salt)方法即可，这里多了一个参数，第一个参数不用多解释，是需要加密的字符串。第二个参数salt中文翻译叫盐，加密的时候我们传一个字符串进去，只要这个salt不被泄露出去，那原则上加密之后是无法被解密的，在存用户密码的时候可以使用，感觉还是非常屌的。 总结以上就是Shiro实际使用的案例，文章讲的比较初略，还需要后面自己拓展，但是关于Shiro的核心东西都在里面了，大家可以自己配一下试试，才更能体会其中的逻辑。 项目地址：https://github.com/mhkzh/SSM 个人博客地址：http://zhfeat.cc GitHub地址：https://github.com/mhkzh/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[应用Druid监控SQL语句的执行情况]]></title>
      <url>%2Fblog%2F2017%2F03%2F01%2F%E5%BA%94%E7%94%A8Druid%E7%9B%91%E6%8E%A7SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%83%85%E5%86%B5%2F</url>
      <content type="text"><![CDATA[Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource Druid是什么？ Druid是一个JDBC组件，它包括三个部分： 基于Filter－Chain模式的插件体系。 DruidDataSource 高效可管理的数据库连接池。 SQLParser(一个经典的词法分析器,可解析各种复杂的SQL语句) 官方文档地址：https://github.com/alibaba/druid/wiki/常见问题 Druid可以做什么？ 替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。 可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。 数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver和DruidDataSource都支持PasswordCallback。 SQL执行日志，Druid提供了不同的LogFilter，能够支持Common-Logging、Log4j和JdkLog，你可以按需要选择相应的LogFilter，监控你应用的数据库访问情况。 扩展JDBC，如果你要对JDBC层有编程的需求，可以通过Druid提供的Filter机制，很方便编写JDBC层的扩展插件。 Druid在项目中配置使用pom.xml中添加Druid依赖123456&lt;!-- druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.28&lt;/version&gt; &lt;/dependency&gt; jdbc.properties属性文件中配置Druid所需参数123456789101112131415161718192021222324252627282930313233343536#druid连接池配置url:jdbc:mysql://localhost:3306/maven?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8 driverClassName:com.mysql.jdbc.Driverusername:rootpassword:rootfilters:stat#最大并发连接数maxActive:20#初始化连接数量initialSize:1#配置获取连接等待超时的时间maxWait:60000#最小空闲连接数minIdle:10#最大空闲连接数maxIdle:15#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒timeBetweenEvictionRunsMillis:60000#配置一个连接在池中最小生存的时间，单位是毫秒minEvictableIdleTimeMillis:300000#用来检测连接是否有效的sql，要求是一个查询语句。 如果validationQuery为null，testOnBorrow、testOnReturn、 testWhileIdle都不会其作用。validationQuery:SELECT 'x'#建议配置为true，不影响性能，并且保证安全性。 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。testWhileIdle:true#申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。testOnBorrow:false#归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能testOnReturn:false#要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100maxOpenPreparedStatements:20#打开removeAbandoned功能removeAbandoned:true#1800秒，也就是30分钟removeAbandonedTimeout:1800#关闭abanded连接时输出错误日志logAbandoned:true web.xml中配置123456789101112131415161718192021222324252627 &lt;!-- druid start--&gt; &lt;!-- 配置sql监控 start--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;!-- 网页监控路径放在了项目路径下的 druid路径中 --&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置sql监控 end--&gt; &lt;!-- 监控jsp和do请求，exclusions参数其实可以去掉的 start --&gt;&lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 监控jsp和do请求，exclusions参数其实可以去掉的 end --&gt; &lt;!-- druid end--&gt; 查看Druid监控页面，测试效果启动项目，在浏览器输入：http://localhost:8000/druid/sql.html 下图为Druid监控主界面： 点击sql监控，调用接口，测试是否监控到了sql的各项信息 下图为DruidSQL监控功能界面： 结果：测试通过，以上为项目引入Druid连接池并启动Druid监控页面的流程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用自定义注解+AOP实现redis缓存]]></title>
      <url>%2Fblog%2F2017%2F03%2F01%2F%E5%88%A9%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%2BAOP%E5%AE%9E%E7%8E%B0redis%E7%BC%93%E5%AD%98%2F</url>
      <content type="text"><![CDATA[数据查询时每次都需要从数据库查询数据，特别是通过复杂sql查询大量数据时，数据库压力很大，查询速度很慢，因此设置缓存层，查询数据时先从redis中查询，如果查询不到，则到数据库中查询然后将数据库中查询的数据放到redis中一份，下次查询时就能直接从redis中查到，不需要查询数据库了。进行增删改操作时，先从redis中查询，如果查询出数据，则在redis中将该数据清除。 redis作为缓存的优势 内存级别缓存，查询速度毋庸置疑。 高性能的K-V存储系统，支持String，Hash，List，Set，Sorted Set等数据类型，能够应用在很多场景中。 redis3.0版本以上支持集群部署。 redis支持数据的持久化，AOF，RDB方式。 redis安装部署请参见：http://blog.csdn.net/erlian1992/article/details/54382443 实现过程 搭建ssm的框架(请参考前一篇博文) 引入redis、jedis、SpringAOP依赖包 编写redis缓存方法、jedis操作Redis以及序列化所用到的工具类。 目录结构 maven依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;!-- modelVersion 这个元素指定了POM的版本，Maven2或者Maven3都只能是4.0.0 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- groupId 是项目组的ID，一般是com.公司组织名.项目名 --&gt; &lt;groupId&gt;com.zh.mavenDemo&lt;/groupId&gt; &lt;!-- artifactId 是该项目在项目组中的ID --&gt; &lt;artifactId&gt;mavenDemo&lt;/artifactId&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- ersion 是项目的版本号，用于维护项目的升级和发布 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 一般没有实际的用处，只是用于标识该项目 --&gt; &lt;name&gt;mavenDemo Maven Webapp&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用--&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 在spring的依赖中，我们需要引用一系列版本的spring，如版本4.0.2.RELEASE，每次都写不利于维护， 所以使用properties标签来统一维护版本号，这样有利于维护，不用大量修改，引用格式 &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; --&gt; &lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;!-- slf4j入口就是众多接口的集合，它不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。 --&gt; &lt;!-- 通俗的讲，slf4j是个数据线，一端嵌入程序，另一端链接日志系统，从而实现将程序中的信息导入到日志系统并记录。 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;!-- log4j是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终日志的输出。 --&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;/properties&gt; &lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;!-- &lt;scope&gt;test&lt;/scope&gt; --&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;!-- spring核心包 --&gt; &lt;!-- 这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring对于object/xml映射的支持，可以让JAVA与XML之间来回切换 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含对Spring对JDBC数据访问进行封装的所有类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含在应用中使用Spring的AOP特性(Spring的面向切面编程)时所需的类。使用基于AOP的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop注解 start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop注解 end --&gt; &lt;!-- redies start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.6.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- redies end --&gt; &lt;!-- Spring context的扩展支持，用于MVC方面。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 对JUNIT等测试框架的简单封装 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.36&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp(数据库连接池)的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 记录日志的，封装好的一个包，通过配置文件配置，在程序中直接调用，记录需要记录的日志，一般日志保存在文件中， --&gt; &lt;!-- SLF4J作用：如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无语忍受加载和维护一个新的日志框架的痛苦。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j-log4j12是链接slf4j-api和log4j中间的适配器。它实现了slf4j-apiz中StaticLoggerBinder接口 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON java对象和json相互转化,JSON串解析--&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传组件包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--构建项目需要的信息--&gt; &lt;build&gt; &lt;finalName&gt;mavenDemo&lt;/finalName&gt; &lt;!--使用的插件列表 。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。--&gt; &lt;plugin&gt; &lt;!-- Jetty 是一个开源的servlet容器，它为基于Java的web容器，例如JSP和servlet提供运行环境。Jetty是使用Java语言编写的，它的API以一组JAR包的形式发布。开发人员可以将Jetty容器实例化成一个对象，可以迅速为一些独立运行（stand-alone）的Java应用提供网络和web连接。 --&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.2.8.v20150217&lt;/version&gt; &lt;configuration&gt; &lt;httpConnector&gt; &lt;port&gt;8000&lt;/port&gt; &lt;/httpConnector&gt; &lt;stopKey&gt;shutdown&lt;/stopKey&gt; &lt;stopPort&gt;9966&lt;/stopPort&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; redis相关配置由于我spring配置文件和mybatis写在了一块，所以在spring-mybatis.xml里添加redis相关配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package="com.zh.*" /&gt; &lt;!-- 引入properties配置文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:config/jdbc.properties&lt;/value&gt; &lt;value&gt;classpath:config/redis.properties&lt;/value&gt; &lt;!--要是有多个配置文件，只需在这里继续添加即可 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:com/zh/mapping/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zh.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置开始 --&gt; &lt;!-- jedis 配置 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig" &gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt; &lt;property name="maxWaitMillis" value="$&#123;redis.maxWait&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;" /&gt; &lt;/bean &gt; &lt;!-- redis服务器中心 --&gt; &lt;bean id="connectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;property name="poolConfig" ref="poolConfig" /&gt; &lt;property name="port" value="$&#123;redis.port&#125;" /&gt; &lt;property name="hostName" value="$&#123;redis.host&#125;" /&gt; &lt;!-- &lt;property name="password" value="$&#123;redis.password&#125;" /&gt; --&gt; &lt;property name="timeout" value="$&#123;redis.timeout&#125;" &gt;&lt;/property&gt; &lt;/bean &gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" &gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="keySerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="valueSerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;/bean &gt; &lt;!-- cache配置插入、更新数据时从redis中清除缓存 --&gt; &lt;bean id="putCache" class="com.zh.redis.cache.PutCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- cache配置从redis获取缓存数据 --&gt; &lt;bean id="getCache" class="com.zh.redis.cache.GetCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置结束 --&gt;&lt;/beans&gt; redis.properties相关配置：1234567891011121314151617#redis中心 #绑定的主机地址 redis.host=127.0.0.1#指定Redis监听端口，默认端口为6379 redis.port=6379 #授权密码（本例子没有使用） redis.password=#最大空闲数：空闲链接数大于maxIdle时，将进行回收 redis.maxIdle=100 #最大连接数：能够同时建立的“最大链接个数” redis.maxActive=300 #最大等待时间：单位msredis.maxWait=1000 #使用连接时，检测连接是否成功 redis.testOnBorrow=true#当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 redis.timeout=10000 spring-mvc.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package="com.zh.controller" /&gt; &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源处理 css js imgs --&gt; &lt;mvc:resources location="/resources/**" mapping="/resources"/&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id="mappingJacksonHttpMessageConverter" class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;ref bean="mappingJacksonHttpMessageConverter" /&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 默认编码 --&gt; &lt;property name="defaultEncoding" value="utf-8" /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name="maxUploadSize" value="10485760000" /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name="maxInMemorySize" value="40960" /&gt; &lt;!-- 启用是为了推迟文件解析，以便捕获文件大小异常 --&gt; &lt;property name="resolveLazily" value="true"/&gt; &lt;/bean&gt; &lt;!-- 配置ViewResolver 。可用多个ViewResolver 。使用order属性排序。 InternalResourceViewResolver 放在最后--&gt; &lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;property name="order" value="1"&gt;&lt;/property&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;!-- 告诉视图解析器，返回的类型为json格式 --&gt; &lt;entry key="json" value="application/json" /&gt; &lt;entry key="xml" value="application/xml" /&gt; &lt;entry key="htm" value="text/htm" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="defaultViews"&gt; &lt;list&gt; &lt;!-- ModelAndView里的数据变成JSON --&gt; &lt;bean class="org.springframework.web.servlet.view.json.MappingJacksonJsonView" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="ignoreAcceptHeader" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;!-- 激活自动代理功能，开启注解 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; &lt;!-- 解决使用@ResponseBody 的中文乱码。 --&gt; &lt;bean class="com.zh.common.UTF8StringBeanPostProcessor"&gt;&lt;/bean&gt; &lt;/beans&gt; 开启注解这个一定要写到springmvc.xml里，否则注解会不起作用。 创建自定义注解、切面PutCache.java12345678910/** * 自定义注解,在插入、更新或者删除的时候更新对应的版本 * @author zh */ @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.METHOD&#125;) public @interface PutCache &#123; String name() default ""; String value() default ""; &#125; 被PutCache.java类中自定义的注解所标记的方法将实现下面的切面：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/**@Component * 注解用来将这个切面类实例化为bean， * 这样的操作也可以在Spring的配置文件中通过&lt;bean id="" class=""/&gt;来实现， * 效果一致。但是注解实现和配置实现两者不能共存， * 因为共存后Spring容器会同时管理两个同样的切面bean， * 导致的结果将是所有的通知都会执行两次， * 因为会有两个一样的切面被切入到业务代码中。**///@Component //实例化为bean，并交由Spring容器管理@Aspect //声明这是一个切面public class PutCacheAOP &#123; @Autowired //声明这个变量将由Spring容器注入 private RedisTemplate&lt;Serializable, Object&gt; redisTemplate; private RedisCache redisCache = new RedisCache(); //定义切入点 @Pointcut("@annotation(com.zh.redis.cache.PutCache)") public void putCache()&#123; System.out.println("我是一个切入点"); &#125; /** * 环绕通知,在所有标注@putCache的地方切入 * @param joinPoint */ @Around("putCache()") public Object beforeExec(ProceedingJoinPoint joinPoint)&#123; //前置：到redis中查询缓存 System.out.println("调用从redis中查询的方法..."); //redis中key格式：id String redisKey = getCacheKey(joinPoint); Object object = null; //获取从redis中查询到的对象 Object objectFromRedis = redisCache.getDataFromRedis(redisKey); //如果查询到了 if(null != objectFromRedis)&#123; System.out.println("从redis中查到数据,从redis中清空缓存"); //清空缓存 redisCache.delDataToRedis(redisKey); try &#123; object = joinPoint.proceed();//启动目标方法执行 System.out.println("操作数据库..."); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; &#125;else&#123; System.out.println("从redis中未查到数据..."); //没有查到，那么直接操作数据库 try &#123; object = joinPoint.proceed(); //启动目标方法执行 &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; System.out.println("操作数据库..."); &#125; return object; &#125; /** * 根据类名、方法名和参数值获取唯一的缓存键 * @return 格式为 "包名.类名.方法名.参数类型.参数值"，类似 "your.package.SomeService.getById(int).123" */ @SuppressWarnings("unused") private String getCacheKey(ProceedingJoinPoint joinPoint) &#123; MethodSignature ms=(MethodSignature) joinPoint.getSignature(); Method method=ms.getMethod(); String ActionName = method.getAnnotation(PutCache.class).name(); String fieldList = method.getAnnotation(PutCache.class).value(); //System.out.println("签名是"+ms.toString()); for (String field:fieldList.split(",")) ActionName +="."+field; //先获取目标方法参数，确保redis-Key的唯一性，由于我在更新或者插入时需要根据相同的key清除缓存，这里暂不做处理。 //String id = null; //Object[] args = joinPoint.getArgs(); //if (args != null &amp;&amp; args.length &gt; 0) &#123; // id = String.valueOf(args[0]); //&#125; //ActionName += "="+id; //String redisKey = ms+"."+ActionName; return ActionName; &#125; public void setRedisTemplate( RedisTemplate&lt;Serializable, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125;&#125; GetCache.java12345678910/** * 自定义注解,对于查询使用缓存的方法加入该注解 * @author Chenth */ @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.METHOD&#125;) public @interface GetCache &#123; String name() default ""; String value() default ""; &#125; 被GetCache.java类中自定义的注解所标记的方法将实现下面的切面：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * GetCache对应的切面 * @author zh * *//**@Component * 注解用来将这个切面类实例化为bean， * 这样的操作也可以在Spring的配置文件中通过&lt;bean id="" class=""/&gt;来实现， * 效果一致。但是注解实现和配置实现两者不能共存， * 因为共存后Spring容器会同时管理两个同样的切面bean， * 导致的结果将是所有的通知都会执行两次， * 因为会有两个一样的切面被切入到业务代码中。**///@Component //实例化为bean，并交由Spring容器管理@Aspect //声明这是一个切面public class GetCacheAOP &#123; @Autowired //声明这个变量将由Spring容器注入 private RedisTemplate&lt;Serializable, Object&gt; redisTemplate; private RedisCache redisCache = new RedisCache(); //定义切入点 @Pointcut("@annotation(com.zh.redis.cache.GetCache)") public void getCache()&#123; System.out.println("我是一个切入点"); &#125; /** * 环绕通知,在所有标注@getCache的地方切入 * @param joinPoint */ @Around("getCache()") public Object beforeExec(ProceedingJoinPoint joinPoint)&#123; //前置：到redis中查询缓存 System.out.println("调用从redis中查询的方法..."); //redis中key格式：id String redisKey = getCacheKey(joinPoint); //获取从redis中查询到的对象 Object objectFromRedis = redisCache.getDataFromRedis(redisKey); //如果查询到了 if(null != objectFromRedis)&#123; System.out.println("从redis中查询到了数据...不需要查询数据库"); return objectFromRedis; &#125; System.out.println("没有从redis中查到数据..."); //没有查到，那么查询数据库 Object object = null; try &#123; object = joinPoint.proceed(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; System.out.println("从数据库中查询的数据..."); //后置：将数据库中查询的数据放到redis中 System.out.println("调用把数据库查询的数据存储到redis中的方法..."); redisCache.setDataToRedis(redisKey, object);; System.out.println("redis中的数据..."+object.toString()); //将查询到的数据返回 return object; &#125; /** * 根据类名、方法名和参数值获取唯一的缓存键 * @return 格式为 "包名.类名.方法名.参数类型.参数值"，类似 "your.package.SomeService.getById(int).123" */ @SuppressWarnings("unused") private String getCacheKey(ProceedingJoinPoint joinPoint) &#123; MethodSignature ms=(MethodSignature) joinPoint.getSignature(); Method method=ms.getMethod(); String ActionName = method.getAnnotation(GetCache.class).name(); String fieldList = method.getAnnotation(GetCache.class).value(); //System.out.println("签名是"+ms.toString()); for (String field:fieldList.split(",")) ActionName +="."+field; //先获取目标方法参数 //String id = null; //Object[] args = joinPoint.getArgs(); //if (args != null &amp;&amp; args.length &gt; 0) &#123; // id = String.valueOf(args[0]); //&#125; //ActionName += "="+id; //String redisKey = ms+"."+ActionName; return ActionName; &#125; public void setRedisTemplate( RedisTemplate&lt;Serializable, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125;&#125; @Pointcut(“@annotation(com.zh.redis.cache.GetCache)”) 这个切入点的作用是在所有标注@getCache的地方切入 @Around(“getCache()”)这里用的是后置通知，即查询之前先查询redis，如果有数据就返回数据，没有就使用AOP的“启动目标方法函数”执行数据库查询数据，之后再缓存到redis中。 编写mapper层,service层,controller层 在上篇文章中已经进行详细介绍，这里不再讲解。 缓存要用到的工具类 RedisCache 12345678910111213141516171819202122232425262728293031323334353637383940public class RedisCache &#123; @Autowired private JedisPool jedisPool = new JedisPool(); //从redis缓存中查询，反序列化 public Object getDataFromRedis(String redisKey)&#123; //查询 Jedis jedis = jedisPool.getResource(); byte[] result = jedis.get(redisKey.getBytes()); //如果查询没有为空 if(null == result)&#123; return null; &#125; //查询到了，反序列化 return SerializeUtil.unSerialize(result); &#125; //将数据库中查询到的数据放入redis public void setDataToRedis(String redisKey, Object obj)&#123; //序列化 byte[] bytes = SerializeUtil.serialize(obj); //存入redis Jedis jedis = jedisPool.getResource(); String success = jedis.set(redisKey.getBytes(), bytes); if("OK".equals(success))&#123; System.out.println("数据成功保存到redis..."); &#125; &#125; //根据redisKey清除缓存 public void delDataToRedis(String redisKey)&#123; Jedis jedis = jedisPool.getResource(); jedis.del(redisKey); System.out.println("缓存数据已清空..."); &#125; 缓存要用到的序列化和反序列化工具123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * * @Description: 序列化反序列化工具 */public class SerializeUtil &#123; /** * * 序列化 */ public static byte[] serialize(Object obj)&#123; ObjectOutputStream oos = null; ByteArrayOutputStream baos = null; try &#123; //序列化 baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(obj); byte[] byteArray = baos.toByteArray(); return byteArray; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * * 反序列化 * @param bytes * @return */ public static Object unSerialize(byte[] bytes)&#123; ByteArrayInputStream bais = null; try &#123; //反序列化为对象 bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 测试redis是否生效在测试过程中遇到了springMvc返回json数据中文乱码问题，使用spring的BeanPostProcessor接口实现。123456789101112131415161718/** * 解决spring MVC3 中@ResponseBody的中文乱码问题 */ public class UTF8StringBeanPostProcessor implements BeanPostProcessor &#123; public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof StringHttpMessageConverter) &#123; MediaType mediaType = new MediaType("text", "plain", Charset.forName("UTF-8")); List&lt;MediaType&gt; types = new ArrayList&lt;MediaType&gt;(); types.add(mediaType); ((StringHttpMessageConverter) bean).setSupportedMediaTypes(types); &#125; return bean; &#125; public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; &#125; 再在springMvc的xml中注册： 12 &lt;!-- 解决使用@ResponseBody 的中文乱码。 --&gt; &lt;bean class="com.zh.common.UTF8StringBeanPostProcessor"&gt;&lt;/bean&gt; 为UserController.java 中的增加方法添加自定义注解@PutCache： 12345678910111213141516171819 // /user/test?id=1@PutCache(name="newsList",value="com.zh.UserController.showUser(String).123") @RequestMapping(value="/test",method=RequestMethod.GET) public String test(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user=null; if (userId==1) &#123; user = new User(); user.setAge(11); user.setId(1); user.setPassword("123"); user.setUserName("javen"); &#125; log.debug(user.toString()); model.addAttribute("user", user); return "index"; &#125; 为UserController.java 中的查询方法添加自定义注解@GetCache： 123456789101112131415 // /user/showUser?id=1// 从请求里面获取参数@GetCache(name="newsList",value="com.zh.UserController.showUser(String).123") @RequestMapping(value="/showUser",method=RequestMethod.GET) @ResponseBodypublic String toIndex(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.debug(user.toString()); String json = JSON.toJSONString(user); return json; //model.addAttribute("user", user); //return "showUser"; &#125; 启动redis服务并启动项目，执行查询方法，控制台输出日志如下所示： http://localhost:8000/user/showUser?id=1 1234567调用从redis中查询的方法...没有从redis中查到数据...userId:1从数据库中查询的数据...调用把数据库查询的数据存储到redis中的方法...数据成功保存到redis...redis中的数据...&#123;&quot;age&quot;:24,&quot;id&quot;:1,&quot;password&quot;:&quot;345&quot;,&quot;userName&quot;:&quot;测试&quot;&#125; 再次执行查询方法，控制台输出日志如下所示： http://localhost:8000/user/showUser?id=1 12调用从redis中查询的方法...从redis中查询到了数据...不需要查询数据库 执行增加方法，控制台输出日志如下所示： http://localhost:8000/user/test?id=1 12345调用从redis中查询的方法...从redis中查到数据,从redis中清空缓存缓存数据已清空...userId:1操作数据库... 再次执行查询方法，控制台输出日志如下所示： http://localhost:8000/user/showUser?id=1 1234567调用从redis中查询的方法...没有从redis中查到数据...userId:1从数据库中查询的数据...调用把数据库查询的数据存储到redis中的方法...数据成功保存到redis...redis中的数据...&#123;&quot;age&quot;:24,&quot;id&quot;:1,&quot;password&quot;:&quot;345&quot;,&quot;userName&quot;:&quot;测试&quot;&#125; 测试通过，由此完成了SSM + redies的整合，降低了应用的数据库请求次数和时间消耗，提高了查询效率。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSM框架整合（Maven+Spring+SpringMVC+MyBatis）]]></title>
      <url>%2Fblog%2F2017%2F02%2F24%2FSSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%EF%BC%88Maven%2BSpring%2BSpringMVC%2BMyBatis%EF%BC%89%2F</url>
      <content type="text"><![CDATA[以下是参考网上的资料自己实践操作的详细步骤。作为日后开发学习的参考。文中JAVA类及配置文件中加入了许多自己的理解和注释，后续会在此框架基础上引入更多的功能，使其更加完善。 基本概念SpringSpring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 SpringMVC Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring MVC分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。 MyBatis MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。 开发环境搭建以及创建Maven Web项目参看博文：http://www.cnblogs.com/zyw-205520/p/4767633.html SSM整合下面主要介绍SSM三大框架的整合，至于环境的搭建以及项目的创建，参看上面的博文。项目依赖包主要由spring核心包、mybatis核心包、dbcp数据库连接池、log4j、slf4j等日志记录相关依赖包、json处理包、junit单元测试包、javaEE核心包、jstl标签所需包、fileupload上传组件包、Jetty容器插件组成，整合分为了2个配置文件，分别是spring-mybatis.xml，包含spring和mybatis的配置文件，还有个是spring-mvc的配置文件，配置文件可以根据实际情况进行调整，此外有2个资源文件：jdbc.propertis和log4j.properties。完整目录结构如下（最后附上源码下载地址）： 使用框架的版本：Spring 4.0.2 RELEASESpring MVC 4.0.2 RELEASEMyBatis 3.2.6 Maven引入需要的JAR包在pom.xml中引入jar包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;!-- modelVersion 这个元素指定了POM的版本，Maven2或者Maven3都只能是4.0.0 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- groupId 是项目组的ID，一般是com.公司组织名.项目名 --&gt; &lt;groupId&gt;com.zh.mavenDemo&lt;/groupId&gt; &lt;!-- artifactId 是该项目在项目组中的ID --&gt; &lt;artifactId&gt;mavenDemo&lt;/artifactId&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- ersion 是项目的版本号，用于维护项目的升级和发布 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 一般没有实际的用处，只是用于标识该项目 --&gt; &lt;name&gt;mavenDemo Maven Webapp&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用--&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 在spring的依赖中，我们需要引用一系列版本的spring，如版本4.0.2.RELEASE，每次都写不利于维护， 所以使用properties标签来统一维护版本号，这样有利于维护，不用大量修改，引用格式 &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; --&gt; &lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;!-- slf4j入口就是众多接口的集合，它不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。 --&gt; &lt;!-- 通俗的讲，slf4j是个数据线，一端嵌入程序，另一端链接日志系统，从而实现将程序中的信息导入到日志系统并记录。 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;!-- log4j是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终日志的输出。 --&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;/properties&gt; &lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;!-- &lt;scope&gt;test&lt;/scope&gt; --&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;!-- spring核心包 --&gt; &lt;!-- 这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring对于object/xml映射的支持，可以让JAVA与XML之间来回切换 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含对Spring对JDBC数据访问进行封装的所有类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含在应用中使用Spring的AOP特性(Spring的面向切面编程)时所需的类。使用基于AOP的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring context的扩展支持，用于MVC方面。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 对JUNIT等测试框架的简单封装 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.36&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp(数据库连接池)的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 记录日志的，封装好的一个包，通过配置文件配置，在程序中直接调用，记录需要记录的日志，一般日志保存在文件中， --&gt; &lt;!-- SLF4J作用：如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无语忍受加载和维护一个新的日志框架的痛苦。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j-log4j12是链接slf4j-api和log4j中间的适配器。它实现了slf4j-apiz中StaticLoggerBinder接口 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON java对象和json相互转化,JSON串解析--&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传组件包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--构建项目需要的信息--&gt; &lt;build&gt; &lt;finalName&gt;mavenDemo&lt;/finalName&gt; &lt;!--使用的插件列表 。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。--&gt; &lt;plugin&gt; &lt;!-- Jetty 是一个开源的servlet容器，它为基于Java的web容器，例如JSP和servlet提供运行环境。Jetty是使用Java语言编写的，它的API以一组JAR包的形式发布。开发人员可以将Jetty容器实例化成一个对象，可以迅速为一些独立运行（stand-alone）的Java应用提供网络和web连接。 --&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.2.8.v20150217&lt;/version&gt; &lt;configuration&gt; &lt;httpConnector&gt; &lt;port&gt;8000&lt;/port&gt; &lt;/httpConnector&gt; &lt;stopKey&gt;shutdown&lt;/stopKey&gt; &lt;stopPort&gt;9966&lt;/stopPort&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 整合SpringMVC配置spring-mvc.xml配置里面的注释也很详细，主要是自动扫描控制器，视图模式，注解的启动这三个。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package="com.zh.controller" /&gt; &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源处理 css js imgs --&gt; &lt;mvc:resources location="/resources/**" mapping="/resources"/&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id="mappingJacksonHttpMessageConverter" class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;ref bean="mappingJacksonHttpMessageConverter" /&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 默认编码 --&gt; &lt;property name="defaultEncoding" value="utf-8" /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name="maxUploadSize" value="10485760000" /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name="maxInMemorySize" value="40960" /&gt; &lt;!-- 启用是为了推迟文件解析，以便捕获文件大小异常 --&gt; &lt;property name="resolveLazily" value="true"/&gt; &lt;/bean&gt; &lt;!-- 配置ViewResolver 。可用多个ViewResolver 。使用order属性排序。 InternalResourceViewResolver 放在最后--&gt; &lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;property name="order" value="1"&gt;&lt;/property&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;!-- 告诉视图解析器，返回的类型为json格式 --&gt; &lt;entry key="json" value="application/json" /&gt; &lt;entry key="xml" value="application/xml" /&gt; &lt;entry key="htm" value="text/htm" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="defaultViews"&gt; &lt;list&gt; &lt;!-- ModelAndView里的数据变成JSON --&gt; &lt;bean class="org.springframework.web.servlet.view.json.MappingJacksonJsonView" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="ignoreAcceptHeader" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;/beans&gt; 配置web.xml文件配置的spring-mvc的Servlet就是为了完成SpringMVC+MAVEN的整合。 web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring和mybatis的配置文件 --&gt; &lt;!-- &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; --&gt; &lt;!-- 编码过滤器 Spring中的字符编码过滤器（CharacterEncodingFilter），可以很方便的为我们解决项目中出现的中文乱码问题；--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- Filter负责拦截的URL 全部以/的请求,如果&lt;url-pattern&gt;/*.action &lt;/&gt;,将会以拦截*.action的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器,配合它一起使用的，经常是context-param，用来指定Spring要加载的配置文件，本质上是创建了一个 WebApplicationContext--&gt; &lt;!-- &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; --&gt; &lt;/listener&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;!-- &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; --&gt; &lt;!-- Spring MVC servlet --&gt; &lt;!-- DispatcherServlet则定义了mvc的相关内容，并配置拦截的url，所有/开头的请求，都会通过SpringMVC这个servlet进行处理。 --&gt; &lt;!-- Servlet拦截匹配规则要自已定义，把拦截下来的请求，交给对于对应的@RequestMapping方法进行处理,也就是依据某某规则分发到目标Controller(我们写的Action)来处理。 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- default servlet映射，此处可以可以配置成*.do，对应struts的后缀习惯 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; Log4j的配置为了方便调试，一般都会使用日志来输出信息，Log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 Log4j的配置很简单，而且也是通用的，下面给出一个基本的配置，换到其他项目中也无需做多大的调整，如果想做调整或者想了解Log4j的各种配置，可见：http://blog.csdn.net/zhshulin/article/details/37937365下面给出配置文件目录：log4j.properties123456789101112131415161718log4j.rootLogger=INFO,Console,File #定义日志输出目的地为控制台 log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.out #可以灵活地指定日志输出格式，下面一行是指定具体的格式 log4j.appender.Console.layout = org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%c] - %m%n #文件大小到达指定尺寸的时候产生一个新的文件 log4j.appender.File = org.apache.log4j.RollingFileAppender #指定输出目录 log4j.appender.File.File = logs/ssm.log #定义文件最大大小 log4j.appender.File.MaxFileSize = 10MB # 输出所有日志，如果换成DEBUG表示输出DEBUG以上级别日志 log4j.appender.File.Threshold = ALL log4j.appender.File.layout = org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%c]%m%n 使用Jetty测试 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zh.model;public class User &#123; private Integer id; private String userName; private String password; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName == null ? null : userName.trim(); &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password == null ? null : password.trim(); &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package package com.zh.controller;import javax.servlet.http.HttpServletRequest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod;import com.zh.model.User; @Controller @RequestMapping("/user") // /user/**public class UserController &#123; private static Logger log=LoggerFactory.getLogger(UserController.class); // /user/test?id=1 @RequestMapping(value="/test",method=RequestMethod.GET) public String test(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user=null; if (userId==1) &#123; user = new User(); user.setAge(11); user.setId(1); user.setPassword("123"); user.setUserName("javen"); &#125; log.debug(user.toString()); model.addAttribute("user", user); return "index"; &#125; &#125; 在浏览器中输入：http://localhost:8000/user/test?id=1 到此 SpringMVC+Maven 整合完毕 Spring与MyBatis的整合取消3.2.2 web.xml中注释的代码(全部) 建立JDBC属性文件jdbc.properties（文件编码修改为utf-8）1234567891011121314driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mavenusername=rootpassword=root#定义初始连接数initialSize=0#定义最大连接数maxActive=20#定义最大空闲maxIdle=20#定义最小空闲minIdle=1#定义最长等待时间maxWait=60000 建立spring-mybatis.xml配置文件这个文件就是用来完成spring和mybatis的整合的。这里面也没多少行配置，主要的就是自动扫描，自动注入，配置数据库。注释也很详细，大家看看就明白了。 spring-mybatis.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package="com.zh.*" /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties" /&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:com/zh/mapping/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zh.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;/beans&gt; JUnit测试经过以上步骤，我们已经完成了Spring和mybatis的整合，这样我们就可以编写一段测试代码来试试是否成功了。 创建测试用表既然我们需要测试，那么我们就需要建立在数据库中建立一个测试表，这个表建的很简单，SQL语句为：1234567891011121314151617-- ------------------------------ Table structure for `user_t`-- ----------------------------DROP TABLE IF EXISTS `user_t`;CREATE TABLE `user_t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_name` varchar(40) NOT NULL, `password` varchar(255) NOT NULL, `age` int(4) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_t-- ----------------------------INSERT INTO `user_t` VALUES ('1', '测试', '345', '24');INSERT INTO `user_t` VALUES ('2', 'javen', '123', '10'); 利用MyBatis Generator自动创建代码参考博文：http://blog.csdn.net/zhshulin/article/details/23912615 这篇文章可根据表自动创建实体类、MyBatis映射文件以及DAO接口，完成后将文件复制到工程中。如图： 建立Service接口和实现类下面给出具体的内容： IUserService.jave12345678package com.javen.service; import com.javen.model.User; public interface IUserService &#123; public User getUserById(int userId); &#125; IUserServiceImpl.java123456789101112131415161718192021package com.zh.service.impl;import javax.annotation.Resource;import org.springframework.stereotype.Service;import com.zh.dao.UserMapper;import com.zh.model.User;import com.zh.service.IUserService; @Service("userService") public class IUserServiceImpl implements IUserService &#123; @Resource private UserMapper userDao; public User getUserByIdTest(int userId) &#123; // TODO Auto-generated method stub return this.userDao.selectByPrimaryKey(userId); &#125; &#125; 建立测试类测试类在src/test/java中建立，下面测试类中注释掉的部分是不使用Spring时，一般情况下的一种测试方法；如果使用了Spring那么就可以使用注解的方式来引入配置文件和类，然后再将service接口对象注入，就可以进行测试了。 如果测试成功，表示Spring和Mybatis已经整合成功了。输出信息使用的是Log4j打印到控制台。123456789101112131415161718192021222324252627282930313233343536373839package com.javen.testmybatis;import javax.annotation.Resource; import org.apache.log4j.Logger; import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.alibaba.fastjson.JSON;import com.zh.model.User;import com.zh.service.IUserService; @RunWith(SpringJUnit4ClassRunner.class) //表示继承了SpringJUnit4ClassRunner类 @ContextConfiguration(locations = &#123;"classpath:spring-mybatis.xml"&#125;) public class TestMyBatis &#123; private static Logger logger = Logger.getLogger(TestMyBatis.class); //private ApplicationContext ac = null; //@Autowired(Spring)与@Resource(J2EE)都可以用来装配bean. 都可以写在字段上,或写在setter方法上。@Resource比较优雅 @Resource private IUserService userService = null; // @Before // public void before() &#123; // ac = new ClassPathXmlApplicationContext("applicationContext.xml"); // userService = (IUserService) ac.getBean("userService"); // &#125; @Test public void test1() &#123; User user = userService.getUserByIdTest(1); // System.out.println(user.getUserName()); // logger.info("值："+user.getUserName()); logger.info(JSON.toJSONString(user)); &#125; &#125; 测试结果： 建立UserController类UserController.java 控制器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.zh.controller;import java.io.File;import java.io.IOException;import java.util.Map;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import org.apache.commons.io.FileUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import com.zh.model.User;import com.zh.service.IUserService;@Controller @RequestMapping("/user") // /user/**public class UserController &#123; private static Logger log = LoggerFactory.getLogger(UserController.class); @Resource private IUserService userService; // /user/test?id=1 @RequestMapping(value="/test",method=RequestMethod.GET) public String test(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user=null; if (userId==1) &#123; user = new User(); user.setAge(11); user.setId(1); user.setPassword("123"); user.setUserName("javen"); &#125; log.debug(user.toString()); model.addAttribute("user", user); return "index"; &#125; // /user/showUser?id=1 // 从请求里面获取参数 @RequestMapping(value="/showUser",method=RequestMethod.GET) public String toIndex(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.debug(user.toString()); model.addAttribute("user", user); return "showUser"; &#125; // /user/showUser2?id=1 //用注解@RequestParam直接获取参数名为id的值。 @RequestMapping(value="/showUser2",method=RequestMethod.GET) public String toIndex2(@RequestParam("id") String id,Model model)&#123; int userId = Integer.parseInt(id); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.debug(user.toString()); model.addAttribute("user", user); return "showUser"; &#125; // /user/showUser3/&#123;id&#125; // @pathVariable 从路径中获取变量，把路径当做变量 @RequestMapping(value="/showUser3/&#123;id&#125;",method=RequestMethod.GET) public String toIndex3(@PathVariable("id")String id,Map&lt;String, Object&gt; model)&#123; int userId = Integer.parseInt(id); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.debug(user.toString()); model.put("user", user); return "showUser"; &#125; // /user/&#123;id&#125; @RequestMapping(value="/&#123;id&#125;",method=RequestMethod.GET) public @ResponseBody User getUserInJson(@PathVariable String id,Map&lt;String, Object&gt; model)&#123; int userId = Integer.parseInt(id); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.info(user.toString()); return user; &#125; // /user/&#123;id&#125; @RequestMapping(value="/jsontype/&#123;id&#125;",method=RequestMethod.GET) public ResponseEntity&lt;User&gt; getUserInJson2(@PathVariable String id,Map&lt;String, Object&gt; model)&#123; int userId = Integer.parseInt(id); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.info(user.toString()); return new ResponseEntity&lt;User&gt;(user,HttpStatus.OK); &#125; //文件上传 @RequestMapping(value="/upload") public String showUploadPage()&#123; return "user_admin/file"; &#125; @RequestMapping(value="/doUpload",method=RequestMethod.POST) public String doUploadFile(@RequestParam("file")MultipartFile file) throws IOException&#123; if (!file.isEmpty()) &#123; log.info("Process file:&#123;&#125;",file.getOriginalFilename()); &#125; FileUtils.copyInputStreamToFile(file.getInputStream(), new File("E:\\",System.currentTimeMillis()+file.getOriginalFilename())); return "succes"; &#125;&#125; 新建jsp页面jsp/user_admin/file.jsp1234567891011121314151617&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;上传文件&lt;/h1&gt; &lt;form method="post" action="/user/doUpload" enctype="multipart/form-data"&gt; &lt;input type="file" name="file"/&gt; &lt;input type="submit" value="上传文件"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; jsp/index.jsp12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; jsp/showUser.jsp1234567891011&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; $&#123;user.userName&#125; &lt;/body&gt; &lt;/html&gt; 至此，完成Spring+SpingMVC+mybatis这三大框架整合完成。 部署项目输入地址：http://localhost/user/jsontype/2 项目下载地址：https://github.com/mhkzh/SSM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven日常-你应该知道的一二三]]></title>
      <url>%2Fblog%2F2017%2F02%2F22%2FMaven%E6%97%A5%E5%B8%B8-%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%8C%E4%B8%89%2F</url>
      <content type="text"><![CDATA[在日常工作中，使用Maven只是机械的执行Maven clean、Maven install,对其中的原理与过程并无了解，本文根据《Maven实战》一书，对Maven的日常使用相关的知识进行总结与归纳，浅显易懂。 什么是Maven？如果没有Maven,你可能不得不经历下面的过程：1 如果使用了spring，去spring的官网下载jar包；如果使用hibernate，去hibernate的官网下载Jar包；如果使用Log4j，去log4j的官网下载jar包…..2 当某些jar包有依赖的时候，还要去下载对应的依赖jar包3 当jar包依赖有冲突时，不得不一个一个的排查4 执行构建时，需要使用ant写出很多重复的任务代码5 当新人加入开发时，需要拷贝大量的jar包，然后重复进行构建6 当进行测试时，需要一个一个的运行….检查有了Maven，它提供了三种功能：1 依赖的管理：仅仅通过jar包的几个属性，就能确定唯一的jar包，在指定的文件pom.xml中，只要写入这些依赖属性，就会自动下载并管理jar包。2 项目的构建：内置很多的插件与生命周期，支持多种任务，比如校验、编译、测试、打包、部署、发布…3 项目的知识管理：管理项目相关的其他内容，比如开发者信息，版本等等 Maven如何管理jar包关于jar包的坐标，有过使用经验的都应该有所了解，maven是通过groupId，artifactId，以及version确定一个唯一的jar包。这部分的内容可以参考前一篇：Maven构建过程例如,最常使用的Junit的声明就是如下：123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; 这是声明的范围，不同的生命周期所要求的范围是不一样的，详情参考《Maven实战》&lt;/dependency&gt; 首先先来说说Maven下载jar包的过程：在Maven中会涉及到几种仓库：1 工作空间，即我们的项目工程，这里面可能会放着pom.xml文件，这个pom.xml就是maven的配置文件2 本地仓库，本地仓库用于存放jar包，其实Jar包并不是直接放入工作空间的，它是存放在本地仓库，然后在执行发布打包的时候，添加依赖路径3 私库：私库是使用者自己搭建的maven仓库，用于缓解频繁从外网下载jar包资源的压力。而且使用私库作为缓存层，也相对安全一些。4 共享仓库：书中所说的中央仓库或者一些常用的镜像网站都属于这种，国内比较著名的oschina以及163都是不错的maven仓库。当我们在pom中声明了依赖关系后，参考上面的图： 1 Maven在执行相关的任务时，会先去本地仓库查看是否有该资源，如果有的话，判断版本是否正确，如果一切都没问题则直接使用；否则，执行下一步2 Maven会去配置的共享仓库中查找，如果找到就拷贝到本地仓库中；找不到则会给出相关的提示3 Maven在本地如果搭建了私库，则会去私库中查找，找到就拷贝到本地仓库；找不到就会去共享仓库中查找，然后放入私库和本地库。有了私库，局域网内的开发者可以共享依赖，就不用每个人都去外网下载jar包，浪费带宽了。 关于本地仓库和共享仓库的配置都在settings.xml中，这个文件位于conf中。 settings.xml中本地仓库的配置为：1&lt;localRepository&gt;F:\apache-maven-3.3.9\repo&lt;/localRepository&gt; 默认是在 用户的本地目录/.m2/repository中。 共享仓库的地址配置为:12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; Maven的生命周期与阶段Maven中有三大生命周期，他们相互独立，分别是：1 clean 清理2 default 构建3 site 建站一般来说，clean和default比较常用。 每个生命周期又有不同的阶段，阶段按顺序执行，并且可以指定执行结束的阶段。构建的时候，会依次从最上面的阶段执行到指定的那个阶段。 比如,clean有3个阶段： 1 pre-clean 执行清理前要完成的工作2 clean 清理上一次构建生成的文件3 post-clean 执行清理后需要完成的工作 当我们输入mvn clean的时候，执行的是pre-clean和clean两个阶段。 default的阶段比较多： validateinitializegenerate-sourcesprocess-sourcesgenerate-resourcesprocess-resourcescompileprocess-classesgenerate-test-sourcesprocess-test-sourcesgenerate-test-resourcesprocess-test-resourcestest-compileprocess-test-classestetprepare-packagepackagepre-integration-testintegration-testpost-integration-testverifyinstalldeploy 看名字大概就能理解，当执行mvn install的时候，实际会执行validate–&gt;initialize–&gt;…–&gt;verify–&gt;install等二十几个阶段。 为了操作方便，不同的声明周期可以在一起执行，比如mvn clean install，会先执行clean的阶段，在执行install的阶段。 在IDE开发环境中，当我们Run as的时候，就可以执行maven clean进行清理，或者执行maven install进行构建，也可以执行maven build同时执行clean和install两个任务。 基本上了解上面两个知识点，就足够日常工作使用了。当然Maven可不止这么一点点的东西，比如它还涉及到自定义构建任务、间接依赖的管理、插件的使用、私库的搭建等等，如果需要的话，读者可以参考《Maven实战》，这本书讲述的很全面了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven构建过程]]></title>
      <url>%2Fblog%2F2017%2F02%2F22%2FMaven%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Maven是一款进行 依赖管理、项目构建、信息管理 为一体的工具。它不像Make具有复杂的命令、也不像Ant需要手动编写大量的重复代码就能进行项目的构建；还能提供强大的依赖库管理，避免jar包混乱与冲突；还可以方便的管理项目的信息、知识产权等内容。 下载目前高版本的Eclipse已经集成了Maven，但是考虑到插件的稳定性，还是推荐使用自己安装的Maven(需要在Eclipse中进行绑定)。 手动安装需要在官网下载Maven,目前最新的版本是3.3.9：http://maven.apache.org/download.cgi 一般windows下的用户下载这个zip就可以了，如果要学习源码，可以下载src那版的。 安装1 首先需要安装JDK,在命令行中输入java -version验证版本： 2 然后解压下载好的压缩包： 3 配置环境变量：在“环境变量”中配置： M2_HOME:xxxx/apache-maven-3.3.9在path中添加：”;%M2_HOME%/bin” 4 在命令行中输入 mvn -v测试： 编写如果使用过Ant都知道Ant是通过build.xml执行构建任务的，Maven中是通过pom.xml来执行任务。POM,project object model，即项目对象模型，它通过这个pom.xml描述一个项目的构建以及信息。 1234567891011&lt;?&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xinoo.test&lt;/groupId&gt; &lt;artifactId&gt;first-maven&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;First Maven Project&lt;/name&gt;&lt;/project&gt; 第一行指定了文档的XML版本和编码第二行即每个pom.xml的核心元素——projectproject下面有几个子元素，这几个子元素一般是每个项目都会使用到的：1 modelVersion 这个元素指定了POM的版本，Maven2或者Maven3都只能是4.0.02 groupId 是项目组的ID，一般是com.公司组织名.项目名3 artifactId 是该项目在项目组中的ID,比如当前的项目是项目组的一个代理项目，就可以叫做myproxy4 version 是项目的版本号，用于维护项目的升级和发布5 name 一般没有实际的用处，只是用于标识该项目比较重要的参数是 groupId、artifactId、version，这三个属性确定唯一的一个项目。 执行任务一般的Maven项目会包含这样一个目录树： project |-src–main–java–你的源代码 | |–test—-java–你的单元测试代码 |-target–编译出的文件和jar包 |-pom.xml–项目信息以及任务定义 因此我们在上面的pom.xml同级目录中，创建src/main/java/com/xingoo/test/firstmaven 文件夹然后再该文件夹中创建HelloWorld.java 12345678910package com.xingoo.test.firstmaven;public class HelloWorld&#123; public String sayHello()&#123; return "Hello Maven"; &#125; public static void main(String[] args)&#123; System.out.println(new HelloWorld().sayHello()); &#125;&#125; 然后再pom.xml所在的目录中运行mvn clean compile命令: 会发现目录中多了一个target文夹，文件夹中增加了两个文件夹： 其中classes中是java编译出的class文件、maven-status是依赖的compile插件。 附：maven的基本命令//查看maven版本： mvn -v //编译maven： mvn compile //test： mvn test //清除： mvn clean //打包： mvn package //安装： mvn install]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一次没有最后期限的编程之旅]]></title>
      <url>%2Fblog%2F2017%2F02%2F22%2F%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E6%9C%80%E5%90%8E%E6%9C%9F%E9%99%90%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%97%85(%E8%BD%AC)%2F</url>
      <content type="text"><![CDATA[写的真的很好，一名老程序员独自去探索陌生的技术，陌生的世界。引用文章中的一句话：这个世界，无从选择。也许，走出去，是旅行；只在一处，也是旅行。 今年上半年，是我工作以来最繁忙的六个月，总之遇到了最艰难的教程、最冗长的文档、最繁琐的代码以及最窘迫的合作，最终的极度疲劳成了压垮了我的最后一根稻草。那年杭州，接连40摄氏度以上的连续高温，忽然一天39度，竟然觉得整个世界都清凉了。人，就是这么犯贱，稍有舒缓，便全然忘记曾经的抓狂。“写一个Apple Watch APP玩玩”，忽然闪过这么一个念头。这对执着于《证明论》和《集合论》的苦行者而言，浮现的不过是一次短暂的旅行。旅行，不是迁移，抑或流浪，终究是要回归的。记得还是在2003年的时候，万老师曾不经意间对我说过一句话，“编程这东西，如果不是每次都催得很急的话，其实还是蛮有乐趣的。”从96年初次接触Pascal开始到现在，整整19年了。我不知道编程这东西在满足一切诡异的条件下，是否依旧还有当年的乐趣。譬如，重返19岁。 图1 Turbo Pasca 没有什么需要整理的行囊，也没有什么设定的归期，说走就走，不知何时归来的编程之旅。我并非坚定的要找寻一些所谓编程的乐趣，只是一路风景，一路散心。写点什么呢？我没有做过移动端开发，可生活却早已离不开移动端的APP，使用频率极高的不外是“微信”、“网易新闻”、“QQ”、“支付宝”、“淘宝”、“百度地图”、“哔哩哔哩动画”、“大众点评”以及“Uber”。我想一款优秀的移动端APP，除了移动便携的基本特征之外，还应能充分利用碎片时间以及丰富多源的感知设备。事实上，游离了好久，没有什么惊艳想法。随意翻阅早已在案头，却无暇顾及的两册图书《Objective-C基础教程》和《精通iOS开发》，大致都是一些移动客户端面向对象的可视化设计。我想拥有一个优秀的IDE，一整套API以及丰富文档的支持，iOS开发的学习曲线应该不会太陡峭。于是，关注点就自然转移到了Web服务端的开发。Web服务端的开发是熟悉的，也是陌生的。最早接触Web开发是在2000年春，用的是ASP2.0，VB5.0编写的ActiveX作为控件，浏览器通过数字签名下载到客户端，实现服务器端文件的下载以及数据库的连接。第二次系统性的开发Web应用程序是2005年，用的是WebLogic 8.1提供的一整套解决方案，包括IDE、页面标签、web服务器、中间件、工作流等，这是一次真正意义上的J2EE开发，但因其优秀的封装，却让我无意间失去了一次自主搭建和配置Java web开发环境的绝好机会。2010年经历了第三次Web工程项目的开发，用的是ASP.NET 4.0，整个解决方案除了web工程之外，其余都是C#编写的类库工程，Web Service、自定义网站模板、自定义页面控件以及各种支付接口，在微软从开发环境到部署的一系列支持下，ASP.NET异常强大，超乎我的想象。我搜了一些iOS服务端的开发，也不乏使用ASP.NET的Web Service的案例。既然是一次漫无目的的旅行，不妨选择一些对我而言极为陌生的技术。然而，仅仅才是初步的调研，就发现我面对的不是一种或几种陌生的技术，而是一个陌生的世界。你好，世界。Java还是PHP，形而上的选择Java。形而上，也不全是信仰。杭州两家大型互联网公司，阿里巴巴和网易（网易杭州研发中心）的应用服务端也是用Java开发的。每次选择JDK的版本，通常只是偷懒的做法，我不是什么资深的Java程序员，也没有成熟老旧的代码需要兼容，直接在Oracle主页上下载最新的1.8版本，虽然1.6和1.7依旧是主流。继续Eclipse么？这次终于可以选择了，因为这次选择权掌握在自己手里。2007年使用Eclipse Plug-in参与开发一个无线传感网络（WSN）自定义语言的集成开发环境，尤其是开发Debug功能，简直是噩梦，到现在都还有恐惧的后遗症。论文的最终版本终于废弃了调试功能，但在presentation的时候还是被人问到。我用蹩脚的口语搪塞道，“It’s very difficult to implement, and need further research.”其实，这还算不得research，只是真的没法implement。虽然还不至于到达算法边界，但早已在我的编程能力之外了。据我了解，现在很多Java程序员在使用Intellij IDEA开发。有一个毛估估的统计数据，网易杭州研发中心的开发人员中使用Eclipse和Intellij IDEA的比例已经达到了1:1。相比免费的Eclipse，2000多元的Personal License可能是贵了点，不过对于如此一款优秀的IDE，这个价格真不算高。我下载了试用版，这就算开始了。可选的经典Darcula主题确实相当美观。至于和Maven完美结合之类优点，我自然体会不到的，因为这将是我第一次使用Maven开发。 图2 Darcula主题的Intellij IDEA 此前，对于Maven，我是极度陌生的。好在现在互联网上学习教程太多了，首先从Apache官网上下载最新的Maven应用程序，接着配置 Maven的环境变量，然后Intellij IDEA设置下Maven的home directory，当然也可直接使用Intellij IDEA内嵌的Bundled (Maven 3)插件。现在可以使用Intellij IDEA开发Maven Project了。建立maven-archetype-webapp工程，在pom.xml中配置好Maven插件，以及各种需要引用的库。使用Maven管理库，确实非常方便，真是一种全新的开发体验。直到要运行了，才想起web服务器都没有安装。不管三七二十一，下了Tomcat8.0.23，照着网上的教程，在Intellij IDEA配置好了运行环境。浏览器中出现了“hello, world”，“全小写，有逗号，逗号后空一格，且无感叹号。”至此，JDK 1.8, Maven3.3.3, Intellij IDEA14.1.4, Tomcat8.0.23以及一个“Hello,World”程序，一个很美好的开端。“Hello, World”写完了，没有下一步的计划和目标。Spring是主流么？反正阿里巴巴和网易都用Spring。于是，买本书《Spring MVC学习指南》看看，翻了三两个小时，对Web服务端开发依旧没有什么清晰的概念。看来我的这次没有计划的旅行似乎有了下一个目标，把Java web开发的架构搞搞清楚。毕竟搞清楚了架构，剩下的无非是算法了。寻找并学习Jave web架构的最佳实践，比我预想的困难的多。疯狂搜索的结果是各种技术及其框架浩如烟海，完全没有概念，直到发现在GitHub上有一个叫quick4j的开源项目(https://github.com/starzou/quick4j)，让我对Jave web开发的架构有了初步认识。我很快在IntellijIDEA中导入了quick4j这个项目，并根据README.md的说明在MySQL中运行了数据库脚本，建立了数据库及表。关于MySQL，我不得不多数几句。MySQL是2015年9月DB-Engines排名第二的数据库，我却从来没有使用过，主要因为2010年以后再无开发数据库相关系统，而2010年以前几次开发数据库的工程主要使用Oracle和SQL Server。现在大型互联网公司大都使用根据自身业务优化的特定分布式实时数据库。当然，对于中小企业的开发，MySQL依旧是上佳选择。此外，在一个应用中同时建立与MySQL和MongoDB的连接，合理利用每一种数据库的优点也是一种趋势。 图3 SQL Server存储过程 quick4j采用Druid作为数据库连接池。我查了下才知道，Druid是阿里巴巴的开源项目，是JDBC的一个扩展，项目负责人的年纪应该和我差不多。既然是开源，用的人似乎也不少，那就学习下。在pom.xml中配置好依赖（dependency），然后在applicationContext.xml中配置bean的一些系列参数，除了修改url，username以及password外，其余参数留着以后有兴趣提升性能的时候再去研究罢。在Druid之上，quick4j采用的是Mybatis，也是完全没用过，查了下和Hibernate是一个层次的东西，属于对象关系模型（ORM）范畴。Hibernate很久以前似乎还用过，当年的学习曲线如何，已没了印象。不过，Mybatis的入门似乎非常简单，在applicationContext.xml中将Mybatis和Druid关联好，就可以在xml中编写SQL了。quick4j对于Mybatis的XML文件写得还是很不错的，是一个非常好的范例，尤其对我这样一个初学者，比网上一些介绍Mybatis概念的示例强得多。几乎就是一张表对应一个XML配置文件和一个DAO接口，这些DAO接口很容易被上层调用。在quick4j中，最初使用Mybatis的是一个叫Shiro的安全框架，用于用户的权限管理。当然quick4j在DAO（Mapper）层和Shiro调用之间还封装了一层Service。权限管理是一件令人头疼的事情，好在权限管理再复杂，其关系不过张二维表。根据quick4j的5张表（user、user_role、role、role_permission、permission），我建立了一个权限的示意关系表，三个字段名分别是“Username”、“Role”、“Permission”，Username表示用户名称，如admin、lace；Role表示用户角色，如Admin（管理员）、Guest（访客）；Permission表示许可，如user: create、user: read、user: update、user: delete等。在概要设计时，通常先建立这张权限的示意关系表，然后再转化为实际的数据表。至于Shiro基本功能使用，如SecurityRealm中doGetAuthorizationInfo和doGetAuthenticationInfo的编写并不太复杂，而且quick4j也给出了很好的样例。终于到了Spring MVC这一层，因为这东西刚看过书，整体的概念要比什么Druid、Mybatis、Shiro强的多。除了配置pom.xml, web.xml, dispatcher-servlet.xml外，主要就是这个Controller类。其实也就是request和response了，根据@RequestMapping注解指定访问的URL，关联的方法处理提交的数据，处理完了return一个网页回去，就这么简明。只是封装的过于完美，让我感觉都不像在编程。旅行，不是定居，亦非常年生活，浅尝即止。所谓服务端开发似乎浏览完了，顺便也了解下quick4j的前端开发。quick4j采用了一套被称为“响应式后台管理模板”Metronic来实现（这里指的“后台”是业务的后台），版本是1.5.5，不过即使是1.5.5，其效果也足以让我惊讶了。我上网查了下，最新版本已经是4.1.0了。Metronic是收费的，Regular License价格为28美元，而Extended License价格达到了1400美元。国内也有演示的版本，的确非常精美，万能的淘宝也必然是有的卖的，最新的版本仅仅9块钱人民币。Metronic1.5.5是基于Bootstrap v3.0.3，而Bootstrap则大名鼎鼎，不过我也是刚才知道的。Bootstrap基于HTML5、CSS3以及Javascript，是一套极为优秀的前端开发框架。不过我粗粗看了下，似乎把Metronic以及相关的JQuery用下，前端的UI开发基本也算了解了，Bootstrap暂时是不用学习了。既然Metronic已经4.1.0了，不如替换quick4j的1.5.5。Metronic4.1.0非常大，居然有644M。Metronic4.1.0其实已经支持AngularJS，不过我还是选用了JQuery。原因很简单，据说AngularJS2.0较1.3有非常大的变化，虽然2.0是革命性的，但1.3巨大的用户还处于摇摆不定的状态，可以预见2.0出现需要一大波小白鼠。显然，作为游客，是没有太多精力的。我选择了“v4.1.0\theme\templates\admin4”模板，并没有仔细甄别“\v4.1.0\theme\assets”文件夹，因为引用的目录过于复杂，全部拷贝到webapp目录下，虽然这个assets达到了125M，但模板中引用文件的路径中只要删除“../../”，修改为相对目录即可，因为quick4j在前端页面通过JSP获取了根目录。偷懒是偷懒了点，但增加新的模板文件其实真的很方便。至此，整个开发架构似乎清晰了。数据库采用MySQL；后端包括Druid, Mybatis,Shiro, Spring MVC；前端采用Metronic (HTML5, CSS3, JQuery, Bootstrap)和JSP；IDE、库管理以及Web服务器分别采用IntellijIDE、Maven以及Tomcat。架子终于搭好了，不写个啥的，真是太可惜了。毕竟动手写点什么才叫编程之旅么。先从完善用户登录开始吧。第一个小功能，“记住我”。“记住我”功能仅用前端技术是无法实现的，因为只有在用户名和密码在后台验证正确后，记录这个选项才有意义，记录的方式通过Cookie是最为方便的。后端在验证通过后，将记住我状态，用户名和密码都保存到Cookie中，这样前端页面每次刷新时就可通过js读取Cookie中记住我的状态，并在需要的时候填充到文本框中。此外，还要考虑的一个小问题是用户输入密码不是加密的，而提交的密码是通过sha256加密的，就在每次提交表单时加密。但前端js通过Cookie读取的已经是加密的密码，提交时应防止再次加密。我一下子也没有想到好的办法，只是利用了sha256加密后的长度均为64，而用户密码均小于64这个假设条件来判断。下一个小功能是用户注册，用户注册显然需要用到验证，前端验证自然用到了基于JQuery的jquery.validate验证框架。jquery.validate虽然是前端验证，但也提供通过ajax提交后台验证，正是这个后台验证让我遇到了不少小问题。一般对于格式的验证，比如用户名长度，邮件格式什么的，jquery.validate的前端验证完全胜任。但对于用户名已经被注册这样的功能，则需要通过后台验证。jquery.validate毕竟是一个常用功能，网上的样例非常多，但适用于目前这个架构的却不多。将几种样例反复尝试，始终进入不了Controller中的设置的断点。直到查阅了官方最新样例，竟没有“contentType : “json””这行数据的，我删除之后果然成功了。显然，网上众多的样例是基于不同版本的写法。各种框架集成的首要问题必然是明确各种框架所用的版本，也应多从官方文档中寻找样例。验证通过后，用户信息的提交和后台的处理则没有遇到什么问题，后台Controller直接通过request获取前端的数据，直接调用DAO接口，并插入了新的记录。既然注册都实现了，接下来不妨写一个用户管理功能吧，CRUD么。Create功能似乎和注册功能疑似，唯一的不同是想做一个导航的功能，也就是说左侧是导航菜单，右侧是目标页面。网页框架的设计原本是很熟悉的，核心不过是用边框为0的表格打框架，iframe用作容器，在超链接的target设置iframe的名字，当年几十个核心页面就是这样搭建起来的。世界毕竟变了，Metronic、Bootstrap这些框架都是用DIV来搭建的。那么如何实现导航功能呢？现在JQuery主流的做法是DIV上通过load来实现。一条核心语句就是$(‘#main-content’).load(url);其中main-content为目标DIV的id。明白了这个做法，底气足了很多，很快通过导航左侧点击，右侧出现添加用户页面就做好了。但提交页面数据的方式，我却改用了Ajax，毕竟这是局部刷新。首先，将form中的数据转化为json格式，通过JQuery的$.ajax方式提交，当然后台Controller对应的方法也@ResponseBody的方式，直接接受json数据，这样的写法似乎更有Spring MVC的样式，最后返回个带有success信息的Map给前端意思下。用户管理功能应该有个表，表的每行都可以删除，编辑啥的，表自然是要分页的。接下来，就被这个DataTables搞死了。为了实现数据列表，我想用JQuery的一个插件库DataTables来实现。最初，我使用原生态的DataTables，样式是难看点，先搞清楚数据渲染么。可前端使用DataTables，后端使用Spring MVC响应的几乎没有正确的样例。将网上最为接近的一个样例反复调试和修改，这才关联了后台数据。接下来是前端分页，还是后端分页这个棘手问题了。quick4j其实已经提供后端分页取数据的方法了，因为DataTables前端可以传入当前即将显示记录页面的“记录的起始索引”和“每页显示的行数”，只要将起始索引转换为页码的索引，即可直接调用后端分页方法，从而获取“记录的起始索引”开始，并且长度为“每页显示的行数”的记录列表了，这是一种典型的后端分页方法，实现过程比我想象的要顺利些。数据渲染正确后，使用Metronic中的DataTables替换原生态的DataTables，发现表格数据并没有显示。调试后发现，Metronic4.1修改了原生态DataTables提交的参数名，比如将“iDisplayStart”改为“start”，“iDisplayLength”改为“length”，不明白Metronic 4.1为何如此修改，因为Metronic 1.5.5和标准的DataTables参数还是一致的。最后，通过查看DataTables提交json的参数，修改了Controller的解析方式，使用Metronic样式的DataTables终于可以显示表格数据了。在每行最后添加“编辑”和“删除”链接之后，真正麻烦的问题出现了，在每次点击“上一页”、“下一页”以及“搜索”等操作都会触发向后台取数据的操作，然而返回后“编辑”和“删除”对应的操作完全丢失，反复出现，不得其解。最后还是在强哥的提醒下，这可能是DOM重建的原因，我恍然大悟。将“编辑”和“删除”对应的功能都写在DataTables的fnDrawCallback回调函数，因为fnDrawCallback回调函数会在“初始化、上一页、下一页以及搜索”等情况下会触发。至于编写“编辑”链接相应的功能则较为简单，特别要注意的是，在DIV load的时候要传递当前需要编辑的记录信息，传递的格式为json，毕竟在编辑功能是在原有数据上进行修改，而jsp页面则可通过request.getParameter来获取数据。只剩下删除操作了，不同于编辑功能，点击编辑时会在列表的上方DIV中显示编辑界面，点击删除链接时，应弹出用于提示用户确认的模式对话框。我看了下Metronic的模板页，正好利用原有页面中的id=”portlet-config”的一个div，可以用作模式对话框。接下来的问题是如何通过js向这个div传递当前记录的编号。我在portlet-config这个div中添加了一个隐藏输入框，然后在js中将该隐藏输入框的值设置为当前记录编号。这样，在提交模式对话框时，当前记录编号便被传递至模式对话框所对应的js中，之后再将该记录编号组建成一个json数据，通过Ajax向后台发送一个异步请求，后台的响应和“编辑”类似。当然为了获取模式对话框“确定”还是“取消”，还需要一个页面级的开关变量来控制。至此，这个想到哪写到哪的程序，已经具备了用户登录，注册以及关于用户的添加、编辑、删除以及通过列表方式查看等基本功能。不过，从业务上来讲，超级用户可通过管理员页面登录，具备管理用户的基本功能，而一般的用户则通过前台页面登录。忽然想到，是否能借助Shiro来实现这些功能。首先要做的是分别建立管理员和一般用户登录页面，以及登录后的主页面。管理员登录后，可以添加、列表查看、删除、编辑以及退出功能。而一般用户可登录、注册以及退出操作。建立好两张登录一页面以及对应的js文件后，分别编写对应的Controller，这样写得目的主要区分不同的url，同时也更加清晰。在处理登录url提交时，首先通过Shiro进行身份验证，然后通过subject记录的用户权限判断是否可跳转到相应的主页。此外，为了防止只有超级用户访问的主页被一般用户访问，可在相应的Controller方法上方添加@RequiresRoles(value = RoleSign.ADMIN)。于是，通过Shiro不仅管理了用户登录、退出，而且能根据权限访问指定页面，实现前台、后台的权限管理。 图 4 MyCRUD的DataTables 给这个程序取了个名MyCRUD，这次编码过程中从GitHub学到了不少，深切的感受了开源的力量。因此，也将此代码上传至GitHub，https://github.com/lacelove/MyCRUD。同时也好好学习了下GitHub的基本用法。首先，在本地安装msysgit以及一个客户端TortoiseGit，利用客户端工具中的puttygen生成一个公钥和私钥。然后注册一个GitHub的账号，在创建repository之后，设置SSH key，也就是客户端生成的公钥。此后，客户端设置好GitHub账号后，就可以Clone、Commit和Push了。其他用户如果获取上述私钥后，也可以直接Commit和Push。当然，其他用户没有私钥的话，则可通过pull request方式贡献自己代码。最后还顺便学习了下GitHub Flavored Markdown来编写RAEDME.md，是用标签控制格式的语法，Latex的感觉，难度不大，简单的写了点。旅行，有些累了，就暂且休息下。过去五年，埋头实时控制系统的设计、开发与测试，忽然抬头看世界，真的变了。这是一次没有最后期限的编程之旅，也是一次陌生世界的探索之旅。一路上，好奇、惊叹一次次冲淡了旅途的疲倦。在没有最后期限，没有需求的设定下，多少重拾了一些编程的乐趣。记得有两部影片，《楚门的世界》和《土拨鼠之日》，主人公的环境非常类似，可最后突破自我的方式却截然不同。在《楚门的世界》里，主人公冒着死亡的危险，也要冲出去看看外面的世界；而《土拨鼠之日》主人公无奈到只能在不断死亡中寻找乐趣，最终还是在这个城市里改变了自我。这个世界，无从选择。也许——走出去，是旅行；只在一处，也是旅行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[运用Fluxion社工高效破解WiFi密码]]></title>
      <url>%2Fblog%2F2017%2F02%2F08%2F%E8%BF%90%E7%94%A8Fluxion%E9%AB%98%E6%95%88%E7%A0%B4%E8%A7%A3WiFi%E5%AF%86%E7%A0%81%2F</url>
      <content type="text"><![CDATA[fluxion是一款无线安全测试工具，其攻击的原理更偏向于社会工程学中的钓鱼。fluxion有一个人性化的脚本，可以迅速帮你检查所需要的插件并进行安装，可以在短时间内搭建出一个完整的wifi渗透环境。省去了敲命令行的繁琐，新版本增加了对中文的支持。 github地址：deltaxflux/fluxion 工作原理（大体步骤） 1.扫描能够接收到的WIFI信号 2.抓取握手包(这一步的目的是为了验证WiFi密码是否正确) 3.使用WEB接口 4.启动一个假的AP实例来模拟原本的接入点 5.然后会生成一个MDK3进程。如果普通用户已经连接到这个WiFi，也会输入WiFi密码 6.随后启动一个模拟的DNS服务器并且抓取所有的DNS请求，并且会把这些请求重新定向到一个含有恶意脚本的HOST地址 7.随后会弹出一个窗口提示用户输入正确的WiFi密码 8.用户输入的密码将和第二步抓到的握手包做比较来核实密码是否正确 9.这个程序是自动化运行的，并且能够很快的抓取到WiFi密码 环境设置 目标WIFI SSID:WIFITEST(360安全路由器p1) 目标设备：Redmi Note 3（模拟目标wifi的主人） 操作机：Kali 2016.2（Penetration Testing and Ethical Hacking Linux Distribution） 安装我们直接在github将所有文件克隆到本机，当然你也可以自行下载然后解压。git clone https://github.com/deltaxflux/fluxion.git下载完成所有文件及文件路径启动 ./fluxion 启动后会自动检测本机是否安装其所依赖的其他软件，如果任意一项不存在软件会自动退出并提示缺少的工具 fluxion目录下有一个‘Installer.sh’脚本文件，运行后会自动更新或安装缺少的工具。 ./Installer.sh 这个过程可能需要很长一段时间，更新安装完成如图 再次启动，出现用户协议 正菜开始在经过用户协议及软件检查更新后，就进入了我们今天的正菜，下面我将介绍每一步的作用。 选择语种，这个工具在更新后增加了对中文的支持，虽然有部分菜单翻译不全，但是还是很良心的，这次我们使用中文，选择‘6’选择信道，我们选择‘1’所有信道fluxion调用aircrack扫描附近WIFI 在找到目标WIFI后按‘Ctrl+c’，fluxion会列出扫描结果并通过id进行选择选择目标后 出现WIFI的基本信息及攻击选项 选择‘1 伪装AP’输入握手包存放路径 我们按回车使用默认路径选择抓取握手包的工具 我们选择第一个 aircrack-ag套件 选择攻击方式 我们选择‘1’对所有目标发起deauthentication攻击（详细介绍：无线攻击利器-mdk3） 出现两个窗口，一个是deauthentication攻击，此时连在目标路由器的客户端会强制解除验证解除连接掉线；另一个是aircrack等待抓取握手包，客户端在掉线后重新连接时会抓取握手包。当在aircrack窗口出现WPA handshake时证明已经抓到握手包，然后我们选择‘1 检查握手包’选择获取密码的方式，第一种 web注入 也是我们今天只要介绍的 第二种跑包（暴力破解）之前的文章已经说过 这里我们选泽‘1’ 选择web页面语言，包括了大部分路由器品牌的页面，当然我们也可以根据自己的需要在 /fluxion/Sites/ 修改页面。本次演示我们选择7 中文通用页面 这时fluxion会调用多个工具对原有路由器进行攻击，并迫使客户端连接到我们伪造的ap中，同时对dns进行欺骗将客户端流量转到我们的钓鱼页面 手机会断开原来的wifi 并连接到我们伪造的ap 并弹出认证页面 由于对dns进行了转发，所以即时关闭认证页面 只要打开任意页面都会转到到这 我们输入错误密码 输入正确密码 在通过对比密码正确后，fluxion会关闭伪造的ap 使客户端重新连接到原来的ap 并给出ap密码 退出程序 你们都说不明白 这次加了一个短视频 可以结合文章步骤作参考。 视频地址： fluxion的使用http://www.iqiyi.com/w_19ru5vgdjt.html 更新： Kali支持的网卡类型： http://www.wirelesshack.org/best-kali-linux-compatible-usb-adapter-dongles-2016.html https://www.aircrack-ng.org/doku.php?id=compatibility_drivers&amp;DokuWiki=ha1cljqc5mnki5hpvmhv1tkfm0#compatibility]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WPA-PSK无线网络破解原理及过程]]></title>
      <url>%2Fblog%2F2017%2F02%2F06%2FWPA-PSK%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E7%A0%B4%E8%A7%A3%E5%8E%9F%E7%90%86%E5%8F%8A%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[无线密码破解的方式主要分为一下几种,抓握手包破解、穷举破解pin码、创建伪AP钓鱼等。以下这篇文章主要讲解利用Kali Linux进行的抓包和跑pin的两种wifi破解方式,文章中所涉及到的命令均为最新版本的Kail Linux命令，请放心食用。 本文将主要讲讲WPA-PSK类型的无线网络安全问题，首先我们看下802.11协议相关的基础知识。 802.11常见的几种认证方式 不启用安全 WEP WPA/WPA2-PSK（预共享密钥） WPA/WPA2 802.1X （radius认证）具体在路由器的配置界面一般如下图所示：WPA-PSK的认证过程由于我这里主要分析wpa-psk类型的认证方式，所以这里就不讨论其他的认证方式了，通过抓包分析，我们可以看到wpa-psk的大致认证过程分为以下几步。 无线AP定期发送beacon数据包，使无线终端更新自己的无线网络列表。 无线终端在每个信道（1-13）广播ProbeRequest（非隐藏类型的WiFi含ESSID，隐藏类型的WiFi不含ESSID）。 每个信道的AP回应，ProbeResponse，包含ESSID，及RSN信息。 无线终端给目标AP发送AUTH包。AUTH认证类型有两种，0为开放式、1为共享式（WPA/WPA2必须是开放式）。 AP回应网卡AUTH包。 无线终端给AP发送关联请求包associationrequest数据包。 AP给无线终端发送关联响应包associationresponse数据包。 EAPOL四次握手进行认证（握手包是破解的关键）。 完成认证可以上网。#802.11数据帧类型说明802.11协议的帧类型主要包括管理帧和数据帧，我们这里主要用到管理帧：管理帧的主体包含的固定字段与信息元素是用来运送信息的。管理帧主要以下几种，负责链路层的各种维护功能。 Beacon 信标帧主要用来声明某个网络的存在。定期（默认100s、可自己设置）传送的信标可让station得知网络的存在，从而调整加入该网络所必需的参数。 Probe Request 探查请求帧移动工作站利用Probe Request探查请求帧来扫描区域内目前哪些802.11网络。包含2个字段SSID：可被设定为特定网络的 SSID 或任何网络的 SSID 。Support rates：移动工作站所支持的速率。 ProbeResponse探查响应帧如果ProbeRequest所探查的网络与之兼容，该网络就会以ProbeResponse帧响应。送出最后一个beacon帧的工作站必须负责响应所收到的探查信息。Probe Request帧中包含了beacon帧的所参数，station可根据它调整加入网络所需要的参数。 IBSS announcement traffic indication map (ATIM)IBSS 的通知传输只是消息 Disassociation and Deauthentication取消关联、解除验证帧 AssociationRequest关联请求帧 Reassociation Request重新关联 Association Response and Reassociation Response关联响应、重新关联响应 Authentication身份验证帧 ///Authentication Algorithm Number：用于算法择 Action frame帧传送、关联与身份验证的状态State1 ：未经认证且尚未关联 2 ：已经认证但尚未关联 3 ：已经认证且已经关联。下图是用科来分析数据包显示的帧类型：WPA-PSK认证四次握手认证的过程WPA-PSK破解原理用我们字典中的PSK+ssid先生成PMK（此步最耗时，是目前破解的瓶颈所在），然后结合握手包中的客户端MAC，AP的BSSID，A-NONCE，S-NONCE计算PTK，再加上原始的报文数据算出MIC并与AP发送的MIC比较，如果一致，那么该PSK就是密钥。如图所示：WPA-PSK破解过程接下来我们看看如何进行抓握手包破解WPA-PSK的无线AP，我这里用的工具是kali Linux，kali Linux集成了aircrack套件。然后网卡使用的是rtl8187芯片的外置USB网卡。破解步骤如下：第一步：把usb网卡插入虚拟机，并开启网卡到监听模式，命令如下：“ifconfig wlan0 up” 加载usb网卡。‍‍“airmon-ng start wlan0” 监听模式已激活到mon0。（通过config 命令查看）。如果不开启监听模式会报错如下图：第二步：抓包查看有哪些无线网络，抓包的界面如下图所示：“airodump-ng wlan0mon” 查看周边路由AP的信息。 个人经验一般信号强度大于-70的可以进行破解，大于-60就最好了，小于-70的不稳定，信号比较弱。（信号强度的绝对值越小表示信号越强）第三步：选择要破解的WiFi，有针对性的进行抓握手包，命令如下：“airodump -w sofia -c 3 –bssid C8:3A:35:5E:93:C0 wlan0mon”参数说明：-w 保存数据包的文件名 –c 信道 –bssid ap的mac地址(注意test.cap会被重命名)，也可以用其他工具抓包比如：wireshark、tcpdump，抓到握手包会有提示。第四步：为了顺利抓到握手包，我们需要使用DEAUTH攻击使已经连接的客户端断开并重新连接，以产生握手包。（注意：抓握手包破解必须有合法的客户端才行。）攻击命令如下：“aireplay-ng-0 111 -a ap’mac wlan0mon” (111次)“aireplay-ng-0 3 -a B8:A3:86:63:B4:06 -c 00:18:1a:10:da:c9 -x 200 wlan0mon” (3次)“aireplay-ng -0 0 -a C8:3A:35:5E:93:C0” (循环发送)参数说明：-0 Deautenticate 冲突模式 3 发包次数 -x 发包速度抓包可以看到很多deauthentication类型的数据包：包结构如下：抓到的数据包打开后如下图：图中使用wireshark打开的，EAPOL类型的数据包共有4个，即四次握手的数据包。第五步：接下来就是破解握手包，命令如下：“aircrack-ng-w pass-haoyong.txt test-03.cap”参数解释：-w 字典路径也可以使用图形化工具EWSA进行破解，Elcomsoft Wireless Security Auditor（EWSA）号称可以利用GPU的运算性能快速攻破无线网络密码，运算速度相比使用CPU可提高最多上百倍。上面我们讲解了通过抓握手包破解WPA-PSK认证的无线AP的全过程，从上述过程可以看出，如果AP没有合法的客户端连接，或者密码设置的足够复杂就基本上不可能破解。 通过WPS破解无线路由器密码接下来我们看一下另一种破解方式，也就是常说的pin码破解后者叫wps破解。首先了解下什么是wps：WPS(Wi-FiProtected Setup，Wi-Fi保护设置)是由Wi-Fi联盟组织实施的认证项目，主要致力于简化无线网络的安全加密设置。功能：简化配置，快速配置一个基于WPA2的网络。快速连接，输入pin码或按下WPS键即可完成网络连接。问题：由于WPS存在漏洞，通过PIN码可以直接提取上网密码。通过WPS快速配置无线路由器我们可以通过WPS快速配置无线路由器：步骤如下1、通过电脑连接新买的无线路由器，提示通过pin码进行设置，界面如下：2、输入pin码下一步，就会为路由器自动生成一个足够复杂的认证方式及密码： 通过WPS快速连接已有网络我们也可以通过WPS快速连接已有网络，不用输入复杂的密码：步骤如下（我使用小米手机进行测试）1、在手机上选择通过PIN码进行连接或通过路由器上的WPS按键连接。2、如果选择前者只需要输入pin码即可连接，如果选择的是后者则只需要按以下路由器上的wps键即可完成连接。 Pin码破解的原理由于WPS存在安全问题，通过PIN码可以直接提取上网密码。而pin码是一个8位的整数，破解过程时间比较短。WPS PIN码的第8位数是一个校验和，因此黑客只需计算前7位数。另外前7位中的前四位和后三位分开认证。所以破解pin码最多只需要1.1万次尝试，顺利的情况下在3小时左右。Wps认证流程如下图： 破解的操作步骤第一步：Wash 扫描开启WPS的网络。“wash-i wlan0mon –C”第二步：穷举破解pin码，并通过获取的pin码得到无线AP上网密码。“reaver-i wlan0mon -b 5C:63:BF:BA:44:DC -a -S -vv”reaver参数说明： -i 监听后接口称号‍‍ -b APmac地址 -a 主动检测AP最佳配置 -S 利用最小的DH key（能够进步PJ速度） -v、-vv 显示更多的破解信息 -d 即delay每穷举一次的闲置时候预设为1秒 -t 即timeout每次穷举守候反应的最长时候 -c指定频道能够便当找到信号，如-c1 指定1频道如果无线路由器没开wps功能会报错如下图：另外破解过程中无线路由器会有如下特征：破解成功后如下：如果之前破解的无线路由器密码被改了，可以直接通过pin码获取密码，命令如下：“reaver-i mon0 -b MAC -p PIN8位数”上面就是通过pin码破解无线路由器密码的全过程，可见开启wps功能并不安全，建议最好不要开此功能。最后介绍几个图形界面的工具：常用的图形界面的工具有水滴、打气筒、奶瓶：这些工具只是将Aircrack-ng、 reaver打包图形化，即为Aircrack-ng套件的GUI。 Aircrack-ng是一个与802.11标准的无线网络分析关的安全软件，主要功能：网络侦测，数据包嗅探，WEP和WPA/WPA2-PSKPJ。 reaver，专用来pin PJ的软件、一般都集成在水滴等里面了。 另外我们常用的注：beini/CDlinux/xiaopan都是小型linux系统，已集成了上述工具。下图为水滴的界面。安全建议 使用WPA2认证，不要使用wep或无认证。 为无线网路设置复杂的密码。 关闭WPS功能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[穴居人]]></title>
      <url>%2Fblog%2F2016%2F12%2F13%2F%E7%A9%B4%E5%B1%85%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[转自08年新概念的一篇文章，《黑夜的力量》，阳光地带网，红客联盟，2001年五月一日的黑客大战，PoizonBox，Wired.com，lion，《The Art of Deception》…… 这间房设备很少，一片昏暗，没有开灯。窗户是唯一能够射进阳光的地方，却被厚厚的古铜色落地窗帘严严实实地遮挡。从那几绺连接着窗与帘的蛛网看，窗像一个世纪没被碰过似的。底下是一张茉莉白单人床，床上堆满了各类网络书籍。床边有一张小桌，桌上有一台电脑和五六个仍未来得及扔的方便面盒。地下满是头皮屑。总体看去，这里简陋得像白垩纪的天然洞穴，陈旧得像中世纪的古堡，阴幽得像地狱里的桃源。 房间的主人就是穴居人。他很少出门，一台台式旧电脑加上电话线，就是他的整个世界。 他，棕黄的皮肤，苍白的脸，蓬乱的头发下一双厚厚的金丝架眼镜，颔下有点点杂乱的须，爱因斯坦式的嘴唇，明明二十岁的年纪，却花白了头发，像六十岁的疲惫的老人。连天的熬夜，使得他的双眼浮肿，像金鱼的眼，黑眼圈顺着脸颊下滑，侵占去大半张有雀斑的脸。他不修边幅，穿着一条嫌小的黑白格子水蓝底T-shirt,铁灰的短裤，把他裹的像冬夜里的毛毛虫茧。衣服上黑斑点点，好像很久没有换过。 他怕见光，怕见生人，像威廉古堡里的嗜血鬼。他的生物钟与普通人截然相反，白天昏睡，晚上才起身。他常常这么做，好像这是理所当然。 电脑忠诚地工作着，音响里唱着栗子撕心裂肺的声音：我们在黑夜里逆风飞行/我们是黑夜里的中国之鹰/我们用黑夜里黑色的眼睛/迎接光明的来临…… 这是多年前脍炙人口的《黑夜的力量》，这是一首曾给他带来无限遐想，光明和力量的歌，而此刻听起，何以叫他如此心伤？ 回忆这东西若是可以言喻，便是未熟的猕猴桃，酸而苦楚。是朵云轩信筏上的一滴泪珠，陈旧而凄迷。每每想起，总会令人黯然神伤。“想当年……”，他的唇微微翕动，抬起自己的枯瘦的左手，手掌上食指与拇指之间的线跌宕起伏。不经意间，泪模糊了视线。 网络像一个浓妆艳服纹身，蛇一样扭动着身躯跳着艳舞的妙龄女子，用那朱红的唇袅娜身姿招徕更多人驻足；又像一潭隐蔽在绿叶红花中的毒水，令深陷其中的人无法自拔。她是美丽的，迷离的。善男信女在这里游戏人生。她是单细胞的，超现实的。人性在这里表现得淋漓尽致，是褪去一层现实的缘故。贪婪，虚荣，好胜，幼稚。人的弱点在这里尽是赤裸裸的。 这里生活着一群特殊的群体——黑客，他们是武侠小说里劫富济穷的侠士，是希腊神话里带来圣火的普罗米修斯。他们热爱技术，沉浸于对未知的探索。 在黑客的圈子里，穴居人是赫赫有名的Scorpio。 Scorpio已经不记得他是如何进入这一行的，他只晓得，他大概已经在这一行干了一年半了吧？不，也许更久。他有个奇怪的嗜好，那就是在网络里游荡，像一只乖戾的蜘蛛，迅速地攻破一台台陌生的主机，在视窗里偷窥别人的一举一动。有时会看见别人在玩泡泡堂，在聊天，抑或在看黄色图片——最有趣的一次，是看到一个男人在传奇里男扮女妆，然后骗取另一个人的钱财，瞧那嗲得让人心里发颤的语气，想象着那个男人的用心良苦和人妖的兰花指，他不禁捧腹大笑——尽管如此，他决不会在别人的电脑里破坏数据。他会默默地把补丁打上，或者仅仅留下一个文本，告诉那个人应该怎么改进自己的计算机。然后悄然离开，走时，总不忘擦掉自己的“脚印”，像一个彬彬有礼的绅士。 黑客守则第一条规定，不随意破坏任何系统和数据。 “我是一个守规矩的黑客。”他常这么说，并以此自鸣得意。 他一直这样默默地过着，直到有一天他进入一台机子时发现，机子主人在试着破译另一台计算机。分明是一个新手，踉踉跄跄像一个烂醉的赌徒，磕磕碰碰，每一步都耗费了好长一段时间思考。Scorpio索性饶有兴致地看着，看那位菜鸟的行动。 很弱智的做法：他先用流光跑出管理密码，然后打开cmd,用ipc连上，上传木马，设定计划执行时间，最后让机子重启…… 菜鸟手忙脚乱地进入那台主机，什么都没做，迅速注销，然后又去研究另一台主机。Scorpio觉得有趣，便发给他一则消息，这则消息并不像通常人与人之间互相发送的信息那样有瞧头，而且魔幻般地出现在屏幕中央。 我终于察觉了 菜鸟暂时中止对另一台主机的研究行动，开始思考与电脑化空间幽灵的首次接触过程，接着，另一条匿名信息好像从计算机自身深处浮出，掠过屏幕。 我已控制 数年来，我一直在黑暗中挣扎 现在，我终于看到了光明 菜鸟没有反应，主控终端没有动静。许久，菜鸟终于醒悟，开始进行全面查毒。 这是典型的Scorpio式幽默，Scorpio明白一个人若是猛然意识到自己被人监视，感觉会比见到一只真正的幽灵还糟糕。但Scorpio依然喜欢这种方式。 Scorpio与菜鸟交了朋友。他的网名叫Capricorn，很好学。得益于丰厚的数学功底，扎实的英语水平和编程基础，在计算机方面他无疑是有天赋的。 他们加入了红客联盟，无偿地将自己的研究成果公布，受人尊敬。与他们并驾齐驱的，是一个叫Leo的人，在一所不出名的大学，对同性恋颇有研究，有空会往阳光地带网钻，有时会神经质地嚷着“为同性恋正名” ——Scorpio觉得有趣，毕竟这样赤裸裸的宣言在现实中是很难听到的。他们经常聚在一起探讨问题，有时，他们也会谈一些非技术的东西。 他们谈到人生。 Scorpio是个理想主义者，他认为快乐就是幸福，有车子，有房子，一个漂亮的老婆，就够了。Capricorn想要开公司赚大钱。轮到Leo发言，他却一言不发，好不容易挤出一句话：“我一向是走一步算一步的。” …… 日子一天一天过去，谁也无法察觉一场大战悄无声息地酝酿着，2001年四月一日中美撞击事件，成了战争的导火索，空气中弥漫着强烈的火药味，一场无硝烟的战争一触即发。对此，迟钝的Scorpio竟一直没有察觉，直到接到Leo的电话。 “你知道吗？美国的PoizonBox黑客组织目前在积极策划攻击行动，目标就是我国的各大网站，他们还不断唆使更多黑客加入战团，就今天，已有24个站点被攻陷……”Leo说着,语气表现出他的激愤。 Scorpio没有回答,只是对这个数字稍微不相信,想不到国外黑客如此能耐,如果数据可信,这无疑反映出我国网络安全意识的淡薄。 “这是美国Wired.com的消息,这无疑是对我国黑客界的极大侮辱和挑衅—-我们在秘密策划一场黑客反击战,黑倒美国,让他们知道我们是不可欺负的!”Leo说着,传给Scorpio一个光荣.rar文件,然后隐去。 Scorpio将这个文件解压缩,出现两个文件,一个是未写完的程序,另一个是黑夜的力量.mp3 当Scorpio打开编辑器察看文件时,他震惊了: 这是一个几乎完美的程序,他有着小巧的体积,简明的界面,缜密的算法.整个文件有三个功能组成.第一是扫描,通过这个可以搜出主机的漏洞;第二是修改,通过这个可以随意修改漏洞主机的主页;第三是破坏,在获得权限之后,通过这个,只需简单几个按键,便可将服务器上的资料全盘毁灭. Scorpio知道Leo的意思，是想让他完成程序,在分析程序时,他仿佛看到美国黑客们哭爹喊娘地抱头鼠窜. 但他犹豫了,他感到从未有过恐慌,在他的字典里,黑客的存在是创造而不是破坏.这次行动无疑是违背原则的.但是,他们如此气焰嚣张地公然挑战,这口气谁能咽下? 音乐响起,是栗子浑圆雄厚的声音:”我们是中国的鹰派/我们是中国的精英/不管敌人的盾牌是多么的坚硬/我们要知道让他们知道我们的锐利.” Scorpio立即感到一股莫名的冲动,不用说,他已经完全被歌曲的力量感染了.不再犹豫,他灵活修长的手指在键盘上飞跃,像他炽热的心。他的内心仿佛有一团烈火在熊熊燃烧,将整个房间映得通红。他的房间是他的战线,他在为光荣而战.幸好,他没失去理智，他完成了前两个功能的同时,将第三个功能取消。这样不会违背黑客守则。 5月1日,中美黑客大战正式打响.仅仅一天一夜的时间,黑客联盟便宣布被攻陷的52个站点.随后,成千上万的红旗高高飘扬在美国各各网站,5月4日上午9时到11时15分,美国白宫网站被迫关闭.白宫网站新闻负责人吉米说:”大量不明数据同时涌入,堵塞了白宫及其互联网服务提供商的连接通道厖”直到5月7日,战争热潮才慢慢冷却. 在这场战争中,Leo显得张狂了些，他一共入侵了37台主机，他把所有的数据都毁了——他是无所谓原则的。他似乎不担心被报复，因为他在攻击前用东南亚的“僵尸机”做了至少四级的跳板。在电话里，他乐呵呵地向Scorpio炫耀。 战争给中美双方带来的破坏力是巨大的。战后，两国政府宣布大力整顿网络界。黑客界受到极大的压力，许多黑客网站被迫关闭。随着红客联盟领导人lion宣布解散，Scorpio与其他成员的联系急剧减少。人性真是很现实，原本关系很好的两个人，一旦遭遇危机，为避免受牵连，宁愿断绝联系，甚至都不肯承认曾经认识。很久没有Leo的消息，Scorpio数着日子。幸好，Scorpio还有Capricorn，他们常谈一些生活琐事。 Capricorn说他曾经喜欢过一个女孩，他们挺聊得来，只是素未谋面，不久前在上岛咖啡会过一次，那是挺清秀的女孩。只是从那以后他们再也没联系。“数字恋爱里的人们总爱把对方想象成最完美的天使，一旦见了面，发现了他的缺点，海誓山盟也会在顷刻间化为泡沫。” Capricorn说着。“尽管他们常常刻意掩饰，数字恋爱的人真正在意的不外乎两种东西，一是金钱，二是美貌。” Scorpio说自己仿佛是忧郁的聚生体，常常有一种莫名的危机感，总是为各种事情担忧。不善交流，在他不得不向别人解释某样东西时，他总担心别人嫌烦。‘不懂幽默就不要乱开口’，他常听到这句斥责，于是他决定在公共场合永远闭上他的嘴。他经常在网上聊天，在网上聊天的最大好处，就是在说每一句话前可以好好酝酿。他经常忘记回家的路，却从不向人求助。幸好，他总能找到回家的公共汽车。“车子迟迟未到，苦死了等它的人。” Scorpio说道。其实Scorpio也是有爱情故事的。“好多年前吧，有个女孩向我笑了笑，当时我什么都不懂，只觉得她笑得很好。”直到今日，Scorpio依然单身，生活在对她的回忆里。 美好的时光是童年时的白兔糖，含在嘴里，感受着它的甜。只是白兔糖总有化为水的一天，人也终有一天会各奔东西。只怪分离来得太快，太像流星。当Capricorn宣布要留学美国时，Scorpio感到突然，知道事情无法更改，Scorpio只好给他最诚挚的祝福。 一切都仿佛回归了起点，Scorpio又一个人过，直到有一天收到Leo的E-mail,看样子他很困惑： 我毕业了，一切都从头开始，才知道我的大学三年，全在发昏，这世界真奇怪，他们看一张小小的文凭重过一个人本身。我找不到工作了，只能在街上流浪。QQ里的一个陌生人知道了我现在身处的环境，他告诉我现在流行盗游戏账号和装备，还说网游的装备可以卖钱。我问他怎么样盗？他说现在流行用网页木马！我一下子就明白他说的话是什么意思。我没有说什么，我只是轻轻的把他丢进了QQ的黑名单。我真的很鄙视这种行为。当初我学黑客技术的时候，只因一份对黑客技术的执着和追求。从来没有想过通过这种我鄙视的手段去赚钱。 生活像一个蛮不讲理的大财主，当他想要一个人痛苦时，就会千方百计折磨人。眼看着身上的钱一天比一天少，我向现实低下了头。当天晚上我入侵了国内一个人气蛮不错的游戏站点，并且在首页上挂上了一个网页木马盗网游装备。第二天邮箱里就收到满满的一大堆账号和密码。我知道这一大堆账号和密码代表了网游里的人物装备既将到手了。当盗来的网游装备变成了人民币，我看着手中的人民币想了好多…我想我是堕落了。那一晚我彻底的失眠了… Scorpio读着，他的心狠狠地抽搐，耳畔仿佛响起曾经的《黑夜的力量》：我们在网络里自由飞行/我们是网络里的中国之鹰……歌曲没变，音调没变，感觉变了。变得苍白无力。Scorpio仿佛听到碎玻璃的声音。那是他金色的记忆在瓦解，露出空荡荡的椭圆的框架，流出石油般油腻腻黏糊糊的黑水，那是心的眼泪，是酸楚的苦水。 Leo的E-mail接二连三地来到。 我建立了一个网站，专门教人盗QQ,盗游戏币，挂木马。我发现越具破坏力的东西，人们越乐意学。我才知道，现在的人们最热衷的是破坏，黑客守则成了一纸空文，。我再也得不到从前的快乐，我亲手玷污了我所狂热的黑客技术。我既伤害了别人，也伤害了自己。 我不知道这样的日子何时才能结束。也许有一天被抓了，一切都可以结束了…… 看完后，Scorpio一言不发，只是无奈地摇头。 最后一次收到Leo的E-mail,是在一个夏日的午后。窗外下着朦胧的太阳雨，柔和的斜阳射进Scorpio的房间，给洁白的菊花纹床单镶上了淡淡的橘黄。信里，Leo激动地通知Scorpio，他上了报纸，而且是头条。他一连嚷了三遍才罢休，又赶忙寻来网上的截报。文章中称呼他为“网络失足少年”，有一张他的照片。照片上的他，白皙的皮肤，瘦削的脸庞，高颧骨，浓眉毛下嵌着一双无神的眼睛，前额有两三绺乌黑的长发，一直垂到唇边。 原来，在他读完&lt;&gt;后，想用社会工程学骗取银行帐号，却因此暴露了自己的身份和地址。 文章上说，当警察带他离开时，让众人奇怪的是，他并不抵抗，像是自愿被捕似的。 从此以后，再没有Capricorn和Leo的消息，阳光再也射不进Scorpio的房间。Scorpio逃避着现实。在网上，终日孤魂野鬼似的游荡。后记： 电视剧常常误导人，如果稍加注意，会有这样的画面映入我们的眼帘：一个俊俏的小伙子穿着干净的休闲衫，在空旷整洁的大厅前用一台联想手提电脑表演入侵。周围坐满了焦急等待的人，只见帅哥双手在键盘上飞速地跃动，盖了厚厚一成白粉的脸庞也有节奏地一起一伏，炯炯有神的双目直直地盯着屏幕。忽然，帅哥的眉头猛地紧缩，汗从额头上泌了出来。周围的人都摒住了呼吸，空气好像都凝固了。不久，电脑自动地响起来,说：“入侵成功”。帅哥的眉头渐渐舒展开，如释重负地叹了口气，周围的人一愣，过了几秒，立即爆发出雷鸣般的掌声…… 现实中的黑客往往没有电视剧里的那么精彩，那么神秘，那么惬意。他们是有着各自的痛苦与孤独的，所以才将自己寄托给冰冷的网络和黑夜。 故事的背景并不是虚构的，天蝎座（Scorpio）的抑郁，摩羯座（Capricorn）的深沉，狮子座（Leo）的张狂。故事里的人，是很多网络人的缩影。故事里的事，是很多网络人的事。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[感恩节，我的第一篇博客上线了]]></title>
      <url>%2Fblog%2F2016%2F11%2F24%2F%E6%84%9F%E6%81%A9%E8%8A%82%EF%BC%8C%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E4%BA%86%2F</url>
      <content type="text"><![CDATA[有时候一件事情的真相，不是来自于对它的思考，而是来自于对它的感觉。 我的个人博客 zhfeat.cc 上线了，我觉得它是一颗 “未熟的猕猴桃”，虽然酸涩苦楚，但随着时间的沉淀，终会有甘美多汁的那一天。]]></content>
    </entry>

    
  
  
</search>
