<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[基于Maven分模块开发实践]]></title>
      <url>%2Fblog%2F2017%2F06%2F19%2F%E5%9F%BA%E4%BA%8EMaven%E5%88%86%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[我们在java 开发中，最常用的模式是MVC，根据理论讲到 各层完全独立，犹如组件一样，比如：今天DAO层用的Hibernate，明天你可以替换成Mybatis， 控制层今天用struts，也可以替换成springmvc，或者swing项目。这些我们只是强调这种思想，但是我们从来没有真正理解过，因为项目开发我们很少遇到这样场景，代码中我经常会为了寻求简便，或者没注意，各层交叉调用，都会导致后期维护困难。因此学习maven模块分层是十分必要的，一个项目或一个平台会分为很多个子系统，比如会分为：前台、运营管理后台、卖家管理后台、监控、统计、定时任务等辅助系统。这些子系统之间独立部署切又有一定联系。对于这些系统 通常我们业务层和持久层代码重用比较多，但是系统如果独立，我们需要把相关代码copy一份过去，这样带来代码的维护难度。 使用场景所有用Maven管理的真实的项目都应该是分模块的，每个模块都对应着一个pom.xml。它们之间通过继承和聚合（也称作多模块，multi-module）相互关联。那么，为什么要这么做呢？我们明明在开发一个项目，划分模块后，导入Eclipse变成了N个项目，这会带来复杂度，给开发带来不便。 为了解释原因，假设有这样一个项目，很常见的Java Web应用。在这个应用中，我们分了几层： Dao层负责数据库交互，封装了Hibernate交互的类。 Service层处理业务逻辑，放一些Service接口和实现相关的Bean。 Web层负责与客户端交互，主要有一些Structs的Action类。 对应的，在一个项目中，我们会看到一些包名： org.myorg.app.dao org.myorg.app.service org.myorg.app.web org.myorg.app.util 这样整个项目的框架就清晰了，但随着项目的进行，你可能会遇到如下问题： 这个应用可能需要有一个前台和一个后台管理端（web或者swing），你发现大部分dao，一些service，和大部分util是在两个应用中重复的。这样的问题，你一周内遇到了好几次。 实际开发时POM的依赖会越来越多，如果目前只有一个项目（WAR），你不得不新建一个项目依赖这个WAR，这变得非常的恶心，因为在Maven中配置对WAR的依赖远不如依赖JAR那样简单明了，而且你根本不需要org.myorg.app.web。 有人修改了dao，提交到svn并且不小心导致build失败了，你在编写service的代码，发现编译不过，只能等那人把dao修复了，你才能继续进行，很多人都在修改，到后来你根本就不清楚哪个依赖是谁需要的，渐渐的，很多不必要的依赖被引入。甚至出现了一个依赖有多个版本存在。 build整个项目的时间越来越长，尽管你只是一直在web层工作，但你不得不build整个项目。 某个模块，比如util，你只想让一些经验丰富的人来维护，可是，现在这种情况，每个开发者都能修改，这导致关键模块的代码质量不能达到你的要求。我们会发现，其实这里实际上没有遵守一个设计模式原则：“高内聚，低耦合”。虽然我们通过包名划分了层次，并且你还会说，这些包的依赖都是单向的，没有包的环依赖。这很好，但还不够，因为就构建层次来说，所有东西都被耦合在一起了。因此我们需要使用Maven划分模块。 我们会发现，其实这里实际上没有遵守一个设计模式原则：“高内聚，低耦合”。虽然我们通过包名划分了层次，并且你还会说，这些包的依赖都是单向的，没有包的环依赖。这很好，但还不够，因为就构建层次来说，所有东西都被耦合在一起了。因此我们需要使用Maven划分模块。 一个简单的Maven模块结构是这样的： 123456789101112131415---- app-parent |-- pom.xml (pom) | |-- app-util | |-- pom.xml (jar) | |-- app-dao | |-- pom.xml (jar) | |-- app-service | |-- pom.xml (jar) | |-- app-web |-- pom.xml (war) 上述简单示意图中，有一个父项目(app-parent)聚合很多子项目（app-util, app-dao, app-service, app-web）。每个项目，不管是父子，都含有一个pom.xml文件。而且要注意的是，小括号中标出了每个项目的打包类型。父项目是pom,也只能是pom。子项目有jar，或者war。根据它包含的内容具体考虑。 这些模块的依赖关系如下： app-dao –&gt; app-util app-service –&gt; app-dao app-web –&gt; app-service 注意依赖的传递性（大部分情况是传递的，除非你配置了特殊的依赖scope），app-dao依赖于app-util，app-service依赖于app-dao，于是app-service也依赖于app-util。同理，app-web依赖于app-dao,app-util。 用项目层次的划分替代包层次的划分能给我们带来如下好处： 方便重用，如果你有一个新的swing项目需要用到app-dao和app-service，添加对它们的依赖即可，你不再需要去依赖一个WAR。而有些模块，如app-util，完全可以渐渐进化成公司的一份基础工具类库，供所有项目使用。这是模块化最重要的一个目的。 由于你现在划分了模块，每个模块的配置都在各自的pom.xml里，不用再到一个混乱的纷繁复杂的总的POM中寻找自己的配置。 如果你只是在app-dao上工作，你不再需要build整个项目，只要在app-dao目录运行mvn命令进行build即可，这样可以节省时间，尤其是当项目越来越复杂，build越来越耗时后。 某些模块，如app-util被所有人依赖，但你不想给所有人修改，现在你完全可以从这个项目结构出来，做成另外一个项目，svn只给特定的人访问，但仍提供jar给别人使用。多模块的Maven项目结构支持一些Maven的更有趣的特性（如DepencencyManagement），这留作以后讨论。 Maven模块配置这里我们通过eclipse来快速创建maven, 如果使用eclipse创建，预先要安装 M2E - Maven Integration for Eclipse 组件。 创建父工程 app-parent点击右键New-选择Maven，选择 Maven project. 这Maven project 和 Maven Module 区别 在 project 是父工程 ，Module 是创建子工程。 填写 group id, artifact id 这里packageing 选择 pom。 创建子工程 app-service, app-dao, app-util,app-web点击app-parent 右键 创建 maven module 子工程，这里除了app-web 选择 war, 其它类型都选择jar 几个子工程创建完后，结构目录如下所示： POM配置细节app-parent先看app-parent的pom.xml： 12345678910111213141516171819&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.zhfeat&lt;/groupId&gt; &lt;artifactId&gt;app-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;maven parent&lt;/name&gt; &lt;description&gt;maven 分模块架构Demo&lt;/description&gt; &lt;modules&gt; &lt;module&gt;app-web&lt;/module&gt; &lt;module&gt;app-service&lt;/module&gt; &lt;module&gt;app-dao&lt;/module&gt; &lt;module&gt;app-util&lt;/module&gt; &lt;/modules&gt; &lt;build&gt; &lt;defaultGoal&gt;compile&lt;/defaultGoal&gt; &lt;/build&gt;&lt;/project&gt; Maven的坐标GAV（groupId, artifactId, version）在这里进行配置，这些都是必须的。特殊的地方在于，这里的packaging为pom。所有带有子模块的项目的packaging都为pom。packaging如果不进行配置，它的默认值是jar，代表Maven会将项目打成一个jar包。该配置重要的地方在于modules，例子中包含的子模块有app-util, app-dao, app-service, app-war。在Maven build app-parent的时候，它会根据子模块的相互依赖关系整理一个build顺序，然后依次build。 这就是一个父模块大概需要的配置，接下来看一下子模块符合配置继承父模块。 app-util123456789&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.zhfeat&lt;/groupId&gt; &lt;artifactId&gt;app-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;app-util&lt;/artifactId&gt;&lt;/project&gt; app-util模块继承了app-parent父模块，因此这个POM的一开始就声明了对app-parent的引用，该引用是通过Maven坐标GAV实现的。而关于项目app-util本身，它却没有声明完整GAV，这里我们只看到了artifactId。这个POM并没有错，groupId和version默认从父模块继承了。实际上子模块从父模块继承一切东西，包括依赖，插件配置等等。此外app-util配置了一个对于commons-lang的简单依赖，这是最简单的依赖配置形式。大部分情况，也是通过GAV引用的。 app-dao再看一下app-dao，它也是继承于app-parent，同时依赖于app-util： 12345678910111213141516&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.zhfeat&lt;/groupId&gt; &lt;artifactId&gt;app-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;app-dao&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.zhfeat&lt;/groupId&gt; &lt;artifactId&gt;app-util&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 该配置和app-util的配置几乎没什么差别，不同的地方在于，依赖变化了，app-dao依赖于app-util。这里要注意的是version的值为${project.version}，这个值是一个属性引用，指向了POM的project/version的值，也就是这个POM对应的version。由于app-dao的version继承于app-parent，因此它的值就是0.0.1-SNAPSHOT。而app-util也继承了这个值，因此在所有这些项目中，我们做到了保持版本一致。这里还需要注意的是，app-dao依赖于app-util，而app-util又依赖于commons-lang，根据传递性，app-dao也拥有了对于commons-lang的依赖。 app-serviceapp-service依赖于app-dao: 12345678910111213141516&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.zhfeat&lt;/groupId&gt; &lt;artifactId&gt;app-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;app-service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.zhfeat&lt;/groupId&gt; &lt;artifactId&gt;app-dao&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; app-web我们最后看一下app-web： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;com.zhfeat&lt;/groupId&gt; &lt;artifactId&gt;app-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;artifactId&gt;app-web&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;app-web Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.zhfeat&lt;/groupId&gt; &lt;artifactId&gt;app-service&lt;/artifactId&gt; &lt;version&gt;$&#123;project.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;defaultGoal&gt;compile&lt;/defaultGoal&gt; &lt;finalName&gt;app-web&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;8.1.8.v20121106&lt;/version&gt; &lt;configuration&gt; &lt;stopKey&gt;stop&lt;/stopKey&gt; &lt;stopPort&gt;5599&lt;/stopPort&gt; &lt;webAppConfig&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;/webAppConfig&gt; &lt;scanIntervalSeconds&gt;5&lt;/scanIntervalSeconds&gt; &lt;connectors&gt; &lt;connector implementation=&quot;org.eclipse.jetty.server.nio.SelectChannelConnector&quot;&gt; &lt;port&gt;8080&lt;/port&gt; &lt;maxIdleTime&gt;60000&lt;/maxIdleTime&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; app-web依赖于app-service，因此配置了对其的依赖。 由于app-web是我们最终要部署的应用，因此它的packaging是war。为此，你需要有一个目录src/main/webapp。并在这个目录下拥有web应用需要的文件，如/WEB-INF/web.xml。没有web.xml，Maven会报告build失败，此外你可能还会有这样一些子目录：/js, /img, /css … 。 我这里没有建立web.xml配置文件，app-web:打包时报Failed to execute goal org.apache.maven.plugins:maven-war-plugin:2.2:war。 解决方案： 如果WebContent/WEB-INF/web.xml文件存在，需要在pom.xml文件的节点中,加上maven-war-plugin插件配置。 1234567891011121314 &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;webResources&gt; &lt;resource&gt; &lt;directory&gt;WebContent&lt;/directory&gt; &lt;/resource&gt; &lt;/webResources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; 如果WebContent/WEB-INF/web.xml文件不存在，则按下面的方式配置。 12345678910 &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; 编译测试看看Maven是如何build整个项目的，我们在 app-parent 根目录中运行 mvn clean install (注意，这里需要把parent工程先install一下，不然会打包失败，提示从远程仓库上找不到依赖)，输出的末尾会有大致这样的内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142[INFO] Scanning for projects...[INFO] ------------------------------------------------------------------------[INFO] Reactor Build Order:[INFO] [INFO] maven parent[INFO] app-util[INFO] app-dao[INFO] app-service[INFO] app-web Maven Webapp[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building maven parent 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ app-parent ---[INFO] Installing D:\biworkspace\app-parent\pom.xml to D:\Repositories\Maven2\com\zhfeat\app-parent\0.0.1-SNAPSHOT\app-parent-0.0.1-SNAPSHOT.pom[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building app-util 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ app-util ---[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 0 resource[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ app-util ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ app-util ---[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 0 resource[INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ app-util ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ app-util ---[INFO] [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ app-util ---[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ app-util ---[INFO] Installing D:\biworkspace\app-parent\app-util\target\app-util-0.0.1-SNAPSHOT.jar to D:\Repositories\Maven2\com\zhfeat\app-util\0.0.1-SNAPSHOT\app-util-0.0.1-SNAPSHOT.jar[INFO] Installing D:\biworkspace\app-parent\app-util\pom.xml to D:\Repositories\Maven2\com\zhfeat\app-util\0.0.1-SNAPSHOT\app-util-0.0.1-SNAPSHOT.pom[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building app-dao 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ app-dao ---[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 0 resource[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ app-dao ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ app-dao ---[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 0 resource[INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ app-dao ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ app-dao ---[INFO] [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ app-dao ---[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ app-dao ---[INFO] Installing D:\biworkspace\app-parent\app-dao\target\app-dao-0.0.1-SNAPSHOT.jar to D:\Repositories\Maven2\com\zhfeat\app-dao\0.0.1-SNAPSHOT\app-dao-0.0.1-SNAPSHOT.jar[INFO] Installing D:\biworkspace\app-parent\app-dao\pom.xml to D:\Repositories\Maven2\com\zhfeat\app-dao\0.0.1-SNAPSHOT\app-dao-0.0.1-SNAPSHOT.pom[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building app-service 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ app-service ---[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 0 resource[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ app-service ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ app-service ---[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 0 resource[INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ app-service ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ app-service ---[INFO] [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ app-service ---[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ app-service ---[INFO] Installing D:\biworkspace\app-parent\app-service\target\app-service-0.0.1-SNAPSHOT.jar to D:\Repositories\Maven2\com\zhfeat\app-service\0.0.1-SNAPSHOT\app-service-0.0.1-SNAPSHOT.jar[INFO] Installing D:\biworkspace\app-parent\app-service\pom.xml to D:\Repositories\Maven2\com\zhfeat\app-service\0.0.1-SNAPSHOT\app-service-0.0.1-SNAPSHOT.pom[INFO] [INFO] ------------------------------------------------------------------------[INFO] Building app-web Maven Webapp 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ app-web ---[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 0 resource[INFO] [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ app-web ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ app-web ---[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent![INFO] Copying 0 resource[INFO] [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ app-web ---[INFO] Nothing to compile - all classes are up to date[INFO] [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ app-web ---[INFO] [INFO] --- maven-war-plugin:3.0.0:war (default-war) @ app-web ---[INFO] Packaging webapp[INFO] Assembling webapp [app-web] in [D:\biworkspace\app-parent\app-web\target\app-web][INFO] Processing war project[INFO] Copying webapp resources [D:\biworkspace\app-parent\app-web\src\main\webapp][INFO] Webapp assembled in [63 msecs][INFO] Building war: D:\biworkspace\app-parent\app-web\target\app-web.war[INFO] [INFO] --- maven-install-plugin:2.4:install (default-install) @ app-web ---[INFO] Installing D:\biworkspace\app-parent\app-web\target\app-web.war to D:\Repositories\Maven2\com\zhfeat\app-web\0.0.1-SNAPSHOT\app-web-0.0.1-SNAPSHOT.war[INFO] Installing D:\biworkspace\app-parent\app-web\pom.xml to D:\Repositories\Maven2\com\zhfeat\app-web\0.0.1-SNAPSHOT\app-web-0.0.1-SNAPSHOT.pom[INFO] ------------------------------------------------------------------------[INFO] Reactor Summary:[INFO] [INFO] maven parent ....................................... SUCCESS [ 0.726 s][INFO] app-util ........................................... SUCCESS [ 2.671 s][INFO] app-dao ............................................ SUCCESS [ 0.094 s][INFO] app-service ........................................ SUCCESS [ 0.098 s][INFO] app-web Maven Webapp ............................... SUCCESS [ 2.004 s][INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 5.815 s[INFO] Finished at: 2017-06-19T00:39:13+08:00[INFO] Final Memory: 14M/258M[INFO] ------------------------------------------------------------------------ 注意Reactor Summary，整个项目根据我们希望的顺序进行build。Maven根据我们的依赖配置，智能的安排了顺序，app-util, app-dao, app-service, app-web。 进入 app-web mvn jetty:run 打开浏览器访问：http://localhost:8080/ 测试是否可以正常访问。 最后，对app-web进行install，success后，你可以在 app-web/target 目录下找到文件 app-web-1.0-SNAPSHOT.war ，打开这个war包，在 /WEB-INF/lib 目录看到了 commons-lang-2.4.jar，以及对应的app-util, app-dao, app-service 的jar包。Maven自动帮你处理了打包的事情，并且根据你的依赖配置帮你引入了相应的jar文件。 总结使用多模块的Maven配置，可以帮助项目划分模块，鼓励重用，防止POM变得过于庞大，方便某个模块的构建，而不用每次都构建整个项目，并且使得针对某个模块的特殊控制更为方便。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CAS单点登录原理及实现]]></title>
      <url>%2Fblog%2F2017%2F06%2F13%2FCAS%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[记得刚入职的时候在公司开发了一套“后台管理系统”，并在该系统的基础上集成了CAS单点登录客服端，实现了单点登录功能，使得在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。同时，我在CAS源码的基础上将其官方登录页面修改为了我自己的样式，提升了系统的可用性和用户体验。温故而知新，这篇文章针对CAS单点登录原理到搭建过程做一个整理和归纳，方便日后我自己理清思路，遇到同类问题可以迅速得出判断并解决。 CAS单点登录原理背景介绍单点登录：Single Sign On，简称SSO，SSO使得在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。 CAS框架：CAS（Central Authentication Service）是实现SSO单点登录的框架。 (Yale 大学发起的一个企业级的、开源的项目，旨在为 Web 应用系统提供一种可靠的单点登录解决方法（属于 Web SSO）) CAS执行部分分析 从结构上看，CAS包含两个部分：CAS Server 和 CAS Client 需要独立部署，主要负责对用户的认证工作； CAS Client负责处理对客户端受保护资源的访问请求，需要登录时，重定向 到CAS Server 图中是CAS最基本的协议过程： CAS Client 与受保护的客户端应用部署在一起，以Filter方式保护 Web 应用的受保护资源，过滤从客户端过来的每一个 Web请求，同时， CAS Client会分析HTTP 请求中是否包含请求 Service Ticket( 上图中的 Ticket) ，如果没有，则说明该用户是没有经过认证的，于是，CAS Client会重定向用户请求到CAS Server（ Step 2 ）。 Step 3是用户认证过程，如果用户提供了正确的Credentials(证书、认证)， CAS Server 会产生一个随机的 Service Ticket，然后，缓存该 Ticket ，并且重定向用户到CAS Client（附带刚才产生的Service Ticket）， ServiceTicket 是不可以伪造的，最后， Step 5 和 Step6 是 CAS Client 和 CASServer之间完成了一个对用户的身份核实，用Ticket查到 Username ，因为 Ticket是 CAS Server产生的，因此，所以 CAS Server 的判断是毋庸置疑的。 该协议完成了一个很简单的任务，所有与CAS的交互均采用SSL协议，确保ST和TGC的安全性。协议工作过程会有两次重定向过程，但是CASClient与CAS Server之间进行ticket验证的过程对于用户是透明的。 总结一下，如下： 访问服务： SSO 客户端发送请求访问应用系统提供的服务资源。 定向认证： SSO 客户端会重定向用户请求到 SSO 服务器。 用户认证：用户身份认证。 发放票据： SSO 服务器会产生一个随机的 Service Ticket 。 验证票据： SSO 服务器验证票据 Service Ticket 的合法性，验证通过后，允许客户端访问服务。 传输用户信息： SSO 服务器验证票据通过后，传输用户认证结果信息给客户端。 进一步搜索、探究相信根据以上的归纳总结，你已经对CAS的工作流程有了一定的了解，那么接下来我们再深入探究一下SSO基本实现思路。 单机Web系统登录机理首先，我们来分析下单Web应用系统登录登出的实现机理。Web系统登录登出功能，通常属于系统安全管理模块的一部分。如上篇所说，登录，意味着用户与系统之间的一次会话开始，登出，意味着本次会话的结束。下图列出整个登录登出会话过程中，用户与系统之间的HTTP交互过程： 如图，服务器内部又做了哪些工作呢？ 通常服务端在用户登录请求到来时(圈1)，会先做认证(Authentication)操作，就是证明这个浏览器请求用户是合法系统用户，一般情况就是验证用户名和密码。 认证通过后，系统紧接着给这个合法用户授权(Authorization)，就是根据该用户在此系统中的权限定义，绑定正确的权限信息，为用户后续正确使用系统功能提供安全保障。 最后建立会话，这个可以基于服务器容器提供的Session机制或自己基于Cookie开发的类似功能，建立起本次会话。 登录成功后，当浏览器后续请求来时(圈2)，服务器需进行登录状态判断，即判别是否处于会话状态，从而识别操作是否是本次登录用户的操作。 登出时，服务端取消会话，本次登录用户会话结束。下次请求时，系统即判断是非登录用户。 程序中简单的代码判断逻辑如下： 1234567891011121314HttpSession sesion = Request.getSesion();//根据请求中的sessionID获取sessionif(session!=null)&#123;//如果sessionID不等于空，则说明是第二次访问//写第二次访问时的代码 &#125;else&#123;//写第一次访问的代码&#125; java web怎么通过sessionid得到session这个我们不需要了解，就是第二次客户端发出请求时，将sessionid也发给了服务器，服务器根据这个唯一的ID找到相应的session(session都是保存在服务器的数据库中，每个session用唯一一个ID所标识），就像是数据库中根据关键字查找数据一样，找到之后就可以直接用这个session里面的数据了。 SSO基本实现思路上面分析了单Web应用登录登出实现机理。那对于多系统的SSO，该如何实现呢？我们先分析下基本实现思路。 有上面分析可知，单Web应用登录，主要涉及到认证、授权、会话建立、取消会话等几个关键环节。推广到多系统，每个系统也会涉及到认证、授权、会话建立取消等工作。那我们能不能把每个系统的认证工作抽象出来，放到单独的服务应用中取处理，是不是就能解决单点登录问题？ 思考方向是正确的，我们把这个统一处理认证服务的应用叫认证中心。当用户访问子系统需要登录时，我们把它引到认证中心，让用户到认证中心去登录认证，认证通过后返回并告知系统用户已登录。当用户再访问另一系统应用时，我们同样引导到认证中心，发现已经登录过，即返回并告知该用户已登录。 由上图可以看出，原先在各系统中的认证模块，已经剥离出来放到独立的认证中心中去执行。至于授权，每个应用都不一样，可维持原样。会话部分，其实分解成了全局会话和局部会话，这个后面再详细解释。 三大关键问题思路是有了，但真正实现这一认证服务器我们还得要具体解决几个关键问题 登录信息传递问题应用系统将登录请求转给认证中心，这个很好解决，我们一个HTTP重定向即可实现。现在的问题是，用户在认证中心登录后，认证中心如何将消息转回给该系统？ 这是在单web系统中不存在的问题。我们知道HTTP协议传递消息只能通过请求参数方式或cookie方式，cookie跨域问题不能解决，我们只能通过URL请求参数。 我们可以将认证通过消息做成一个令牌(token)再利用HTTP重定向传递给应用系统。但现在的关键是：该系统如何判断这个令牌的真伪？如果判断这个令牌确实是由认证中心发出的，且是有效的？ 我们还需要应用系统和认证中心之间再来个直接通信，来验证这个令牌确实是认证中心发出的，且是有效的。由于应用系统和认证中心是属于服务端之间的通信，不经过用户浏览器，相对是安全的。 用户首次登录时流程如下： 用户浏览器访问系统A需登录受限资源，此时进行登录检查，发现未登录，然后进行获取票据操作，发现没有票据。 系统A发现该请求需要登录，将请求重定向到认证中心，获取全局票据操作，没有，进行登录。 认证中心呈现登录页面，用户登录，登录成功后，认证中心重定向请求到系统A，并附上认证通过令牌，此时认证中心同时生成了全局票据。 此时再次进行登录检查，发现未登录，然后再次获取票据操作，此时可以获得票据(令牌)，系统A与认证中心通信，验证令牌有效,证明用户已登录。 系统A将受限资源返给用户。 已登录用户首次访问应用群中系统B时： 浏览器访问另一应用B需登录受限资源，此时进行登录检查，发现未登录，然后进行获取票据操作，发现没有票据。 系统B发现该请求需要登录，将请求重定向到认证中心，获取全局票据操作，获取全局票据，可以获得，认证中心发现已经登录。 认证中心发放临时票据(令牌)，并携带该令牌重定向到系统B。 此时再次进行登录检查，发现未登录，然后再次获取票据操作，此时可以获得票据(令牌)，系统B与认证中心通信，验证令牌有效,证明用户已登录。 系统B将受限资源返回给客户端。 登录状态判断问题用户到认证中心登录后，用户和认证中心之间建立起了会话，我们把这个会话称为全局会话。当用户后续访问系统应用时，我们不可能每次应用请求都到认证中心去判定是否登录，这样效率非常低下，这也是单Web应用不需要考虑的。 我们可以在系统应用和用户浏览器之间建立起局部会话，局部会话保持了客户端与该系统应用的登录状态，局部会话依附于全局会话存在，全局会话消失，局部会话必须消失。 用户访问应用时，首先判断局部会话是否存在，如存在，即认为是登录状态，无需再到认证中心去判断。如不存在，就重定向到认证中心判断全局会话是否存在，如存在，按1提到的方式通知该应用，该应用与客户端就建立起它们之间局部会话，下次请求该应用，就不去认证中心验证了。 登出问题用户在一个系统登出了，访问其它子系统，也应该是登出状态。要想做到这一点，应用除结束本地局部会话外，还应该通知认证中心该用户登出。认证中心接到登出通知，即可结束全局会话，同时需要通知所有已建立局部会话的子系统，将它们的局部会话销毁。这样，用户访问其它应用时，都显示已登出状态。 整个登出流程如下： 客户端向应用A发送登出Logout请求。 应用A取消本地会话，同时通知认证中心，用户已登出。 应用A返回客户端登出请求。 认证中心通知所有用户登录访问的应用，用户已登出。 拨开云雾见青天对以上步骤中的标红部分一一解释1)、问：系统A是如何发现该请求需要登录重定向到认证中心的？ 答：用户通过浏览器地址栏访问系统A，系统A(也可以称为CAS客户端)去Cookie中拿JSESSION，会;话session的id，如果拿到了，说明用户已经登录，如果未拿到，说明用户未登录。 2)、问：系统A重定向到认证中心，发送了什么信息或者地址变成了什么？ 答：假如系统A的地址为http://a:8080/ CAS认证中心的服务地址为http://cas.server:8080/ 那么重点向前后地址变化为：http://a:8080/ ————&gt; http://cas.server:8080/?service=http://a:8080/ 由此可知，重点向到认证中心，认证中心拿到了当前访问客户端的地址。 3)、问：登录成功后，认证中心重定向请求到系统A，认证通过令牌是如何附加发送给系统A的？ 答：重定向之后的地址栏变成：http://a:8080/?ticket=ST-XXXX-XXX 将票据以ticket为参数名的方式通过地址栏发送给系统A 4)、问：系统A验证令牌，怎样操作证明用户登录的？ 答：系统A通过地址栏获取ticket的参数值ST票据，然后从后台将ST发送给CAS server认证中心验证，验证ST有效后，CAS server返回当前用户登录的相关信息，系统A接收到返回的用户信息，并为该用户创建session会话，会话id由cookie维护，来证明其已登录。 5)、问：登录B系统，认证中心是如何判断用户已经登录的？ 这块要重点理解! 答：在系统A登录成功后，用户和认证中心之间建立起了全局会话，这个全局会话就是TGT(Ticket Granting Ticket)，TGT位于CAS服务器端，TGT并没有放在Session中，也就是说，CAS全局会话的实现并没有直接使用Session机制，而是利用了Cookie自己实现的，这个Cookie叫做TGC(Ticket Granting Cookie)，它存放了TGT的id,保存在用户浏览器上。 用户发送登录系统B的请求，首先会去Cookie中拿JSESSION，因为系统B并未登录过，session会话还未创建，JSESSION的值是拿不到的，然后将请求重定向到CAS认证中心，CAS认证中心先去用户浏览器中拿TGC的值，也就是全局会话id，如果存在则代表用户在认证中心已经登录，附带上认证令牌重定向到系统B。 上面登录状态判断也是这个逻辑。 6)、问：登出的过程，各个系统对当前用户都做了什么？ 答：认证中心清除当前用户的全局会话TGT，同时清掉cookie中TGT的id：TGC；然后是各个客户端系统，比如系统A、系统B，清除局部会话session，同时清掉cookie中session会话id：jsession 对系统A登录流程图添加注释，查看 cas框架配置详解 安装配置JDK、安装Tomcat7，此处不做详解。 准备工作 下载CAS Server 和 Client： 服务端：cas-server-4.0.0-release.zip 客户端：cas-client-3.2.1-release.zip 部署 将下载的cas-server-4.0.0-release.zip解开，把cas-server-4.0.0/modules/cas-server-webapp-4.0.0.war拷贝到 tomcat的webapps目录，并更名为cas.war。 修改cas\WEB-INF\spring-configuration\ticketGrantingTicketCookieGenerator.xml文件，将属性p:cookieSecure=”true” 变成 p:cookieSecure=”false”（这个设置主要是让CAS不走SSL协议） 注：CAS不用SSL（既用http协议，不用https）不能实现跨域的原因是CAS的TGC（TicketGrantingCookie）生成时设置了安全属性为只能被https协议访问，http协议访问不到。解决方法其实很简单，只要把TGC的安全属性去掉，让它可以被http协议访问就可以了。 使用CAS是为了实现单点登陆功能，就是网上很流行的通行证系统。由于CAS是通行证系统的服务端，涉及到敏感的用户帐户信息，于是我们一般用SSL来保证其通信的安全。SSL可以对通信的内容进行加密，防止通信内容被截取后泄露用户帐户信息。所以说在真正应用中SSL对于CAS还是比较必要的一个配置，不推荐大家放弃用SSL。 启动tomcat，然后访问：http://localhost:8803/cas 如果能出现正常的CAS登录页面，则说明CAS Server 已经部署成功。如下图： 默认账号：casuser 默认密码：Mellon 虽然 CAS Server 已经部署成功，但这只是一个缺省的实现，在实际使用的时候，还需要根据实际概况做扩展和定制，最主要的是扩展认证 (Authentication) 接口和 CAS Server 的界面。 CAS Client配置 如果没有用Maven进行依赖管理，将下载的cas-client-3.2.1-release.zip解开，将cas-client-3.2.1/modules/cas-client-core-3.2.1.jar，放入你的web项目lib目录中。 在pom.xml中配置依赖 123456&lt;!-- cas --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jasig.cas.client&lt;/groupId&gt; &lt;artifactId&gt;cas-client-core&lt;/artifactId&gt; &lt;version&gt;3.1.12&lt;/version&gt; &lt;/dependency&gt; 在客户端项目的web.xml配置过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167 &lt;!-- ======================== 单点登录开始 ======================== --&gt; &lt;!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 该过滤器用于实现单点登出功能，可选配置。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责用户的认证工作，必须启用它 --&gt; &lt;filter&gt; &lt;filter-name&gt;CASFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;http://localhost:8888/cas/login&lt;/param-value&gt;&lt;!-- cas 服务器登录 地址 http://IP:PORT/CasWebProName/login --&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 这里的server是服务端的IP --&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:8080&lt;/param-value&gt;&lt;!-- 客户端服务器地址 http://IP:PORT --&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CASFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责对Ticket的校验工作，必须启用它 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;http://localhost:8888/cas&lt;/param-value&gt;&lt;!-- cas 服务器地址 http://IP:PORT/CasWebProName --&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:8080&lt;/param-value&gt;&lt;!-- 客户端服务器地址 http://IP:PORT --&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责实现HttpServletRequest请求的包裹， 比如允许开发者通过HttpServletRequest的getRemoteUser()方法获得SSO登录用户的登录名，可选配置。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。 比如AssertionHolder.getAssertion().getPrincipal().getName()。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- ======================== 单点登录结束 ======================== --&gt; &lt;/web-app&gt; [xml] view plain copy&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;CasClientOne&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- ======================== 单点登录结束 ======================== --&gt; &lt;!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 该过滤器用于实现单点登出功能，可选配置。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.session.SingleSignOutFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Single Sign Out Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责用户的认证工作，必须启用它 --&gt; &lt;filter&gt; &lt;filter-name&gt;CASFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.authentication.AuthenticationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerLoginUrl&lt;/param-name&gt; &lt;param-value&gt;http://localhost:8888/cas/login&lt;/param-value&gt;&lt;!-- cas 服务器登录 地址 http://IP:PORT/CasWebProName/login --&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 这里的server是服务端的IP --&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:8080&lt;/param-value&gt;&lt;!-- 客户端服务器地址 http://IP:PORT --&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CASFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责对Ticket的校验工作，必须启用它 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;casServerUrlPrefix&lt;/param-name&gt; &lt;param-value&gt;http://localhost:8888/cas&lt;/param-value&gt;&lt;!-- cas 服务器地址 http://IP:PORT/CasWebProName --&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;serverName&lt;/param-name&gt; &lt;param-value&gt;http://localhost:8080&lt;/param-value&gt;&lt;!-- 客户端服务器地址 http://IP:PORT --&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Validation Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器负责实现HttpServletRequest请求的包裹， 比如允许开发者通过HttpServletRequest的getRemoteUser()方法获得SSO登录用户的登录名，可选配置。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.HttpServletRequestWrapperFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS HttpServletRequest Wrapper Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。 比如AssertionHolder.getAssertion().getPrincipal().getName()。 --&gt; &lt;filter&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;filter-class&gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CAS Assertion Thread Local Filter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- ======================== 单点登录结束 ======================== --&gt; 配置完毕后，启动tomcat，然后访问：http://IP:PORT/login.jsp，如果系统跳转到CAS登录页面，输入用户名/密码（正确的）后，会跳转到http://IP:PORT/login.jsp，则说明CAS Client已经部署成功。 注：到此CAS框架已搭建完毕，此种方法未采用SSL协议(需要修改Cas)，如果想采用SSL协议方式，则在上述配置中需要以下调整： 修改Cas Server所处Web容器（本文为Tomcat），使其支持SSL协议 CAS服务端部署时,不需要修改cas\WEB-INF\spring-configuration\ticketGrantingTicketCookieGenerator.xml CAS客户端中,web.xml中配置的Cas Server相关地址需要将http变更成https JDBC认证方式相关JAR包准备cas-server-4.0.0-release.zip\cas-server-4.0.0\modules\cas-server-support-jdbc-4.0.0.jar及相应的数据库驱动包（这里是MySQL驱动mysql-connector-java-5.1.7-bin.jar）复制到cas/WEB-INF/lib目录下。 修改deployerConfigContext.xml12345678910111213141516171819202122232425262728293031 &lt;!-- 注释掉原本固定登录用户 --&gt;&lt;!-- &lt;bean id="primaryAuthenticationHandler" --&gt;&lt;!-- class="org.jasig.cas.authentication.AcceptUsersAuthenticationHandler"&gt; --&gt;&lt;!-- &lt;property name="users"&gt; --&gt;&lt;!-- &lt;map&gt; --&gt;&lt;!-- &lt;entry key="casuser" value="Mellon"/&gt; --&gt;&lt;!-- &lt;/map&gt; --&gt;&lt;!-- &lt;/property&gt; --&gt;&lt;!-- &lt;/bean&gt; --&gt; &lt;!-- 变更为JDBC验证方式 --&gt; &lt;bean id="primaryAuthenticationHandler" class="org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;property name="sql" value="select password from user where user_name=?"&gt;&lt;/property&gt; &lt;property name="passwordEncoder" ref="MD5PasswordEncoder"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 数据源配置 --&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;&lt;property name="driverClassName"&gt;&lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;&lt;/property&gt;&lt;property name="url"&gt;&lt;value&gt;jdbc:mysql://localhost:3306/testCas?characterEncoding=utf8&lt;/value&gt;&lt;/property&gt;&lt;property name="username"&gt;&lt;value&gt;root&lt;/value&gt;&lt;/property&gt;&lt;property name="password"&gt;&lt;value&gt;root&lt;/value&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 添加MD5密码加密功能 --&gt;&lt;bean id="MD5PasswordEncoder" class="org.jasig.cas.authentication.handler.DefaultPasswordEncoder"&gt;&lt;constructor-arg index="0"&gt;&lt;value&gt;MD5&lt;/value&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 客户端获取用户登录信息CAS登录成功默认返回的只有用户名， JAVA客户端获取：12AttributePrincipal principal = (AttributePrincipal) request.getUserPrincipal(); String username = principal.getName(); 而在实际应用中，客户端需要知道更多的用户信息，比如用户的性别，年龄，爱好，地址，用户的分组，角色信息等等，下面介绍如何给客户端返回更多的用户资料和信息： 修改cas/WEB-INF/deployerConfigContext.xml，注释掉原有的attributeRepository及attributeRepository的引用信息，添加如下信息： 123456789101112131415161718192021222324252627&lt;bean id="attributeRepository" class="org.jasig.services.persondir.support.jdbc.SingleRowJdbcPersonAttributeDao"&gt; &lt;constructor-arg index="0" ref="dataSource"/&gt; &lt;constructor-arg index="1" value="select * from user where &#123;0&#125;"/&gt; &lt;!-- &lt;constructor-arg index="1" value="select * from user where &#123;0&#125; &#123;1&#125;"/&gt; --&gt; &lt;!-- 组装sql用的查询条件属性 --&gt; &lt;property name="queryAttributeMapping"&gt; &lt;map&gt; &lt;!-- 这里的key需写username，value对应数据库用户名字段 --&gt; &lt;entry key="username" value="user_name"/&gt; &lt;!-- &lt;entry key="id" value="id"/&gt; --&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 如果要组装多个查询条件，需要加上下面这个，默认为AND --&gt; &lt;property name="queryType"&gt; &lt;value&gt;OR&lt;/value&gt; &lt;/property&gt; &lt;!-- 要获取的属性在这里配置 --&gt; &lt;property name="resultAttributeMapping"&gt; &lt;map&gt; &lt;!--key为对应的数据库字段名称，value为提供给客户端获取的属性名字，系统会自动填充值--&gt; &lt;entry key="id" value="id"/&gt; &lt;entry key="user_name" value="username"/&gt; &lt;entry key="phone" value="phone"/&gt; &lt;entry key="email" value="email"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 修改cas/WEB-INF/view/jsp/protocol/2.0/casServiceValidationSuccess.jsp,添加下方虚线中间部分： 1234567891011121314151617181920212223242526&lt;cas:serviceResponse xmlns:cas='http://www.yale.edu/tp/cas'&gt;&lt;cas:authenticationSuccess&gt;&lt;cas:user&gt;$&#123;fn:escapeXml(assertion.primaryAuthentication.principal.id)&#125;&lt;/cas:user&gt;-----------------------------------------------------------------------&lt;%-- 返回更多用户信息配置 By Goma --%&gt;&lt;c:if test="$&#123;fn:length(assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes) &gt; 0&#125;"&gt; &lt;cas:attributes&gt; &lt;c:forEach var="attr" items="$&#123;assertion.chainedAuthentications[fn:length(assertion.chainedAuthentications)-1].principal.attributes&#125;"&gt; &lt;cas:$&#123;fn:escapeXml(attr.key)&#125;&gt;$&#123;fn:escapeXml(attr.value)&#125;&lt;/cas:$&#123;fn:escapeXml(attr.key)&#125;&gt; &lt;/c:forEach&gt; &lt;/cas:attributes&gt; &lt;/c:if&gt; ----------------------------------------------------------------------- &lt;c:if test="$&#123;not empty pgtIou&#125;"&gt; &lt;cas:proxyGrantingTicket&gt;$&#123;pgtIou&#125;&lt;/cas:proxyGrantingTicket&gt; &lt;/c:if&gt; &lt;c:if test="$&#123;fn:length(assertion.chainedAuthentications) &gt; 1&#125;"&gt; &lt;cas:proxies&gt; &lt;c:forEach var="proxy" items="$&#123;assertion.chainedAuthentications&#125;" varStatus="loopStatus" begin="0" end="$&#123;fn:length(assertion.chainedAuthentications)-2&#125;" step="1"&gt; &lt;cas:proxy&gt;$&#123;fn:escapeXml(proxy.principal.id)&#125;&lt;/cas:proxy&gt; &lt;/c:forEach&gt; &lt;/cas:proxies&gt; &lt;/c:if&gt;&lt;/cas:authenticationSuccess&gt;&lt;/cas:serviceResponse&gt; 3.客户端取值12345AttributePrincipal principal = (AttributePrincipal) request.getUserPrincipal(); String username = principal.getName(); Map&lt;String,Object&gt; attributes = principal.getAttributes();String email = attributes .get("email") + ""; 界面定制CAS 提供了一套默认的页面，在目录cas/WEB-INF/view/jsp/default下。在部署 CAS 之前，我们可能需要定制一套新的CAS Server页面，添加一些个性化的内容。最简单的方法就是拷贝一份 default文件到“ cas/WEB-INF/view/jsp ”目录下，比如命名为newUI，接下来是实现和修改必要的页面，有 4 个页面是必须的： casConfirmView.jsp: 当用户选择了“warn”时会看到的确认界面 casGenericSuccess.jsp: 在用户成功通过认证而没有目的Service时会看到的界面 casLoginView.jsp: 当需要用户提供认证信息时会出现的界面 casLogoutView.jsp: 当用户结束 CAS 单点登录系统会话时出现的界面 CAS 的页面采用 Spring框架编写，对于不熟悉 Spring 的使用者，在修改之前需要熟悉该框架。 页面定制完过后，还需要做一些配置从而让 CAS 找到新的页面，拷贝cas/WEB-INF/classes/default_views.properties，重命名为as/WEB-INF/classes/ newUI_views.properties，并修改其中所有的值到相应新页面。最后是更新cas/WEB-INF/cas.properties文件中的 cas.viewResolver.basename，将default_views更改为newUI_views。 其他功能扩展增加验证码、密码有效期、限制用户登录之类的功能这里不做描述，如果需要请自行查找。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis实现消息队列]]></title>
      <url>%2Fblog%2F2017%2F06%2F02%2Fredis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%2F</url>
      <content type="text"><![CDATA[消息队列，通俗点说就是消息传输过程中暂时保存消息的容器，可以在不同平台、不同语言的应用之间传输数据，并且可以异步地实现数据写入，在处理大并发问题时能起到很好的效果。 在我开发的BI项目中，由于导出操作很频繁，数据量很大，同步导出会使数据库使用率很高，所以需要分批次的对数据进行excel导出。但是分批次导出的过程中，会出现其他导出任务也会执行的并发问题，所以采用了redis的阻塞队列，对导出任务进行管理，进行异步导出，按任务顺序依次执行，完全可以满足我的需求，这篇文章就介绍下reids消息队列的使用场景和使用方式。 使用场景一个消息队列的简单使用场景： 我的系统需要实时接收来自客户端的请求（周期性请求），并且将请求的数据保存在数据库，每次请求的数据量很小，但是由于需要频繁操作数据库，所以系统遭遇到性能瓶颈。原先的想法是直接将这些数据保存在Redis中，但仔细想想，虽然每次的数据量不大，但是由于数据是周期性的并且会不断增长，虽然redis也有持久化功能，但如果依靠持久化到硬盘来保存，就失去了redis作为内存数据库的优势。 解决方案最终决定使用消息队列，方式如下： 每次请求的数据直接写入消息队列，然后给予客户端响应，后台开启一个线程监听消息队列，一旦有数据写入，取得消息队列中的数据写入MySQL数据库，这样就可以实现异步地将实时数据写入数据库，避免系统因直接操作数据库造成的瓶颈。 消息队列的选择那么问题来了，使用哪种消息队列，现在比较主流的消息队列如:RabbitMQ，ActiveMQ等，其技术比较成熟效率也很高。但是考虑到项目本身已经使用了redis（做缓存），并且每次的数据量比较小，而redis不仅仅是一个key-value数据库，它支持丰富的数据类型，如HashMap、Set、List等，其中的List完全可以作为消息队列使用，并且redis的List支持blpop，brpop等阻塞式的命令，完全可以满足我的需求。 reids 阻塞队列demo简单的测试代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//产生数据import redis.clients.jedis.Jedis;public class RedisProducer &#123; /** * jedis操作List */ public static void main(String[] args)&#123; Jedis jedis = new Jedis("192.168.10.209", 6379); for(int i = 0;i&lt;10;i++) &#123; jedis.lpush("informList","value_" + i); &#125; jedis.close(); &#125;&#125;//消费数据import java.util.List;import redis.clients.jedis.Jedis;public class RedisConsumer &#123; /** * jedis操作List */ public static void main(String[] args)&#123; ScheduleMQ mq = new ScheduleMQ(); mq.start(); &#125; &#125;class ScheduleMQ extends Thread &#123; @Override public void run() &#123; while(true) &#123; Jedis jedis = new Jedis("192.168.10.209", 6379); //阻塞式brpop，List中无数据时阻塞 //参数0表示一直阻塞下去，直到List出现数据 List&lt;String&gt; list = jedis.brpop(0, "informList"); for(String s : list) &#123; System.out.println(s); &#125; jedis.close(); &#125; &#125;&#125; 注意事项BlPOP 会阻塞list的取出元素的操作.如果list为空,那么blpop就会一直等待,直到超时.有元素添加到list.这时才会取出元素,解除阻塞.会送值为key 和第一个元素值 lpush 采用头插法 向list添加数据。 brpop和blpop区别就是一个从一个从list末尾去数据.list开始出取数据,blpop和brpop取出数据之后会删除list中的数据,如果这时候redis客户端挂了.那个数据就永远丢失了.redis提供了一种备用机制. BRPOPLPUSH 这个命令会先把pop出来的数据.存到指定的list.然后再把传递给redis客户端,多了一层保障。 1redis 127.0.0.1:6379&gt; BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT Redis Brpoplpush 命令从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素的值，第二个元素是等待时长。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Eclipse中SVN分支创建及合并]]></title>
      <url>%2Fblog%2F2017%2F05%2F09%2FEclipse%E4%B8%ADSVN%E5%88%86%E6%94%AF%E5%88%9B%E5%BB%BA%E5%8F%8A%E5%90%88%E5%B9%B6%2F</url>
      <content type="text"><![CDATA[在进行项目开发时，比较稳妥的做法是确定一个稳定的主干版本，用于线上发布，基于主干版本建立一个分支版本，用于bug调试和新功能开发。分支版本在发布到测试服务器测试通过后，再从分支将代码合并到主干。这样就有效的避免了频繁的在一套程序上进行bug修改和新功能增加，导致项目处于不稳定状态。 问题起因 在进行项目开发时，由于我开发的项目中为其他项目提供了接口，导致其他项目在批量上线时出现版本不一致的问题，具体原因是因为调用我接口的项目同时部署在了集团内的多家影院内，上线时间不同步，导致一部分升级到了最新的版本，一部分还停留在旧版本。但是我为其提供的接口是针对该项目的最新版本的联调开发的，而且我这边因项目需要也上线了几个版本，这样就会出现对方旧版本项目无法使用我这边新版本项目的最新接口的问题。需要我把我的项目代码回滚到旧版本再进行部署，但是由于我再此基础上已经修改了多处bug，增加了很多新功能，所以想回到之前确切的版本十分困难，只能将之前发布的代码进行反编译，抽离出来，进行二次开发。 所以，经项目组讨论，以后再进行开发时，要确定一个主干版本，用于线上发布，针对具体功能基于主干版本建立一个分支版本，用于bug调试和新功能开发，分支版本发布到测试服务器测试通过后，再从分支将代码合并到主干。这样就有效的避免了我在一套程序上进行bug修改，新功能增加，开发工作进行到一半，其他项目组出现了问题，让我回滚代码到旧版本进行适配的问题。 创建分支 创建分支实际上就是将程序(通常是测试通过后运行稳定的一个版本)copy一份到指定的分支目录，如下图示： 分支创建完毕,查看svn资源库中可以看到，分支信息： 分支合并主干切换到分支，如图 切换： 修改分支信息在pojo中新增Test类，并提交到svn中（一定要提交哦！） 切换到主干中，准备合并主干此时主干的pojo中是没有Test类的。 分支合并主干，在主干上操作 主干合并分支修改主干Test类中信息，并提交。 切换到分支中，准备合并分支 主干合并分支，在分支上操作 合并完毕，提交分支代码到svn中 这里分支和主干采用的都是Head版本，仅作为图解示例，项目中使用时From的版本要对应选择分支或者主干的最初版本。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[结合日常开发说说互联网架构为什么要做服务化]]></title>
      <url>%2Fblog%2F2017%2F05%2F02%2F%E7%BB%93%E5%90%88%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E8%AF%B4%E8%AF%B4%E4%BA%92%E8%81%94%E7%BD%91%E6%9E%B6%E6%9E%84%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8C%96%2F</url>
      <content type="text"><![CDATA[在网上看到一篇“互联网架构为什么要做服务化”的文章后。我发现结合我目前开发工作所遇到的问题、遇到的坑，其实都可以根据服务化的方式进行合理解决。无奈我开发的这个项目其实是一套相对独立的，以市场推动为主的项目。五脏俱全但是公司又不会投入太多精力对其进行架构方面的改进和升级。这里贴上这篇文章的目的是为了我后续的工作和面试提供一些参考，也是一个总结。该篇也可算作对之前那篇《SSM集成Dubbo+Zookeeper实现服务化》的一些补充。 一、互联网高可用架构，为什么要服务化？【服务化之前高可用架构】在服务化之前，互联网的高可用架构大致是这样一个架构： 用户端是浏览器 browser ， APP 客户端 后端入口是高可用的 nginx 集群，用于做反向代理 中间核心是高可用的 web-server 集群， 研发工程师主要编码工作就是在这一层 后端存储是高可用的 db 集群，数据存储在这一层 更典型的， web-server 层是通过 DAO/ORM 等技术来访问数据库的。 可以看到，最初都是没有服务层的，此时架构会碰到一些什么痛点呢？ 【架构痛点一：代码到处拷贝】举一个最常见的业务的例子 -&gt; 用户数据的访问，绝大部分公司都有一个数据库存储用户数据，各个业务都有访问用户数据的需求： 在有用户服务之前， 各个业务线都是自己通过 DAO 写 SQL 访问 user 库来存取用户数据，这无形中就导致了代码的拷贝。 【架构痛点二：复杂性扩散】随着并发量的越来越高，用户数据的访问数据库成了瓶颈，需要加入缓存来降低数据库的读压力，于是架构中引入了缓存，由于没有统一的服务层，各个业务线都需要关注缓存的引入导致的复杂性： 对于用户数据的写请求，所有业务线都要升级代码： 先淘汰cache 再写数据 对于用户数据的读请求，所有业务线也都要升级代码： 先读cache，命中则返回 没命中则读数据库 再把数据放入cache这个复杂性是典型的“业务无关”的复杂性，业务方需要被迫升级。 随着数据量的越来越大，数据库需要进行水平拆分，于是架构中又引入了分库分表，由于没有统一的服务层，各个业务线都需要关注分库分表的引入导致的复杂性： 这个复杂性也是典型的“业务无关”的复杂性，业务方需要被迫升级。包括bug的修改，发现一个bug，多个地方都需要修改。 【架构痛点三：库的复用与耦合】服务化并不是唯一的解决上述两痛点的方法，抽象出统一的“库”是最先容易想到的解决： 代码拷贝 复杂性扩散 的方法。抽象出一个user.so，负责整个用户数据的存取，从而避免代码的拷贝。至于复杂性，也只有user.so这一个地方需要关注了。 解决了旧的问题，会引入新的问题，库的版本维护与业务线之间代码的耦合： 业务线A将user.so由版本1升级至版本2，如果不兼容业务线B的代码，会导致B业务出现问题；业务线A如果通知了业务线B升级，则是的业务线B会无故做一些“自身业务无关”的升级，非常郁闷。当然，如果各个业务线都是拷贝了一份代码则不存在这个问题。 【架构痛点四：SQL质量得不到保障，业务相互影响】业务线通过DAO访问数据库： 本质上SQL语句还是各个业务线拼装的，资深的工程师写出高质量的SQL没啥问题，经验没有这么丰富的工程师可能会写出一些低效的SQL，假如业务线A写了一个全表扫描的SQL，导致数据库的CPU100%，影响的不只是一个业务线，而是所有的业务线都会受影响。 【架构痛点五：疯狂的DB耦合】业务线不只访问user数据，还会结合自己的业务访问自己的数据： 典型的，通过join数据表来实现各自业务线的一些业务逻辑。 这样的话，业务线A的table-user与table-A耦合在了一起，业务线B的table-user与table-B耦合在了一起，业务线C的table-user与table-C耦合在了一起，结果就是：**table-user，table-A，table-B，table-C都耦合在了一起。 随着数据量的越来越大，业务线ABC的数据库是无法垂直拆分开的**，必须使用一个大库（疯了，一个大库300多个业务表 =_=）。 二、服务化解决什么问题？为了解决上面的诸多问题，互联网高可用分层架构演进的过程中，引入了“服务层”。 以上文中的用户业务为例，引入了user-service，对业务线响应所用用户数据的存取。引入服务层有什么好处，解决什么问题呢？ 【好处一：调用方爽】有服务层之前：业务方访问用户数据，需要通过DAO拼装SQL访问有服务层之后：业务方通过RPC访问用户数据，就像调用一个本地函数一样，非常之爽User = UserService::GetUserById(uid);传入一个uid，得到一个User实体，就像调用本地函数一样，不需要关心序列化，网络传输，后端执行，网络传输，范序列化等复杂性。 【好处二：复用性，防止代码拷贝】这个不展开叙述，所有user数据的存取，都通过user-service来进行，代码只此一份，不存在拷贝。 升级一处升级，bug修改一处修改。 【好处三：专注性，屏蔽底层复杂度】 在没有服务层之前，所有业务线都需要关注缓存、分库分表这些细节。 在有了服务层之后，只有服务层需要专注关注底层的复杂性了，向上游屏蔽了细节。 【好处四：SQL质量得到保障】 原来是业务向上游直接拼接SQL访问数据库。 有了服务层之后，所有的SQL都是服务层提供的，业务线不能再为所欲为了。底层服务对于稳定性的要求更好的话，可以由更资深的工程师维护，而不是像原来SQL难以收口，难以控制。 【好处五：数据库解耦】 原来各个业务的数据库都混在一个大库里，相互join，难以拆分。 服务化之后，底层的数据库被隔离开了，可以很方便的拆分出来，进行扩容。 【好处六：提供有限接口，无限性能】在服务化之前，各业务线上游想怎么操纵数据库都行，遇到了性能瓶颈，各业务线容易扯皮，相互推诿。服务化之后，服务只提供有限的通用接口，理论上服务集群能够提供无限性能，性能出现瓶颈，服务层一处集中优化。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用Nexus搭建Maven私服]]></title>
      <url>%2Fblog%2F2017%2F05%2F02%2F%E4%BD%BF%E7%94%A8Nexus%E6%90%AD%E5%BB%BAMaven%E7%A7%81%E6%9C%8D%2F</url>
      <content type="text"><![CDATA[私服是架设在局域网的一种特殊的远程仓库，目的是代理远程仓库及部署第三方构件。有了私服之后，当 Maven 需要下载构件时，直接请求私服，私服上存在则下载到本地仓库；否则，私服请求外部的远程仓库，将构件下载到私服，再提供给本地仓库下载。 私服使用场景使用Maven可以对项目的各种依赖进行统一管理，在pom文件中定以好依赖，就可以从Maven中央库或者第三方库中下载到本地。但在企业内部使用也会遇到一些问题，每个使用者都需要去下载相应的依赖包或者插件，效率低下，浪费带宽，所以搭建企业内部的私服就很有必要。 搭建私服后，所有的依赖就可以从私服下载，私服会自动判定，如果私服库里没有这个资源，则私服会自动去网上下载，如果私服已经包含所需资源，则可以通过内网提供给使用者，大大提高工作效率。 我们可以使用专门的 Maven 仓库管理软件来搭建私服，比如：Apache Archiva，Artifactory，Sonatype Nexus。这里我们使用 Sonatype Nexus。Nexus是Maven常用的私服，安装使用都还算方便，适用于搭建企业内部的maven私服。 Nexus常用功能就是：指定私服的中央地址、将自己的Maven项目指定到私服地址、从私服下载中央库的项目索引、从私服仓库下载依赖组件、将第三方项目jar上传到私服供其他项目组使用。 Nexus下载Nexus 专业版是需要付费的，这里我们下载开源版 Nexus OSS。下载地址： 传送门 网站上提供了两个开源版的Nexus：Nexus Repository Manager OSS 3.x、Nexus Repository Manager OSS 2.x，前者为 Docker、NuGet、npm、Bower、PyPI、Ruby Gems 提供尖端支持,后者是Nexus Repository的原始开源版本，部署在数千个组织。为 Maven、P2、OBR、Yum提供支持，这里我们下载原始开源版本（Nexus Repository Manager OSS 2.x）就可以了，由于我在window7环境下进行部署测试，所以点击bundle.zip进行Nexus下载。 使用bundle安装包安装Nexus解压安装包nexus-2.14.4-03-bundle.zip，打开命令提示符，进入nexus-2.14.4-03-bundle\nexus-2.14.4-03\bin目录下，键入nexus命令（为方便启动和退出Nexus，可将bin目录添加到环境变量） start：启动 | stop：停止 | restart：重启 | install：安装服务 | uninstall 卸载服务 打开浏览器，访问：http://localhost:8081/nexus/ （Jetty 默认端口号：8081，如需修改请查看配置文件 conf/nexus.properties）： 点击右上角 Log In，使用用户名：admin ，密码：admin123 登录，可使用更多功能： Nexus预置的仓库实际开发中最频繁的就是点击左侧菜单栏的Repositories按钮 一般用到的仓库种类是hosted、proxy。 hosted 宿主仓库：内部项目的发布仓库，主要用于部署无法从公共仓库获取的构件（如 oracle 的 JDBC 驱动）、商业软件jar包以及自己或第三方的项目构件； Proxy代表代理远程的仓库，最典型的就是Maven官方中央仓库、JBoss仓库等等。如果构建的Maven项目本地仓库没有依赖包，那么就会去这个代理站点去下载，那么如果代理站点也没有此依赖包，就回去远程中央仓库下载依赖，这些中央仓库就是proxy。代理站点下载成功后再下载至本机。 group 仓库组：Nexus 通过仓库组的概念统一管理多个仓库，这样我们在项目中直接请求仓库组即可请求到仓库组管理的多个仓库。 virtual 虚拟仓库：用于适配 Maven 1； 3rd party 第三方依赖的仓库，这个数据通常是由内部人员自行下载之后发布上去 这里重点讲解一下： releases 内部的模块中的发布仓库，snapshots 内部的模块中的快照仓库 maven中的仓库分为两种，snapshot快照仓库和release发布仓库。snapshot快照仓库用于保存开发过程中的不稳定版本，release正式仓库则是用来保存稳定的发行版本。定义一个组件/模块为快照版本，只需要在pom文件中在该模块的版本号后加上-SNAPSHOT即可(注意这里必须是大写)，如下： 1234&lt;groupId&gt;cc.zhfeat&lt;/groupId&gt;&lt;artifactId&gt;m1&lt;/artifactId&gt;&lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt; maven会根据模块的版本号(pom文件中的version)中是否带有-SNAPSHOT来判断是快照版本还是正式版本。 如果是快照版本，那么在mvn deploy时会自动发布到快照版本库中，而使用快照版本的模块，在不更改版本号的情况下，直接编译打包时，maven会自动从镜像服务器上下载最新的快照版本。 如果是正式发布版本，那么在mvn deploy时会自动发布到正式版本库中，而使用正式版本的模块，在不更改版本号的情况下，编译打包时如果本地已经存在该版本的模块则不会主动去镜像服务器上下载。 添加代理仓库以 Sonatype 为例，添加一个代理仓库，用于代理 Sonatype 的公共远程仓库。点击菜单 Add - Proxy Repository ： 填写 Repository ID (存储库ID) - sonatype； Repository Name (存储库名称) - Sonatype Repository； Remote Storage Location(远程存储位置) - http://repository.sonatype.org/content/groups/public/ save 保存： 将添加的 Sonatype 代理仓库加入 Public Repositories 仓库组。选中 Public Repositories，在 Configuration 选项卡中，将 Sonatype Repository 从右侧 Available Repositories 移到左侧 Ordered Group Repositories，save 保存： 搜索构件下载Maven项目索引，项目索引是为了使用者能够在私服站点搜索依赖使用的功能。 我们可以设置所有 proxy 仓库的 Download Remote Indexes 为 true，即允许下载远程仓库索引。 保存后后台会运行一个任务，点击菜单栏的Scheduled Tasks选项即可看到有个任务在RUNNING。 下载完成后，Maven索引就可以使用了。 索引下载成功之后，在 Browse Index 选项卡下，可以浏览到所有已被索引的构件信息，包括坐标、格式、Maven 依赖的 xml 代码： 有了索引，我们就可以搜索了： 配置使用MAVEN私服私服搭建成功，我们就可以配置 Maven 使用私服，以后下载构件、部署构件，都通过私服来管理。 在项目中指定maven仓库先在项目pom中配置相关私服信息，这儿我们使用私服公共仓库组 Public Repositories 的地址： 指定仓库：12345678910111213&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;nexus&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; 指定插件仓库：12345678910111213&lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;nexus&lt;/name&gt; &lt;url&gt;&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; 我们先看一下&lt;repositories&gt;的配置，你可以在它下面添加多个 ，每个都有它唯一的ID，一个描述性的name，以及最重要的，远程仓库的url。此外，true告诉Maven可以从这个仓库下载releases版本的构件，而false告诉Maven不要从这个仓库下载snapshot版本的构件。禁止从公共仓库下载snapshot构件是推荐的做法，因为这些构件不稳定，且不受你控制，你应该避免使用。当然，如果你想使用局域网内组织内部的仓库，你可以激活snapshot的支持。 关于的更详细的配置及相关解释，请参考：传送门。 至于&lt;pluginRepositories&gt;，这是配置Maven从什么地方下载插件构件（Maven的所有实际行为都由其插件完成）。该元素的内部配置和完全一样，不再解释。 在POM中配置好maven仓库后，启动我们的SSM项目，参见博客中之前的项目搭建。 可以发现已经是从我本地开始下载jar包了。这里注意，如果在pom中配置了远程仓库，Maven下settings文件也配置了远程仓库，Maven会优先根据全局的settings.xml配置的远程仓库获取依赖。 在settings.xml中配置远程仓库我们知道了如何在POM中配置远程仓库，但考虑这样的情况：在一个公司内部，同时进行这3个项目，而且以后随着这几个项目的结束，越来越多的项目会开始；同时，公司内部建立一个Maven仓库。我们统一为所有这些项目配置该仓库，于是不得不为每个项目提供同样的配置。问题出现了，这是重复 ！其实我们可以做到只配置一次，在哪里配置呢？就是settings.xml。不过事情没有那么简单，不是简单的将POM中的及元素复制到settings.xml中就可以，setting.xml不直接支持 这两个元素。但我们还是有一个并不复杂的解决方案，就是利用profile，如下： 1234567891011121314&lt;settings&gt; ... &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;!-- repositories and pluginRepositories here(参考上面的示例)--&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!--追加激活profile --&gt; &lt;activeProfiles&gt; &lt;activeProfile&gt;dev&lt;/activeProfile&gt; &lt;/activeProfiles&gt; ... &lt;/settings&gt; 这里我们定义一个id为dev的profile，将所有repositories以及pluginRepositories元素放到这个profile中，然后，使用元素自动激活该profile。这样，你就不用再为每个POM重复配置仓库。使用profile为settings.xml添加仓库提供了一种用户全局范围的仓库配置。 之后所有本机的Maven项目就在私服下载组件。（这样比较好） 我们将POM下配置的远程仓库部分删除，在Maven的settings.xml中根据以上进行配置，启动我们的SSM项目，控制台从我本地的Maven私服下载依赖。 使用镜像如果你的地理位置附近有一个速度更快的central镜像，或者你想覆盖central仓库配置，或者你想为所有POM使用唯一的一个远程仓库（这个远程仓库代理的所有必要的其它仓库），你可以使用settings.xml中的mirror配置。以下的mirror配置用maven.NET.cn覆盖了Maven自带的central： 123456789101112&lt;settings&gt; ... &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;maven-net-cn&lt;/id&gt; &lt;name&gt;Maven China Mirror&lt;/name&gt; &lt;url&gt;http://maven.net.cn/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; ... &lt;/settings&gt; 这里唯一需要解释的是，这里我们配置central的镜像，我们也可以配置一个所有仓库的镜像，以保证该镜像是Maven唯一使用的仓库： 1234567891011121314&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | --&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus Mirror&lt;/name&gt; &lt;url&gt;http://xx.xx/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;/mirrors&gt; 局域网的镜像(例子一)：123456789101112&lt;settings&gt; ... &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;my-org-repo&lt;/id&gt; &lt;name&gt;Repository in My Orgnization&lt;/name&gt; &lt;url&gt;http://192.168.1.100/maven2&lt;/url&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; ... &lt;/settings&gt; 阿里的镜像(例子二)： 123456789101112131415161718192021222324252627&lt;mirrors&gt; &lt;!-- mirror | Specifies a repository mirror site to use instead of a given repository. The repository that | this mirror serves has an ID that matches the mirrorOf element of this mirror. IDs are used | for inheritance and direct lookup purposes, and must be unique across the set of mirrors. | &lt;mirror&gt; &lt;id&gt;mirrorId&lt;/id&gt; &lt;mirrorOf&gt;repositoryId&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://my.repository.com/repo/path&lt;/url&gt; &lt;/mirror&gt; --&gt; &lt;mirror&gt; &lt;!--This sends everything else to /public --&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;!--This is used to direct the public snapshots repo in the profile below over to a different nexus group --&gt; &lt;id&gt;nexus-public-snapshots&lt;/id&gt; &lt;mirrorOf&gt;public-snapshots&lt;/mirrorOf&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 项目的发布12345678910111213&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;user-release&lt;/id&gt; &lt;name&gt;User Project Release&lt;/name&gt; &lt;url&gt;http://172.16.5.36:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;user-snapshots&lt;/id&gt; &lt;name&gt;User Project SNAPSHOTS&lt;/name&gt; &lt;url&gt;http://172.16.5.36:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 注意配置了还是发布项目到私服失败，异常提示拒绝访问，原因为没有权限 nexus配置 Releases和Snapshots的权限增加宿主仓库首先在Repositories中添加宿主仓库，ADD –&gt; Hosted Repository增加 Releases 和 Snapshots，Repository ID 和 Repository Name 分别设置为releases、Releases和snapshots、Snapshots。设置好后分别save进行保存。 添加权限定位到Security 下的Privileges 并且点击右边Add..进行添加：添加release和snapshots 配置如下： 之后点击Save进行保存，snapshots配置方式是一样的，这里不再贴图。 建立权限定位到Security 下的Role并且点击右边Add..进行添加刚才配置的：release和snapshots的增删改查权限以及一些nexus操作的基本权限，如下： 点击Save进行保存。 和用户进行绑定定位到Security下的Users，这里我们新建一个用户，添加刚刚建立的权限： 点击Save保存。 授权完毕，这里我们稳妥起见，重新启动下nexus的服务。 Maven配置项目发布权限配置权限在settings.xml 1234567891011121314 &lt;servers&gt;&lt;server&gt;&lt;!--这里注意，ID为POM中配置的ID --&gt; &lt;id&gt;user-release&lt;/id&gt; &lt;username&gt;zhfeat&lt;/username&gt; &lt;password&gt;zhfeat123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;!--这里注意，ID为POM中配置的ID --&gt; &lt;id&gt;user-snapshots&lt;/id&gt; &lt;username&gt;zhfeat&lt;/username&gt; &lt;password&gt;zhfeat123&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; POM.xml 12345678910111213141516&lt;!-- 项目发布 --&gt;&lt;distributionManagement&gt; &lt;repository&gt; &lt;!--这里的ID与setting中配置一致--&gt; &lt;id&gt;user-release&lt;/id&gt; &lt;name&gt;User Project Release&lt;/name&gt; &lt;url&gt;http://172.16.5.36:8081/nexus/content/repositories/releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;!--这里的ID与setting中配置一致--&gt; &lt;id&gt;user-snapshots&lt;/id&gt; &lt;name&gt;User Project SNAPSHOTS&lt;/name&gt; &lt;url&gt;http://172.16.5.36:8081/nexus/content/repositories/snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 然后运行发布 执行 clean deploy 在控制台发布成功 然后进入到私服上的仓库中，看一下确实存在刚刚发布的项目 宿主库——3rd party假如我们下载了Oracle的驱动程序jar包想给其他项目组使用，就需要上传该jar包。选中宿主库——3rd party，之后选择Artifact Upload上传至宿主空间。 最后点击上传。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring boot(二) web综合开发]]></title>
      <url>%2Fblog%2F2017%2F04%2F10%2Fspring%20boot(%E4%BA%8C)%20web%E7%BB%BC%E5%90%88%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[这篇文章内容继续为大家介绍spring boot的一些其它特性和配置(有些未必是spring boot体系桟的功能，但是却是spring特别推荐的一些开源技术)。我也是参考网上的一些教程做了一些简单的尝试，java web开发就是这样，可以实现同样需求的技术有很多，但每去一家新的公司，根据项目的背景、开发人员的水平、生产环境的差异，所用到的技术千差万别。所以我这里整理spring boot系列博文的目的，就是为了让自己的视野更开阔，顺便了解下更丰富的开发技术。 web开发spring boot web开发非常的简单，其中包括常用的json输出、filters、property、log等。 json 接口开发在以前的spring 开发的时候需要我们提供json接口的时候需要做那些配置呢： 添加 jackjson 等相关jar包 配置spring controller扫描 对接的方法添加@ResponseBody 就这样我们会经常由于配置错误，导致406错误等等，spring boot如何做呢，只需要类添加 @RestController 即可，默认类中的方法都会以json的格式返回。 12345678910@RestControllerpublic class HelloWorldController &#123; @RequestMapping("/getUser") public User getUser() &#123; User user=new User(); user.setUserName("小明"); user.setPassWord("xxxx"); return user; &#125;&#125; 如果我们需要使用页面开发只要使用 @Controller ，下面会结合模板来说明 自定义Filter我们常常在项目中会使用filters用于调用日志、排除有XSS威胁的字符、执行权限验证等等。Spring Boot自动添加了OrderedCharacterEncodingFilter和HiddenHttpMethodFilter，并且我们可以自定义Filter。 两个步骤： 实现Filter接口，实现Filter方法 添加@Configuration 注解，将自定义Filter加入过滤链 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.zh;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.FilterConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;import javax.servlet.http.HttpServletRequest;import org.apache.catalina.filters.RemoteIpFilter;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.web.servlet.FilterRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * * @author zhanghao * * 附录：总结过滤器 监听器 拦截器区别 * 1.过滤器 * Servlet中的过滤器Filter是实现了javax.servlet.Filter接口的服务器端程序， * 依赖于servlet容器，主要的用途是过滤字符编码、做一些业务逻辑判断等。 * 其工作原理是，只要你在web.xml文件配置好要拦截的客户端请求， * 它都会帮你拦截到请求，此时你就可以对请求或响应(Request、Response)统一设置编码， * 简化操作；同时还可进行逻辑判断，如用户是否已经登陆、有没有权限访问该页面等等工作。 * 整个过程是基于函数回调完成的。它是随你的web应用启动而启动的， * 只初始化一次，以后就可以过滤几乎所有的相关请求，只有当你的web应用停止或重新部署的时候才销毁。 * * 2.监听器 * 现在来说说Servlet的监听器Listener，它是实现了javax.servlet.ServletContextListener * 接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。 * 主要作用是：做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。 * * 3.拦截器 * 拦截器是面向切面编程（AOP）的一种实现，就是在你的service或者一个方法前调用一个方法， * 或者在方法后调用一个方法。是基于Java的反射机制。拦截器不是在web.xml， * 比如struts在struts.xml中配置，或在spring的配置文件中配置，所以它不依赖于servlet容器。 * 以Struts拦截器举例，拦截器只能对符合配置的请求起作用，而且可以访问action中的上下文、 * 值栈里的对象，在action的生命周期中，拦截器可多次被调用。这些都是与过滤器所不同的。 * */@Configurationpublic class WebConfiguration &#123; @Value("$&#123;com.zh.title&#125;") private String title; //在 @Configuration 中，声明注解 @Bean 相当于在Spring老版本中在配置文件中声明一个Bean。 @Bean public RemoteIpFilter remoteIpFilter() &#123; /** 现在假设我们的应用程序运行在一台负载均衡代理服务器后方，因此需要将代理服务器发来的请求包含的IP地址转换成真正的用户IP。 * Tomcat 8 提供了对应的过滤器：RemoteIpFilter。通过将RemoteFilter这个过滤器加入过滤器调用链即可使用它。 * 返回一个RemoteIPFilter类的spring bean。 * 当Spring Boot监测到有javax.servlet.Filter的bean时就会自动加入过滤器调用链。 * 该过滤器仅用于测试，以后添加过滤器时，如果是javax.servlet.Filter的bean，直接用这种方式就可以加入过滤器调用链 */ return new RemoteIpFilter(); &#125; //定义过滤器规则 @Bean public FilterRegistrationBean testFilterRegistration() &#123; System.out.println("fifter设置"); FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new MyFilter()); registration.addUrlPatterns("/*"); registration.addInitParameter("paramName", "paramValue"); registration.setName("MyFilter"); registration.setOrder(1); return registration; &#125; public class MyFilter implements Filter &#123; @Override public void destroy() &#123; System.out.println("fifter销毁"); &#125; //执行 @Override public void doFilter(ServletRequest srequest, ServletResponse sresponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println("执行fifter"); HttpServletRequest request = (HttpServletRequest) srequest; System.out.println("this is MyFilter,url :"+request.getRequestURI()); filterChain.doFilter(srequest, sresponse); &#125; //初始化 @Override public void init(FilterConfig arg0) throws ServletException &#123; System.out.println("fifter初始化"+ title); &#125; &#125;&#125; 我分别配置了RemoteIpFilter 和 自定义了MyFilter，具体含义请看代码中的注释。 这里涉及到了servlet的生命周期，为了方便理解，我在每一个方法执行的时候都在控制台输出对应的方法描述，这样可以帮助我们在项目启动时，了解过滤器的执行顺序。 启动spring boot Application.java 中的main方法，控制台输出如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424310:41:49.564 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Included patterns for restart : []10:41:49.567 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Excluded patterns for restart : [/spring-boot-starter/target/classes/, /spring-boot-autoconfigure/target/classes/, /spring-boot-starter-[\w-]+/, /spring-boot/target/classes/, /spring-boot-actuator/target/classes/, /spring-boot-devtools/target/classes/]10:41:49.568 [main] DEBUG org.springframework.boot.devtools.restart.ChangeableUrls - Matching URLs for reloading : [file:/C:/Users/Administrator/Desktop/springBoot/springBoot/target/classes/] . ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.2.RELEASE)2017-04-10 10:41:50.292 INFO 10064 --- [ restartedMain] com.zh.Application : Starting Application on zh-PC with PID 10064 (C:\Users\Administrator\Desktop\springBoot\springBoot\target\classes started by Administrator in C:\Users\Administrator\Desktop\springBoot\springBoot)2017-04-10 10:41:50.304 INFO 10064 --- [ restartedMain] com.zh.Application : No active profile set, falling back to default profiles: default2017-04-10 10:41:50.452 INFO 10064 --- [ restartedMain] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@17af3e0f: startup date [Mon Apr 10 10:41:50 CST 2017]; root of context hierarchy2017-04-10 10:41:54.339 INFO 10064 --- [ restartedMain] trationDelegate$BeanPostProcessorChecker : Bean &apos;org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration&apos; of type [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$$b006387a] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)2017-04-10 10:41:55.656 INFO 10064 --- [ restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)2017-04-10 10:41:55.726 INFO 10064 --- [ restartedMain] o.apache.catalina.core.StandardService : Starting service Tomcat2017-04-10 10:41:55.730 INFO 10064 --- [ restartedMain] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.112017-04-10 10:41:56.030 INFO 10064 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2017-04-10 10:41:56.032 INFO 10064 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 5589 msfifter设置2017-04-10 10:41:56.558 INFO 10064 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;characterEncodingFilter&apos; to: [/*]2017-04-10 10:41:56.559 INFO 10064 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;hiddenHttpMethodFilter&apos; to: [/*]2017-04-10 10:41:56.560 INFO 10064 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;httpPutFormContentFilter&apos; to: [/*]2017-04-10 10:41:56.560 INFO 10064 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;requestContextFilter&apos; to: [/*]2017-04-10 10:41:56.561 INFO 10064 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;MyFilter&apos; to urls: [/*]2017-04-10 10:41:56.561 INFO 10064 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;remoteIpFilter&apos; to: [/*]2017-04-10 10:41:56.561 INFO 10064 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Mapping servlet: &apos;dispatcherServlet&apos; to [/]fifter初始化zhfeat2017-04-10 10:41:57.746 INFO 10064 --- [ restartedMain] j.LocalContainerEntityManagerFactoryBean : Building JPA container EntityManagerFactory for persistence unit &apos;default&apos;2017-04-10 10:41:59.202 INFO 10064 --- [ restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit &apos;default&apos;2017-04-10 10:42:00.450 INFO 10064 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@17af3e0f: startup date [Mon Apr 10 10:41:50 CST 2017]; root of context hierarchy2017-04-10 10:42:00.596 INFO 10064 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/hello]&#125;&quot; onto public java.lang.String com.zh.controller.HelloWorldController.index()2017-04-10 10:42:00.607 INFO 10064 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2017-04-10 10:42:00.607 INFO 10064 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2017-04-10 10:42:00.664 INFO 10064 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-10 10:42:00.664 INFO 10064 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-10 10:42:00.765 INFO 10064 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-10 10:42:01.258 INFO 10064 --- [ restartedMain] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292017-04-10 10:42:01.350 INFO 10064 --- [ restartedMain] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-04-10 10:42:01.649 INFO 10064 --- [ restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-04-10 10:42:01.670 INFO 10064 --- [ restartedMain] com.zh.Application : Started Application in 12.076 seconds (JVM running for 13.054) 可以看到，在spring boot 打印出的log中，我们定义的两个fifter已经被加载： 122017-04-10 10:41:56.561 INFO 10064 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;MyFilter&apos; to urls: [/*]2017-04-10 10:41:56.561 INFO 10064 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;remoteIpFilter&apos; to: [/*] 控制台先输出了“fifter设置”，紧接着输出了“fifter初始化zhfeat”，可见，在我们自定义的WebConfiguration.java 过滤器类中，首先执行的是testFilterRegistration()定义过滤器规则，然后执行的是init()，过滤器初始化方法。 我们在浏览器中输入以下url进行访问，验证过滤器是否对请求进行了过滤： http://localhost:8080/hello 控制台输出：12执行fifterthis is MyFilter,url :/hello 调用了WebConfiguration.java中的doFilter()方法。 由此可见，过滤器在项目初始化的时候，首先定义了过滤器规则，然后执行初始化方法，该步骤只执行一次，调用时，只要满足过滤器中所定义的规则，就会执行doFilter方法。最后我们关闭spring boot项目，则会调用destroy()销毁方法。 自定义Property在web开发的过程中，我经常需要自定义一些配置文件，如何使用呢？ 配置在application.properties中123#自定义Propertycom.zh.title=zhfeatcom.zh.description=a hard man 自定义配置类12345678910@Componentpublic class NeoProperties &#123; @Value("$&#123;com.zh.title&#125;") private String title; @Value("$&#123;com.zh.description&#125;") private String description; //省略getter settet方法 &#125; log 配置配置输出的地址和输出级别 12345#配置日志的输出的地址和输出级别logging.path=D:/logSpringBootlogging.level.com.favorites=DEBUGlogging.level.org.springframework.web=INFOlogging.level.org.hibernate=ERROR path为本机的log地址，logging.level 后面可以根据包路径配置不同资源的log级别 数据库操作在这里我重点讲述mysql、spring data jpa的使用，其中mysql 就不用说了大家很熟悉，jpa是利用Hibernate生成各种自动化的sql，如果只是简单的增删改查，基本上不用手写了，spring内部已经帮大家封装实现了。 首先由于我对spring data jpa不是很熟悉，所以这里放上一篇JPA/Hibernate/Spring Data概念。转至http://www.jianshu.com/p/49b31ef74ff3 JPA/Hibernate/Spring Data概念事情的起源，无意当中在一个群里看到这么一句描述：”有人么？默默的问一句，现在开发用mybatis还是hibernate还是jpa”?然后大家就进行各种回答，但是没有有质疑这句话描述的合理性，个人觉得需要清楚概念的，在这里mybatis大家肯定是没有什么疑问，我们把上面那句话更改下，方便我们抛出一些点出来，去掉mybatis修改为：“现在开发是使用hibernate还是jpa”?那么在这里的话，我们就要清楚hibernate/jpa/springdata/spring data jpa到底怎么一个关系？ 什么是JPA?JPA全称Java Persistence API.JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。百度百科JPA 在上面只是一个JPA的定义，我们看看另外一段更能看出是什么的描述： JPA(Java Persistence API)是Sun官方提出的Java持久化规范。它为Java开发人员提供了一种对象/关系映射工具来管理Java应用中的关系数据。 在这段话就比较清晰了，这里有一个关键词“持久化规范”。我们可以拆成两部分进行解读“持久化”、“规范”。所谓的持久化是将程序数据在瞬时数据（比如内存中的数据）转换为持久数据（比如：保存到数据库中，磁盘文件…）。这个个人粗糙的描述，看看专业的描述，如下： 持久化（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的对象存储在的数据库中，或者存储在磁盘文件中、XML数据文件中等等。 持久化是将程序数据在持久状态和瞬时状态间转换的机制。 JDBC就是一种持久化机制。文件IO也是一种持久化机制。 好了，上面已经描述很清楚了，我们在说说“规范”： 所谓的规范意指明文规定或约定俗成的标准。如：道德规范、技术规范，公司管理规范。 那么“持久化规范”就是Sun针对持久化这一层操作指定的规范，如果没有指定JPA规范，那么新起的框架就随意按照自己的标准来了，那我们开发者的世界就玩完了，我们就没法把我们的经历全部集中在我们的业务层上，而是在想我们进行兼容了，这种情况有点像Android开发，Android本身有官方的SDK,但是由于SDK过于开源了，结果导致很多厂商基于SDK二次开发，但是开发完兼容性就不是很好，最好的例子就是Android的头像上传，就是一件很烦人的事情。好了，JPA就唠叨到这里。 什么是Hibernate?这里引用百度百科的话hibernate： Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。 在上面这段描述中抓住核心的一句话就可以了“是一个全自动的ORM框架”。那么是ORM呢? ORM是对象关系映射的意思，英语：Object Relational Mapping简称ORM，是一种程序技术，用于实现面向对象编程语言里不同系统类型的系统之间的数据转换。好了，更多的概念需要自己去挖掘，这里只是抛装引玉下。 什么是Spring Data?Spring Data是一个用于简化数据库访问，并支持云服务的开源框架。其主要目标是使得数据库的访问变得方便快捷，并支持map-reduce框架和云计算数据服务。此外，它还支持基于关系型数据库的数据服务，如Oracle RAC等。对于拥有海量数据的项目，可以用Spring Data来简化项目的开发，就如Spring Framework对JDBC、ORM的支持一样，Spring Data会让数据的访问变得更加方便。 在上面这段描述中我觉得核心的就是“Spring Data是用于简化数据库访问，支持云服务的开源框架”。所以Spring Data本身就是一个开源的框架。 什么是Spring Data JPA?我们先看一个描述： Spring Data JPA能干什么 可以极大的简化JPA的写法，可以在几乎不用写实现的情况下，实现对数据的访问和操作。除了CRUD外，还包括如分页、排序等一些常用的功能。 首先我们需要清楚的是Spring Data是一个开源框架，在这个框架中Spring Data JPA只是这个框架中的一个模块，所以名称才叫SpringData JPA。如果单独使用JPA开发，你会发现这个代码量和使用JDBC开发一样有点烦人，所以Spring Data JPA的出现就是为了简化JPA的写法，让你只需要编写一个接口继承一个类就能实现CRUD操作了。 JPA/Hibernate关系？我们先看下别人的描述： Jpa是一种规范，而Hibernate是它的一种实现。除了Hibernate，还有EclipseLink(曾经的toplink)，OpenJPA等可供选择，所以使用Jpa的一个好处是，可以更换实现而不必改动太多代码。 从上面这个描述，我们能就是能看出: JPA定义了一个规范，Hibernate是其中的一种实现方式可以，所以我们可以说：Hibernate是JPA的一种实现方式。但是这么说就有点欠妥当了：开发是使用hibernate还是jpa。如果你回答使用JPA的话，那么你根本做不了什么事情，因为你需要使用它具体的一种实现方式，比如：Hibernate,EclipseLink,toplink。如果回答说是使用Hibernate的话，还勉强说的过去，但是在Hibernate中也有JPA的影子。但是这里不要造成一个误解，hibernate一定依赖JPA什么之类的，JPA现在只是Hibernate功能的一个子集。Hibernate从3.2开始，开始兼容JPA的。Hibernate3.2获得了SunTCK的JPA(JavaPersistence API)兼容认证。 那么我们在描述的时候，别人问你持久化具体使用了什么，我们可以说：使用了基于Hibernate实现的JPA，或者是Hibernate JPA，那么加上spring data的，我们一般都简化说：spring data jpa，一般默认的就是使用了hibernate进行实现，现在网上这方面的资料也比较多，可能就约定俗成了。 下面简单介绍一下如何在spring boot中使用： POM中添加依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; application.properties增加配置123456789#mysql数据库连接spring.datasource.url=jdbc:mysql://localhost:3306/test?characterEncoding=utf8&amp;useSSL=truespring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.jpa.properties.hibernate.hbm2ddl.auto=updatespring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialectspring.jpa.show-sql= true 其实这个hibernate.hbm2ddl.auto参数的作用主要用于：自动创建|更新|验证数据库表结构,有四个值： create： 每次加载hibernate时都会删除上一次的生成的表，然后根据你的model类再重新来生成新表，哪怕两次没有任何改变也要这样执行，这就是导致数据库表数据丢失的一个重要原因。 create-drop ：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭,表就自动删除。 update：最常用的属性，第一次加载hibernate时根据model类会自动建立起表的结构（前提是先建立好数据库），以后加载hibernate时根据 model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等 应用第一次运行起来后才会。 validate ：每次加载hibernate时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。 dialect 主要是指定生成表名的存储引擎为InneoDB show-sql 是否打印出自动生产的SQL，方便调试的时候查看 添加实体类和Dao实体： 12345678910111213141516171819@Entitypublic class User implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue private Long id; @Column(nullable = false, unique = true) private String userName; @Column(nullable = false) private String passWord; @Column(nullable = false, unique = true) private String email; @Column(nullable = true, unique = true) private String nickName; @Column(nullable = false) private String regTime; //省略getter settet方法、构造方法&#125; dao只要继承JpaRepository类就可以，几乎可以不用写方法，还有一个特别有尿性的功能非常赞，就是可以根据方法名来自动的生产SQL，比如findByUserName 会自动生产一个以 userName 为参数的查询方法，比如 findAlll 自动会查询表里面的所有数据，比如自动分页等等。。 Entity中不映射成列的字段得加@Transient 注解，不加注解也会映射成列 Dao：1234public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123; User findByUserName(String userName); User findByUserNameOrEmail(String username, String email);&#125; 测试1234567891011121314151617181920212223242526272829303132333435363738package com.zh;import java.text.DateFormat;import java.util.Date;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.zh.domain.User;import com.zh.domain.UserRepository;@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTestpublic class UserRepositoryTests &#123; @Autowired private UserRepository userRepository; @Test public void test() throws Exception &#123; Date date = new Date(); DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.LONG); String formattedDate = dateFormat.format(date); userRepository.save(new User("aa@126.com","aa","aa1","aa123456",formattedDate)); userRepository.save(new User("bb@126.com","bb","bb2","bb123456",formattedDate)); userRepository.save(new User("cc@126.com","cc","cc3","cc123456",formattedDate)); //查询数据库中一共有多少条记录 System.out.println(userRepository.findAll().size()); //根据用户名或者邮箱查找NickName System.out.println(userRepository.findByUserNameOrEmail("cc123456", "cc@126.com").getNickName()); //根据用户名查询到该条记录并删除 userRepository.delete(userRepository.findByUserName("cc123456")); &#125;&#125; 执行该单元测试时，spring Data JPA会根据实体自动在数据库中创建表结构，插入三条数据后，根据条件删除一条。执行以上逻辑的详细过程这里就不再截图说明了。 spring data jpa 还有很多功能，比如封装好的分页，可以自己定义SQL，主从分离等等，这里就不详细讲了。 thymeleaf模板 Spring boot 推荐使用来代替jsp,thymeleaf模板到底是什么来头呢，让spring大哥来推荐，下面我们来聊聊。 Thymeleaf 介绍 Thymeleaf是一款用于渲染XML/XHTML/HTML5内容的模板引擎。类似JSP，Velocity，FreeMaker等，它也可以轻易的与Spring MVC等Web框架进行集成作为Web应用的模板引擎。与其它模板引擎相比，Thymeleaf最大的特点是能够直接在浏览器中打开并正确显示模板页面，而不需要启动整个Web应用。 好了，你们说了我们已经习惯使用了什么 velocity,FreMaker，beetle之类的模版，那么到底好在哪里呢？ 比一比吧 Thymeleaf是与众不同的，因为它使用了自然的模板技术。这意味着Thymeleaf的模板语法并不会破坏文档的结构，模板依旧是有效的XML文档。模板还可以用作工作原型，Thymeleaf会在运行期替换掉静态值。Velocity与FreeMarker则是连续的文本处理器。 下面的代码示例分别使用Velocity、FreeMarker与Thymeleaf打印出一条消息： 123Velocity: &lt;p&gt;$message&lt;/p&gt;FreeMarker: &lt;p&gt;$&#123;message&#125;&lt;/p&gt;Thymeleaf: &lt;p th:text="$&#123;message&#125;"&gt;Hello World!&lt;/p&gt; 注意：由于Thymeleaf使用了XML DOM解析器，因此它并不适合于处理大规模的XML文件。 URLURL在Web应用模板中占据着十分重要的地位，需要特别注意的是Thymeleaf对于URL的处理是通过语法@{…}来处理的。Thymeleaf支持绝对路径URL： 1&lt;a th:href="@&#123;http://www.thymeleaf.org&#125;"&gt;Thymeleaf&lt;/a&gt; 条件求值1&lt;a th:href="@&#123;/login&#125;" th:unless=$&#123;session.user != null&#125;&gt;Login&lt;/a&gt; for 循环12345&lt;tr th:each="prod : $&#123;prods&#125;"&gt; &lt;td th:text="$&#123;prod.name&#125;"&gt;Onions&lt;/td&gt; &lt;td th:text="$&#123;prod.price&#125;"&gt;2.41&lt;/td&gt; &lt;td th:text="$&#123;prod.inStock&#125;? #&#123;true&#125; : #&#123;false&#125;"&gt;yes&lt;/td&gt;&lt;/tr&gt; 就列出这几个吧，大概了解一下，我个人觉得比较NB的地方在于可以不用启动web容器，直接在页面中进行取值渲染，比较6。不想jsp那样依赖Java。 页面既原型在Web开发过程中一个绕不开的话题就是前端工程师与后端工程师的写作，在传统Java Web开发过程中，前端工程师和后端工程师一样，也需要安装一套完整的开发环境，然后各类Java IDE中修改模板、静态资源文件，启动/重启/重新加载应用服务器，刷新页面查看最终效果。 但实际上前端工程师的职责更多应该关注于页面本身而非后端，使用JSP，Velocity等传统的Java模板引擎很难做到这一点，因为它们必须在应用服务器中渲染完成后才能在浏览器中看到结果，而Thymeleaf从根本上颠覆了这一过程，通过属性进行模板渲染不会引入任何新的浏览器不能识别的标签，例如JSP中的，不会在Tag内部写表达式。整个页面直接作为HTML文件用浏览器打开，几乎就可以看到最终的效果，这大大解放了前端工程师的生产力，它们的最终交付物就是纯的HTML/CSS/JavaScript文件。 Gradle 构建工具spring 项目建议使用Gradle进行构建项目，相比maven来讲 Gradle更简洁，而且gradle更时候大型复杂项目的构建。gradle吸收了maven和ant的特点而来，不过目前maven仍然是Java界的主流，大家可以先了解了解。 一个使用gradle配置的项目: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647buildscript &#123; repositories &#123; maven &#123; url &quot;http://repo.spring.io/libs-snapshot&quot; &#125; mavenLocal() &#125; dependencies &#123; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:1.3.6.RELEASE&quot;) &#125;&#125;apply plugin: &apos;java&apos; //添加 Java 插件, 表明这是一个 Java 项目apply plugin: &apos;spring-boot&apos; //添加 Spring-boot支持apply plugin: &apos;war&apos; //添加 War 插件, 可以导出 War 包apply plugin: &apos;eclipse&apos; //添加 Eclipse 插件, 添加 Eclipse IDE 支持, Intellij Idea 为 &quot;idea&quot;war &#123; baseName = &apos;favorites&apos; version = &apos;0.1.0&apos;&#125;sourceCompatibility = 1.7 //最低兼容版本 JDK1.7targetCompatibility = 1.7 //目标兼容版本 JDK1.7repositories &#123; // Maven 仓库 mavenLocal() //使用本地仓库 mavenCentral() //使用中央仓库 maven &#123; url &quot;http://repo.spring.io/libs-snapshot&quot; &#125; //使用远程仓库&#125; dependencies &#123; // 各种 依赖的jar包 compile(&quot;org.springframework.boot:spring-boot-starter-web:1.3.6.RELEASE&quot;) compile(&quot;org.springframework.boot:spring-boot-starter-thymeleaf:1.3.6.RELEASE&quot;) compile(&quot;org.springframework.boot:spring-boot-starter-data-jpa:1.3.6.RELEASE&quot;) compile group: &apos;mysql&apos;, name: &apos;mysql-connector-java&apos;, version: &apos;5.1.6&apos; compile group: &apos;org.apache.commons&apos;, name: &apos;commons-lang3&apos;, version: &apos;3.4&apos; compile(&quot;org.springframework.boot:spring-boot-devtools:1.3.6.RELEASE&quot;) compile(&quot;org.springframework.boot:spring-boot-starter-test:1.3.6.RELEASE&quot;) compile &apos;org.webjars.bower:bootstrap:3.3.6&apos; compile &apos;org.webjars.bower:jquery:2.2.4&apos; compile(&quot;org.webjars:vue:1.0.24&quot;) compile &apos;org.webjars.bower:vue-resource:0.7.0&apos;&#125;bootRun &#123; addResources = true&#125; WebJarsWebJars是一个很神奇的东西，可以让大家以jar包的形式来使用前端的各种框架、组件。 什么是WebJars什么是WebJars？WebJars是将客户端（浏览器）资源（JavaScript，Css等）打成jar包文件，以对资源进行统一依赖管理。WebJars的jar包部署在Maven中央仓库上。(第一次看到这个介绍的时候我觉得真是66666) 为什么使用我们在开发Java web项目的时候会使用像Maven，Gradle等构建工具以实现对jar包版本依赖管理，以及项目的自动化管理，但是对于JavaScript，Css等前端资源包，我们只能采用拷贝到webapp下的方式，这样做就无法对这些资源进行依赖管理。那么WebJars就提供给我们这些前端资源的jar包形势，我们就可以进行依赖管理。 如何使用 WebJars主官网 查找对于的组件，比如Vuejs 12345&lt;dependency&gt; &lt;groupId&gt;org.webjars.bower&lt;/groupId&gt; &lt;artifactId&gt;vue&lt;/artifactId&gt; &lt;version&gt;1.0.21&lt;/version&gt;&lt;/dependency&gt; 页面引入1&lt;link th:href="@&#123;/webjars/bootstrap/3.3.6/dist/css/bootstrap.css&#125;" rel="stylesheet"&gt;&lt;/link&gt; 就可以正常使用了！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring boot(一) spring boot项目构建]]></title>
      <url>%2Fblog%2F2017%2F04%2F06%2Fspring%20boot(%E4%B8%80)%20spring%20boot%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[什么是spring bootSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是spring boot其实不是什么新的框架，它默认配置了很多框架的使用方式。 使用spring boot有什么好处其实就是简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢？ 1）配置web.xml，加载spring和spring mvc 2）配置数据库连接、配置spring事务 3）配置加载配置文件的读取，开启注解 4）配置日志文件 … 配置完成之后部署tomcat或者使用jetty进行调试。 … 可参见blog中的SSM框架搭建，虽然可以copy，但是具体过程还是比较耗时耗力的，一个配置没配好，可能就要根据控制台输出的异常去花时间调试一下。 现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍！ 但是如果使用spring boot呢？ 很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套web项目或者是构建一个微服务！ spring boot项目搭建 访问 spring boot github 选择构建工具Maven Project、Spring Boot版本1.5.8以及一些工程基本信息，点击“Switch to the full version.”java版本选择1.8，可参考下图所示： 点击Generate Project下载项目压缩包 解压后，使用eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt;选择解压后的文件夹-&gt; Finsh，OK done! 项目结构介绍项目导入后如下图所示，灰色部分是我自己创建的，可以暂且无视。 如上图所示，Spring Boot的基础结构共三个文件: l src/main/java 程序开发以及主程序入口 l src/main/resources 配置文件 l src/test/java 测试程序另外，spingboot建议的目录结果如下： root package结构：com.example. 123456789101112131415com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- controller | +- CustomerController.java | Application.java 建议放到跟目录下面,主要用于做一些框架配置 domain 目录主要用于实体（Entity）与数据访问层（Repository） service 层主要是业务类代码 controller 负责页面访问控制 采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改 最后，启动Application main方法，至此一个java项目搭建好了！ 引入web模块 pom.xml中添加支持web的模块： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; pom.xml文件中默认有两个模块： spring-boot-starter：核心模块，包括自动配置支持、日志和YAML； spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito 编写controller内容 1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping("/hello") public String index() &#123; return "Hello World"; &#125;&#125; @RestController的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！ 启动Application.java里的main方法，打开浏览器访问http://localhost:8080/hello，就可以看到效果了。 启动项目后控制台输出： 12345678910111213141516171819202122232425262728293031323334353618:42:34.465 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Included patterns for restart : []18:42:34.481 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Excluded patterns for restart : [/spring-boot-starter/target/classes/, /spring-boot-autoconfigure/target/classes/, /spring-boot-starter-[\w-]+/, /spring-boot/target/classes/, /spring-boot-actuator/target/classes/, /spring-boot-devtools/target/classes/]18:42:34.481 [main] DEBUG org.springframework.boot.devtools.restart.ChangeableUrls - Matching URLs for reloading : [file:/C:/Users/Administrator/Desktop/springBoot/springBoot/target/classes/] . ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.2.RELEASE)2017-04-06 18:42:35.335 INFO 11936 --- [ restartedMain] com.zh.Application : Starting Application on zh-PC with PID 11936 (C:\Users\Administrator\Desktop\springBoot\springBoot\target\classes started by Administrator in C:\Users\Administrator\Desktop\springBoot\springBoot)2017-04-06 18:42:35.335 INFO 11936 --- [ restartedMain] com.zh.Application : No active profile set, falling back to default profiles: default2017-04-06 18:42:35.444 INFO 11936 --- [ restartedMain] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@6c7fe02f: startup date [Thu Apr 06 18:42:35 CST 2017]; root of context hierarchy2017-04-06 18:42:39.175 INFO 11936 --- [ restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)2017-04-06 18:42:39.191 INFO 11936 --- [ restartedMain] o.apache.catalina.core.StandardService : Starting service Tomcat2017-04-06 18:42:39.191 INFO 11936 --- [ restartedMain] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.112017-04-06 18:42:39.395 INFO 11936 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2017-04-06 18:42:39.395 INFO 11936 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 3951 ms2017-04-06 18:42:39.691 INFO 11936 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Mapping servlet: &apos;dispatcherServlet&apos; to [/]2017-04-06 18:42:39.691 INFO 11936 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;characterEncodingFilter&apos; to: [/*]2017-04-06 18:42:39.691 INFO 11936 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;hiddenHttpMethodFilter&apos; to: [/*]2017-04-06 18:42:39.691 INFO 11936 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;httpPutFormContentFilter&apos; to: [/*]2017-04-06 18:42:39.691 INFO 11936 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;requestContextFilter&apos; to: [/*]2017-04-06 18:42:40.143 INFO 11936 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@6c7fe02f: startup date [Thu Apr 06 18:42:35 CST 2017]; root of context hierarchy2017-04-06 18:42:40.284 INFO 11936 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/hello]&#125;&quot; onto public java.lang.String com.zh.controller.HelloWorldController.index()2017-04-06 18:42:40.284 INFO 11936 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2017-04-06 18:42:40.284 INFO 11936 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2017-04-06 18:42:40.315 INFO 11936 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-06 18:42:40.315 INFO 11936 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-06 18:42:40.394 INFO 11936 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-06 18:42:40.690 INFO 11936 --- [ restartedMain] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292017-04-06 18:42:40.753 INFO 11936 --- [ restartedMain] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-04-06 18:42:40.956 INFO 11936 --- [ restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-04-06 18:42:40.971 INFO 11936 --- [ restartedMain] com.zh.Application : Started Application in 6.444 seconds (JVM running for 7.67) 浏览器访问http://localhost:8080/hello接口返回数据： 如何做单元测试打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。有关mockmvc的介绍请参考前面一篇blog，具体思路就是在单元测试中模拟一个http请求，这样我们就可以很方便的对controller层进行测试了。 1234567891011121314151617@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes = MockServletContext.class)@WebAppConfigurationpublic class HelloWorldControlerTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn(); &#125;&#125; 开发环境的调试热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，改动项目不重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要在pom文件中添加以下的配置：123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。 总结使用spring boot可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用sping boot非常适合构建微服务。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用MockMvc测试SpringMvc Controller]]></title>
      <url>%2Fblog%2F2017%2F04%2F05%2F%E4%BD%BF%E7%94%A8MockMvc%E6%B5%8B%E8%AF%95SpringMvc%20Controller%2F</url>
      <content type="text"><![CDATA[对模块进行集成测试时，希望能够通过输入URL对Controller进行测试，如果通过启动服务器，建立http client进行测试，这样会使得测试变得很麻烦，比如，启动速度慢，测试验证不方便，依赖网络环境等，这样会导致测试无法进行，为了可以对Controller进行测试，可以通过引入MockMVC进行解决。 什么是MockMvcMockMvc实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，这样可以使得测试速度快、不依赖网络环境，而且提供了一套验证的工具，这样可以使得请求的验证统一而且很方便。 使用场景作为WEB开发人员在开发过程中总是需要测试各种请求，常规的方法则是启动WEB服务器进行测试，如果出错，停掉WEB服务器，调整代码，重启WEB服务器进行测试。大量的时间都浪费在WEB服务器的启动上,MockMvc实现了对Http请求的模拟，该方法基于SpringMVC 与 spring Test 框架，可以让我们不用频繁的启动WEB容器去测试，而是以单元测试的方式进行调试，节省了开发时间，提高了开发效率。 使用要求spring 集成测试中对mock的集成很好，让开发员使用起来很方便，但是使用时必须注意以下三个条件： Junit必须在4.9版本以上 spring版本必须在3.2以上 使用的框架必须是springMvc框架 MockMvc功能依旧基于之blog中搭建的SSM框架。 MockMvc运行配置POM依赖这里只贴上主要用到的依赖： 版本信息：4.0.2.RELEASE12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 &lt;!-- spring核心包 --&gt; &lt;!-- 这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring对于object/xml映射的支持，可以让JAVA与XML之间来回切换 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含对Spring对JDBC数据访问进行封装的所有类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring context的扩展支持，用于MVC方面。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 对JUNIT等测试框架的简单封装 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;!-- &lt;scope&gt;test&lt;/scope&gt; --&gt; &lt;/dependency&gt; &lt;!-- 使用MockMvc模拟请求必须要有这个jar，不然会抛异常 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; 用到的注解 RunWith(SpringJUnit4ClassRunner.class): 表示使用Spring Test组件进行单元测试; WebAppConfiguration: 使用这个Annotate会在跑单元测试的时候真实的启一个web服务，然后开始调用Controller的Rest API，待单元测试跑完之后再将web服务停掉; ContextConfiguration: 指定Bean的配置文件信息，可以有多种方式，这个例子使用的是文件路径形式，如果有多个配置文件，可以将括号中的信息配置为一个字符串数组来表示; 代码结构MessageTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.javen.testmybatis;import javax.annotation.Resource;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.result.MockMvcResultHandlers;import org.springframework.test.web.servlet.result.MockMvcResultMatchers;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;import com.zh.producer.MessageProducer;/** * 功能概要： * * @author zhanghao */@RunWith(SpringJUnit4ClassRunner.class) //表示继承了SpringJUnit4ClassRunner类 @ContextConfiguration(locations = &#123;"classpath:spring-mybatis.xml"&#125;) @WebAppConfiguration public class MessageTest &#123; //MockMvc实例 private MockMvc mvc; @Autowired private WebApplicationContext wac; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.webAppContextSetup(wac).build(); &#125; /** 整个过程： 1、mockMvc.perform执行一个请求； 2、MockMvcRequestBuilders.get("/user/showUser")构造一个请求 3、ResultActions.andExpect添加执行完成后的断言 4、ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情，比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息。 5、ResultActions.andReturn表示执行完成后返回相应的结果。 * @throws Exception **/ @Test public void getHello() throws Exception&#123; //perform 执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理； mvc.perform(MockMvcRequestBuilders.get("/user/showUser").accept(MediaType.APPLICATION_JSON).param("id", "1")) //andExpect：添加ResultMatcher验证规则，验证控制器执行完成后结果是否正确； .andExpect(MockMvcResultMatchers.status().isOk()) //andDo：添加ResultHandler结果处理器，比如调试时打印结果到控制台； .andDo(MockMvcResultHandlers.print()) //andReturn：最后返回相应的MvcResult；然后进行自定义验证/进行下一步的异步处理； .andReturn(); &#125; &#125; MockMvc可以对controller中的一次调用进行模拟，perform就是一次请求，MockMvcRequestBuilders进行url的请求，andExcept方法为对Controller类、调用方法、视图和model的预期设置，andDo进行这次请求的执行，最后andReturn返回。 MockMvc测试测试逻辑:Mock出一个MockHttpServletRequestBuilder对象。用于模拟Http的get请求方式,param()方法可以给http请求携带参数,相当于写了这样一个url： http://localhost:8000/user/showUser?id=1然后调用.andExport(status().isOk())方法看请求的状态响应码是否为200如果不是则抛异常，测试不通过。 执行单元测试后返回结果： 1234567891011121314151617181920212223242526272829303132MockHttpServletRequest: HTTP Method = GET Request URI = /user/showUser Parameters = &#123;id=[1]&#125; Headers = &#123;Accept=[application/json]&#125; Handler: Type = com.zh.controller.UserController Async: Was async started = false Async result = null Resolved Exception: Type = null ModelAndView: View name = null View = null Model = null FlashMap:MockHttpServletResponse: Status = 200 Error message = null Headers = &#123;Content-Type=[application/json], Content-Length=[55]&#125; Content type = application/json Body = &#123;&quot;age&quot;:24,&quot;id&quot;:1,&quot;password&quot;:&quot;345&quot;,&quot;userName&quot;:&quot;Maven1?&quot;&#125; Forwarded URL = null Redirected URL = null Cookies = [] 其中Body就是我们Controller返回的json字符串。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSM集成Dubbo+Zookeeper实现服务化]]></title>
      <url>%2Fblog%2F2017%2F03%2F29%2FSSM%E9%9B%86%E6%88%90Dubbo%2BZookeeper%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%8C%96%2F</url>
      <content type="text"><![CDATA[随着互联网的发展，网站应用或者企业应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 什么是面向服务的架构(SOA)面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。 SOA的框架也正是现在网站的系统架构演化史，也从侧面反映了我国网民数量的增加和对网站性能的提升。 大型网站系统特点 高并发、大流量：PV量巨大 高可用：7*24小时不间断服务 海量数据：文件数目分分钟xxTB 用户分布广泛，网络情况复杂：网络运营商 安全环境恶劣：黑客的攻击 需求快速变更，发布频繁：快速适应市场，满足用户需求 渐进式发展：慢慢地运营出大型网站 例子：小明作为一个屌丝码农，有一天创建了一个网站，最开始只是小明一个人在运营，所有的程序都在一个Server里面跑，数据库访问和逻辑控制也都写在jsp文件里面。应用程序、数据库、文件等所有资源都集中在一台Server上。这就是典型的纯jsp网站。 后来他的好朋友小王来了，他觉得小明的网站做的不错，于是就提出了改造建议，小王可是受过培训的啊，什么MVC人家可是经常背，于是他们的网站就开始拆分MVC三层了。并且把文件服务器和数据库单独部署到一个Server上。这个时候三台Server平天下，应用和数据服务分离。 再到后来，他们的网站越来越大了，普通的架构已经满足不了他们了，怎么办，必须得做集群，必须要有缓存，什么读写分离啊，redis啊和反向代理和CDN加速等等，慢慢的开始应用起来。 分布式服务：既然每一个应用系统都需要执行许多相通的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。 好了，其实dubbo简单来说就是用来管理我们的服务的，以前我们都是自己调自己的服务，如果服务挂掉的话，那么整个系统就挂掉了，现在是我们把服务交给dubbo去统一管理,而zookeeper是管理我们的dubbo的。 Dubbo介绍单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。 此时，用于简化增删改查工作量的 数据访问框架(ORM)是关键。 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 此时，用于加速前端页面开发的Web框架(MVC) 是关键。 垂直应用架构详细： 技术比较单一，学习成本低，开发上手快，测试、部署、运维也比较简单。 业务组网也比较简单，在小规模应用场景中，通常只需要做热双机( 双机热备就是当一台服务器挂掉后，自动切换到另一台使用) 即可。 在高并发，大流量的场景中，需要做集群。通常的组网方案是前端F5（F5是一家公司，专门做应用交付的厂商，在负载均衡设备中比较知名的），后端做对等集群(物理配置对等的机器)部署。 缺点： 维护成本越来越高。因为代码是全量一起打包和部署，相互影响。 团队协作效率差，功能重复开发。 系统可靠性变差，容易引起“雪崩”效应。 维护和定制困难。 新功能上线周期变长。 将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，以实现服务的共享和重用，RPC框架就应运而生了。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。 需求 在大规模服务化之前，应用可能只是通过RMI(Java RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。可以用此方法调用的任何对象必须实现该远程接口。)或Hessian(Hessian是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。)等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过F5等硬件进行负载均衡。 当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover，降低对F5硬件负载均衡器的依赖，也能减少部分成本。 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。这时，需要自动画出应用间的依赖关系图，以帮助架构师理清理关系。 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。 架构 节点角色说明： Provider: 暴露服务的服务提供方 Consumer: 调用远程服务的服务消费方。 Registry: 服务注册与发现的注册中心。 Monitor: 统计服务的调用次数调和调用时间的监控中心。 Container: 服务运行容器。 调用关系说明： 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 (1) 连通性： 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者 注册中心和监控中心全部 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者 (2) 健状性： 监控中心宕掉不影响使用，只是丢失部分采样数据 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务 注册中心对等集群，任意一台宕掉后，将自动切换到另一台 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯 服务提供者无状态，任意一台宕掉后，不影响使用 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 (3) 伸缩性： 注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者 (4) 升级性： 当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力： 总结Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能。Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。 主要核心部件： Remoting: 网络通信框架，实现了 sync-over-async 和 request-response 消息机制. RPC: 一个远程过程调用的抽象，支持负载均衡、容灾和集群功能 Registry: 服务目录框架用于服务的注册和服务事件发布和订阅 Zookeeper安装与配置 Zookeeper属于Hadoop的一个子项目，是分布式服务框架，主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等等。 Zookeeper的安装和配置十分简单, 既可以配置成单机模式, 也可以配置成集群模式. 下面将分别进行介绍. 本文基于Windows 环境进行配置。 安装下载本文采用Zookeeper3.4.6版本，下载地址：http://zookeeper.apache.org/doc/r3.4.6/releasenotes.html 安装Zookeeper下载后，将Zookeeper解压，如下图： 单机配置打开conf目录下zoo.cfg(如果为zoo_sample.cfg，需改名为zoo.cfg)配置文件进行配置，如下图： 12345678910111213141516171819202122232425262728# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial # synchronization phase can takeinitLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.dataDir=/Users/apple/zookeeper0/data# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to "0" to disable auto purge feature#autopurge.purgeInterval=1 参数说明: tickTime：基本事件单元，以毫秒为单位，用来控制心跳和超时，默认情况超时的时间为两倍的tickTime dataDir：数据目录.可以是任意目录. dataLogDir：log目录, 同样可以是任意目录. 如果没有设置该参数,将使用和dataDir相同的设置. clientPort：监听client连接的端口号. maxClientCnxns：限制连接到zookeeper的客户端数量，并且限制并发连接数量，它通过ip区分不同的客户端。 minSessionTimeout和maxSessionTimeout：最小会话超时时间和最大的会话超时时间，在默认情况下，最小的超时时间为2倍的tickTime时间，最大的会话超时时间为20倍的会话超时时间，系统启动时会显示相应的信息。默认为-1 initLimit：参数设定了允许所有跟随者与领导者进行连接并同步的时间，如果在设定的时间段内，半数以上的跟随者未能完成同步，领导者便会宣布放弃领导地位，进行另一次的领导选举。如果zk集群环境数量确实很大，同步数据的时间会变长，因此这种情况下可以适当调大该参数。默认为10 syncLimit：参数设定了允许一个跟随者与一个领导者进行同步的时间，如果在设定的时间段内，跟随者未完成同步，它将会被集群丢弃。所有关联到这个跟随者的客户端将连接到另外一个跟随着。 启动Zookeeper在bin目录下，双击zkServer.cmd即可启动Zookeeper。 如果启动闪退，可能是配置文件有问题，可以使用默认配置文件看是否可以启动。 启动成功见下图： 伪集群配置所谓伪集群, 是指在单台机器中启动多个zookeeper进程, 并组成一个集群. 以启动3个zookeeper进程为例. 将zookeeper的目录拷贝2份: |–zookeeper0 |–zookeeper1 |–zookeeper2 更改zookeeper0/conf/zoo.cfg文件为: 123456789tickTime=2000 initLimit=5 syncLimit=2 dataDir=/Users/apple/zookeeper0/data dataLogDir=/Users/apple/zookeeper0/logs clientPort=4180 server.0=127.0.0.1:8880:7770 server.1=127.0.0.1:8881:7771 server.2=127.0.0.1:8882:7772 新增了几个参数, 其含义如下: initLimit: zookeeper集群中的包含多台server, 其中一台为leader, 集群中其余的server为follower. initLimit参数配置初始化连接时, follower和leader之间的最长心跳时间. 此时该参数设置为5, 说明时间限制为5倍tickTime, 即5*2000=10000ms=10s. syncLimit: 该参数配置leader和follower之间发送消息, 请求和应答的最大时间长度. 此时该参数设置为2, 说明时间限制为2倍tickTime, 即4000ms. server.X=A:B:C 其中X是一个数字, 表示这是第几号server. A是该server所在的IP地址. B配置该server和集群中的leader交换消息所使用的端口. C配置选举leader时所使用的端口. 由于配置的是伪集群模式, 所以各个server的B, C参数必须不同. 参照zookeeper0/conf/zoo.cfg, 配置zookeeper1/conf/zoo.cfg, 和zookeeper2/conf/zoo.cfg文件. 只需更改dataDir, dataLogDir, clientPort参数即可. 在之前设置的dataDir中新建myid文件, 写入一个数字, 该数字表示这是第几号server. 该数字必须和zoo.cfg文件中的server.X中的X一一对应./Users/apple/zookeeper0/data/myid文件中写入0, /Users/apple/zookeeper1/data/myid文件中写入1, /Users/apple/zookeeper2/data/myid文件中写入2. 分别进入/Users/apple/zookeeper0/bin, /Users/apple/zookeeper1/bin, /Users/apple/zookeeper2/bin三个目录, 启动server. 集群模式集群模式的配置和伪集群基本一致. 由于集群模式下, 各server部署在不同的机器上, 因此各server的conf/zoo.cfg文件可以完全一样.基于Linux配置。 123456789tickTime=2000 initLimit=5 syncLimit=2 dataDir=/home/zookeeper/data dataLogDir=/home/zookeeper/logs clientPort=4180 server.43=10.1.39.43:2888:3888 server.47=10.1.39.47:2888:3888 server.48=10.1.39.48:2888:3888 部署了3台zookeeper server, 分别部署在10.1.39.43, 10.1.39.47, 10.1.39.48上. 需要注意的是, 各server的dataDir目录下的myid文件中的数字必须不同. 10.1.39.43 server的myid为43, 10.1.39.47 server的myid为47, 10.1.39.48 server的myid为48. 部署完成后即可分别启动。启动后要检查 Zookeeper 是否已经在服务，可以通过 netstat -at|grep 2181 命令查看是否有 clientPort 端口号在监听服务。 总结Zookeeper安装和配置都比较简单，配置完成以后，启动ZK即可使用。 SSM集成Dubbo+Zookeeper实现服务化前面分别对Dubbo和Zookeeper进行介绍、安装、配置说明。 本文基于之前的SSM项目，配置了两个工程，为方便理解，暂且称其为dubbo-service和dubbo-client dubbo-service提供服务，提供数据增删改查服务，无页面及Controller。 dubbo_client提供页面访问，具体的增删改查条用dubbo-service远程服务。 Pom依赖服务端和客户端一致。在SSM基础上加入Dubbo和Zookeeper依赖。 123456789101112131415161718192021222324252627282930&lt;!-- Dubbo 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- Zookeeper 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt; 服务端配置服务接口 DubboTestService.java 1234567891011121314package com.zh.service;import com.zh.model.User;/** * Dubbo生产者接口 * @author Administrator * */public interface DubboTestService &#123; public int insert(User record);&#125; 实现 DubboTestServiceImpl.java 1234567891011121314151617181920package com.zh.service.impl;import javax.annotation.Resource;import org.springframework.stereotype.Service;import com.zh.dao.UserMapper;import com.zh.model.User;import com.zh.service.DubboTestService;@Service("dubboTestService") public class DubboTestServiceImpl implements DubboTestService &#123; @Resource private UserMapper userDao; public int insert(User record) &#123; return this.userDao.insert(record); &#125;&#125; 具体如何操作数据库的过程不再累述，请查看之前的blog或者下载源码。 这里我将配置好的dubbo-service服务端(服务提供者)生成war包，先行部署到tomcat下。 Dubbo服务声明1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd" &gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="dubbo_provider" /&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" /&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880" /&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface="com.zh.service.DubboTestService" ref="dubboTestService" /&gt;&lt;/beans&gt; Web.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring和mybatis的配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 编码过滤器 Spring中的字符编码过滤器（CharacterEncodingFilter），可以很方便的为我们解决项目中出现的中文乱码问题；--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- Filter负责拦截的URL 全部以/的请求,如果&lt;url-pattern&gt;/*.action &lt;/&gt;,将会以拦截*.action的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- shiro过滤器定义 --&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;!-- 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 --&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 拦截所有请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器,配合它一起使用的，经常是context-param，用来指定Spring要加载的配置文件，本质上是创建了一个 WebApplicationContext--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- druid start--&gt; &lt;!-- 配置sql监控 start--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;!-- 网页监控路径放在了项目路径下的 druid路径中 --&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置sql监控 end--&gt; &lt;!-- 监控jsp和do请求，exclusions参数其实可以去掉的 start --&gt; &lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置SESSION超时，单位是分钟 --&gt; &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!--定义一个cxf的servlet,访问webservice/*这个地址就会进入CXF的servlet中。--&gt; &lt;servlet&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/webservice/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 监控jsp和do请求，exclusions参数其实可以去掉的 end --&gt; &lt;!-- druid end--&gt; &lt;!-- Spring MVC servlet --&gt; &lt;!-- DispatcherServlet则定义了mvc的相关内容，并配置拦截的url，所有/开头的请求，都会通过SpringMVC这个servlet进行处理。 --&gt; &lt;!-- 如果你的DispatcherServlet拦截"*.do"这样的有后缀的URL，就不存在访问不到静态资源的问题。 --&gt; &lt;!-- 如果你的DispatcherServlet拦截"/"，为了实现REST风格，拦截了所有的请求，那么同时对*.js,*.jpg等静态文件的访问也就被拦截了。--&gt; &lt;!-- 激活Tomcat的defaultServlet来处理静态文件，如下面&lt;servlet-name&gt;default&lt;/servlet-name&gt;所配 --&gt; &lt;!-- Servlet拦截匹配规则要自已定义，把拦截下来的请求，交给对于对应的@RequestMapping方法进行处理,也就是依据某某规则分发到目标Controller(我们写的Action)来处理。 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- default servlet映射，此处可以可以配置成*.do，对应struts的后缀习惯 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/turnToIndex.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/notfound.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;!-- 确保静态资源可以被访问,对客户端请求的静态资源如图片、 JS文件等的请求交由默认的servlet进行处理,不然访问会报404 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.png&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.swf&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.txt&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ico&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 这里主要是这一句，修改为加载全部以Spring开头的配置文件：1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/context-param&gt; Dubbo-admin管理平台的安装需要将Zookeeper注册中心先启动。 因为zookeeper只是一个黑框，我们无法看到是否存在了什么提供者或消费者，这时就要借助Dubbo-Admin管理平台来实时的查看，也可以通过这个平台来管理提者和消费者。 dubbo-admin.war可在网上百度去下载，但是我下载了好几个war包，发布上去服务启动都报错，这个时候大概是我们系统的JDK和编译dubbo-admin.war的JDK版本不同导致的了。网上推荐说可以直接下载了dubbo-master的源代码，然后自己编译了一个war包，这样就不会存在启动报错的问题了。但是由于阿里停止更新了dubbo，我在使用Maven编译的过程中出现了could not find art ifact com.alibaba:dubbo:jar:2.5.4-SNAPSHOT 异常，这个依赖没有下载下来，导致编译失败，Google了一圈，网上遇到这个问题的童鞋都是更换了maven的公共仓库进行下载，我换了N个都不行，都是最后到这里都卡住。最后花了两积分在CSDN上下载了个jdk1.8能用的dubbo-admin-2.5.4-SNAPSHOT.war，总算是可以在tomcat中启动成功了。 这里提分享给大家我从CSDN上下载的适用于JDK1.8的war包：dubbo-admin-2.5.4-SNAPSHOT.war 自行下载源码编译war包的方式请参考：传送门 这里下载Dubbo-admin2.5.4.war，我将war改名为Root.war复制到Tomcat/webapp目录下，启动Tomcat进行编译，当然你也可以不改名直接放到webapp下。 编译后关闭tomcat，检查项目中的配置文件： D:\apache-tomcat-8.0.9\webapps\ROOT\WEB-INF\dubbo.properties 是否是如下内容： 123dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.admin.root.password=root dubbo.admin.guest.password=root 如果是，就不用改，这里的127.0.0.1对应的是自己的电脑IP，因为这里zookeeper也在自己电脑上，所以要这么写才行。一般情况下都是不需要改的，因为初始都是本地的IP地址。但还是看看比较安全。 接下来我们再启动tomcat就可以正常访问了，这里注意，一定要将Zookeeper注册中心先启动。 http://localhost:8803/ 用户名：root 密码：root 启动service端 因为我之前已经将配置好的dubbo-service服务端(服务提供者)部署到tomcat下面了，所以打开Dubbo-admin页面，我们看到已经有了1个应用、1个服务、1个提供者。 具体服务 点击服务治理–服务，查看具体服务 客户端配置dubbo-client项目 接口声明 同样需要将服务接口在客户端声明(将provider的接口生成jar包引入，或者直接拷贝到dubbo-client项目（包名必须一样）)。 DubboTestService.java 1234567891011121314package com.zh.service;import com.zh.model.User;/** * Dubbo消费者接口 * @author Administrator * */public interface DubboTestService &#123; public int insert(User record);&#125; dubbo服务声明spring-dubbo.xml 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd" &gt; &lt;!-- 消费方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="dubbo_consumer" /&gt; &lt;!-- 使用zookeeper注册中心订阅服务地址 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" /&gt; &lt;!-- 用dubbo协议在20880端口调用服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880" /&gt; &lt;!-- 声明需要调用的服务接口 --&gt; &lt;dubbo:reference interface="com.zh.service.DubboTestService" id="dubboTestService" check="false"/&gt;&lt;/beans&gt; 实体类声明说明：服务端和客户端中需要交互的实体类必须实现Serializable接口(序列化) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.zh.model;import java.io.Serializable;@SuppressWarnings("serial")public class User implements Serializable&#123; private Integer id; private String userName; private String password; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName == null ? null : userName.trim(); &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password == null ? null : password.trim(); &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 启动客户端小知识：Service通常用于标注一个业务处理类@Service(“demoService”)表示这个bean的名字是“demoService” 这里写上面那条小知识的原因是，我之前没有在controller中使用@Resource注解将dubboTestService这个实现类的bean装配注入，结果导致消费者没有向zookeeper注册中心订阅自己所需的服务，dubbo admin页面中自然不会新增消费者。所以我的理解是，项目启动时，将dubboTestService这个实现类注入的时候，dubbo会根据配置文件中id=”dubboTestService”这个属性找到配置文件中需要向zookeeper注册中心订阅的接口，然后再通过这个接口名称向zookeeper注册中心订阅该服务。 这里我直接通过jetty启动dubbo-client项目(消费者) 启动后我们刷新dubbo-admin页面，新增了1个应用，1个消费者。就是我们的dubbo-client项目。 消费者管理页面： 测试效果UserController.java12345678910111213141516171819202122@Controller @RequestMapping("/user") // /user/**public class UserController &#123; @Resource //这里其实是由dubbo远程调用得到的对象 private DubboTestService dubboTestService; //测试dubbo调用 @RequestMapping(value = "/insert",method = &#123; RequestMethod.GET &#125;) @ResponseBody public void insert()&#123; User user = new User(); user.setAge(12); user.setPassword("123456"); user.setUserName("测试dubbo"); dubboTestService.insert(user); &#125;&#125; 我们在浏览器中输入url进行测试：http://localhost:8000/user/insert 查看数据库,新增了一条记录，测试成功： 总结： Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。 主要核心部件： Remoting: 网络通信框架，实现了 sync-over-async 和 request-response 消息机制. RPC: 一个远程过程调用的抽象，支持负载均衡、容灾和集群功能 Registry: 服务目录框架用于服务的注册和服务事件发布和订阅 补充dubbo-monitor 监控中心的配置部署过程简单介绍下monitor： Simple Monitor挂掉不会影响到Consumer和Provider之间的调用，所以用于生产环境不会有风险。 配置好了之后可以结合admin管理后台使用，可以清晰的看到服务的访问记录、成功次数、失败次数等.. Simple Monitor采用磁盘存储统计信息，请注意安装机器的磁盘限制，如果要集群，建议用mount共享磁盘。 百度了一下，发现有人在这个简单dubbo监控中心的基础上，二次开发了一个比较完善的版本，走的是数据库而不是写文件，比较优雅，以后实际在生产环节使用可以参考。传送门 这里我就介绍一下简易控制中心monitor的配置和部署 dubbo-monitor是一个web工程，是基于内嵌的jetty。dubbo-monitor是使用Java编写的项目，所以需要安装jdk。 首先下载dubbo-monitor-simple-2.5.3，下载地址: dubbo-monitor-simple-2.5.3 下载下来后，我们发现是一个tar格式的在linux上进行压缩的压缩文件。我本机使用的是windows，所以直接对其进行解压。 解压后再dubbo-monitor-simple-2.5.3根目录下，我们会看到lib、conf、bin三个文件夹。这里我们打开conf文件夹下的dubbo.properties配置文件进行配置。 dubbo.properties1234567891011121314151617181920212223242526272829### Copyright 1999-2011 Alibaba Group.# # Licensed under the Apache License, Version 2.0 (the "License");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at# # http://www.apache.org/licenses/LICENSE-2.0# # Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an "AS IS" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.##dubbo.container=log4j,spring,registry,jettydubbo.application.name=simple-monitordubbo.application.owner=#dubbo.registry.address=multicast://224.5.6.7:1234dubbo.registry.address=zookeeper://127.0.0.1:2181 #dubbo.registry.address=redis://127.0.0.1:6379#dubbo.registry.address=dubbo://127.0.0.1:9090dubbo.protocol.port=7070dubbo.jetty.port=9090dubbo.jetty.directory=D:/dubboMonitor/monitordubbo.charts.directory=D:/dubboMonitor/chartsdubbo.statistics.directory=D:/dubboMonitor/monitor/statisticsdubbo.log4j.file=logs/dubbo-monitor-simple.logdubbo.log4j.level=WARN 这里对比较重要的几条配置进行说明： dubbo.registry.address=zookeeper://127.0.0.1:2181 将ip 端口号 修改为 zookeeper服务器的ip地址端口号，如果你的zookeeper是集群，则注册地址修改为zookeeper://127.0.0.1:2181?backup=127.0.0.1:2182,127.0.0.1:2183 dubbo.protocol.port=7070 协议端口，端口号只要是没有被占用就行 dubbo.jetty.port=9090 jetty提供web服务的端口号，即通过 浏览器访问 监控中心的端口号其他的配置默认就行，当然也可以自己配置。 dubbo.jetty.directory=D:/dubboMonitor/monitor 在配置dubbo.jetty.directory=/aa/bb/monitor 时候 monitor这个目录不存在，默认是不会自动给创建这个目录的，他下面的charts和统计的会自动创建，所以这里我自己在D盘创建了dubboMonitor这个目录，并在下面创建了monitor目录。 dubbo.charts.directory=D:/dubboMonitor/charts charts目录不需要自己创建，如果创建会出现监控图表无法显示的问题。该目录会自动生成，根据dubbo调用次数、平均调用时间所生成的图片会保存在这个目录下面 dubbo.statistics.directory=D:/dubboMonitor/monitor/statistics 该目录下面存放的是根据dubbo调用次数、调用时间所统计相关的数据，以文件的形式进行保存。 配置完成后，不要忘了在我们的消费者(dubbo-client)以及生产者(dubbo-service)项目中的spring-dubbo.xml配置文件中配置monitor监控。 spring-dubbo.xml 1234&lt;!-- 监控中心配置 --&gt; &lt;!-- 监控中心协议，如果为protocol="registry"，表示从注册中心发现监控中心地址，否则直连监控中心 --&gt;&lt;!-- 直连监控中心服务器地址，如：address="192.168.3.71:7070"--&gt;&lt;dubbo:monitor protocol="registry"/&gt; 我们启动zookeeper注册中心、dubbo-admin管理平台、生产者(dubbo-service)、消费者(dubbo-client)、最后启动dubbo-monitor。 dubbo-monitor启动方式：windows下运行dubbo-monitor-simple-2.5.3\bin目录下的start.bat，linux运行start.sh文件。弹出命令框后不要关闭，输出以下信息代表启动成功。 浏览器访问地址 http://192.168.17.129:9090/ 显示页面(为方便理解我用google浏览器翻译了一下) 我在浏览器中调用了两次插入操作的方法url：http://localhost:8000/user/insert 我们可以查看调用情况统计，如下图： 也可以查看调用统计信息图表，如下图： 以上就是dubbo-monitor监控中心的配置和部署，这样，使用dubbo两个必备的工具，dubbo的管理控制台以及简易控制中心monitor我们都有了，是不是很兴奋。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构建前端Mock Server--RAP部署及使用]]></title>
      <url>%2Fblog%2F2017%2F03%2F24%2F%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AFMock%20Server--RAP%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[RAP是阿里的一套完整的可视化接口管理工具，可以定义接口结构，动态生成模拟数据，校验真实接口正确性。不仅如此，RAP围绕接口定义，提供了一系列包括团队管理、项目管理、文档版本管理、mock插件等服务。RAP可以完全可视化地定义项目相关信息，定义接口的请求响应等等，学习成本较低。RAP还为后端开发人员提供了校验接口的功能，为前端开发人员提供了mock数据的工具等。 RAP使用场景mock：模拟的，虚假的 mock server：模拟服务，模拟请求，模拟虚假数据 为了前后端更好的分工，接口文档是必须的，前后端都根据接口文档写代码，然后对接接口就行了。 但是，后端跟不上前端节奏，接口跟不上来怎么办？即便接口跟上来了，大后端数据跟不上又怎么办？ 第一种想到的方法就是模拟返回数据，根据接口文档定义好的返回数据格式，新建一个json文件夹，里面放一堆*.json文件，像这样： 然后请求json数据，像这样： 所以为了前端有数据，就会有很多很多的请求json文件。当后端接口上来后，又要一个一个挨着去把json请求改为真实接口名，这就要求代码需要写的比较规范，不然接口的对接真的很难受，而且在修改某些复杂逻辑的地方的时候还必须的小心翼翼，不然就只有等测试发来bug单了。 造json文件模拟请求对于小的项目确实还是挺方便的，但是项目大了呢，上百个接口甚至更多呢？ 一堆一堆的json看着都烦，还不说前后端对接了。 那么要怎么才能解决前后分离，节约时间，提高开发效率，减少前端对后端的依赖呢？ 那就是为前端提供一个可以在本地用的web容器，这个就是 mock server。 mock server 能解决哪些问题呢？ 接口文档的编写 根据接口拦截请求，返回接口需要返回的结果数据 方便线上线下的切换 我这里要用做mockserver的就是rap了，rap结合了团队管理，项目管理，文档编写、Mock.js、可视化、接口过渡、文档历史版本（赞）、mock插件（线上线下切换就只需要注释一句代码就OK），支持本地部署。 RAP部署那么怎么将rap部署到本地呢？官网有部署手册：传送门 我这里是部署到windows环境下的。 部署方式有两种： 使用编译好的war包部署（适合仅想部署RAP服务，不需开发定制功能的同学） 使用源码自行编译、开发后部署（需配置J2EE开发环境， 适合想要研究RAP源代码，开发定制功能的同学） 我们不需要自行开发就采用war包部署。 需要环境：jdk，tomcat，MySQL，Redis 第一步：在官网 传送门 将最新的war包下下来，然后改名为ROOT.war，放到tomcat下面的webapps里面 第二步：启动tomcat，该war包自动部署到文件夹ROOT 第三步：修改数据库配置文件，打开ROOT中的WEB-INF/classes/config.properties 123456jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://localhost\:3306/rap_db?useUnicode\=true&amp;characterEncoding\=utf8&amp;zeroDateTimeBehavior\=convertToNull&amp;noAccessToProcedureBodies\=truejdbc.username=rootjdbc.password=rootredis.host=localhostredis.port=6379 jdbc.username=您的数据库用户名 jdbc.password=您的数据库密码 redis的端口号默认 配置完数据库连接后，我们要在mysql中运行官方提供的sql脚本，以便RAP系统使用。 rap_db.sql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562CREATE DATABASE IF NOT EXISTS rap_db DEFAULT CHARSET utf8 COLLATE utf8_general_ci;USE rap_db;/************************************************** * * * account module * * * **************************************************//** * user table */CREATE TABLE tb_user( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, account VARCHAR(32) NOT NULL COMMENT '账户名 account name', password VARCHAR(128) NOT NULL COMMENT '密码 password', name VARCHAR(256) NOT NULL COMMENT '名字/昵称 name/nickname', email VARCHAR(256) NOT NULL COMMENT 'email', create_date TIMESTAMP NOT NULL COMMENT '创建日期 create date' DEFAULT now(), is_locked_out INT(1) NOT NULL COMMENT '用户是否锁定 is the user locked out' DEFAULT 0, is_hint_enabled INT(1) NOT NULL COMMENT '是否开启新手引导 is user hint enabled' DEFAULT 1, last_login_date DATETIME NOT NULL COMMENT '最近登录 last login date', incorrect_login_attempt INT(10) NOT NULL COMMENT '错误登录次数，登录成功后会重置为0 count of incorrect login attempts, will be set to 0 after any succesful login' DEFAULT 0, realname VARCHAR(128) NOT NULL COMMENT '真实姓名' DEFAULT '', emp_id VARCHAR(45) NULL COMMENT '工号，可选', mock_num INT(10) NOT NULL COMMENT 'mock次数，用于记录该用户所创建的接口被调用的mock次数。 mock num, used for record mock API invokation count' DEFAULT 0) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * role table * roles instruction: * user - every registered shuold have this role * rd - research and development engineering * qa - quality engineering * pm - project manager * op - operation manager * admin - administrator * god - super admin */CREATE TABLE tb_role( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(16) NOT NULL COMMENT '角色名称 role name') ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * user role table */CREATE TABLE tb_role_and_user( user_id INT(10) NOT NULL, role_id INT(10) NOT NULL, PRIMARY KEY (user_id, role_id), FOREIGN KEY (user_id) REFERENCES tb_user (id), FOREIGN KEY (role_id) REFERENCES tb_role (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/************************************************** * * * project module * * * **************************************************//** * parameter table */CREATE TABLE tb_parameter( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(256) NULL COMMENT '参数含义 parameter name', identifier VARCHAR(256) NULL COMMENT '变量名/参数标识符 parameter identifier', data_type VARCHAR(32) NULL COMMENT '数据类型 data type', remark TEXT NULL COMMENT '备注/mock数据等 remark/mock data', expression VARCHAR(128) NULL COMMENT '备用字段：表达式 backup column:expression', mock_data TEXT NULL COMMENT '备用字段:mock数据 backup column:mock data') ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * project table * workspace_mode 1-vss(default) 2-svn * stage 1-design 2-developing 3-debug */CREATE TABLE tb_project( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, `version` VARCHAR(128) NOT NULL COMMENT '版本号 version no.' DEFAULT '0.0.0.1', name VARCHAR(128) NOT NULL COMMENT '项目名称 project name', create_date TIMESTAMP NOT NULL COMMENT '创建日期 create date' DEFAULT now(), user_id INT(10) NOT NULL COMMENT '创建人ID, project author id', introduction TEXT NULL COMMENT '项目描述 project introduction', workspace_mode INT(10) NOT NULL COMMENT '工作区提交模式(类VSS or SVN)，暂时弃用了。 Workspace submit mode, deprecated.' DEFAULT 1, stage INT(10) NOT NULL COMMENT '项目阶段，暂时废弃;project stage, temply deprecated. 1-design 2-developing 3-debug' DEFAULT 1, project_data LONGTEXT NULL COMMENT '项目JSON数据，存放当前最新的版本。 project JSON data, saved the newest version of the project', group_id INT(10) NULL COMMENT '分组ID group id', related_ids VARCHAR(128) NOT NULL COMMENT '路由ID，用于指定与哪些项目共享mock数据; router id, used for specify sharing data with which projects.' DEFAULT '', update_time DATETIME NOT NULL COMMENT '更新时间 update time', mock_num INT NOT NULL COMMENT 'mock次数 mock num' DEFAULT 0, access_type TINYINT NOT NULL COMMENT '权限控制, 10普通, 0私有' DEFAULT 10, FOREIGN KEY (user_id) REFERENCES tb_user (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * user list and user table * used for creating multiple to multiple mapping * access_level: * 1 - read * 2 - read&amp;write * 3 - read&amp;write&amp;manage */CREATE TABLE tb_project_and_user( project_id INT(10) NOT NULL, user_id INT(10) NOT NULL, access_level INT NOT NULL DEFAULT 1, PRIMARY KEY (project_id, user_id), FOREIGN KEY (project_id) REFERENCES tb_project (id), FOREIGN KEY (user_id) REFERENCES tb_user (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * module table */CREATE TABLE tb_module( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, project_id INT(10) NOT NULL, name VARCHAR(256) NOT NULL, introduction VARCHAR(128) NULL, FOREIGN KEY (project_id) REFERENCES tb_project (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * page table */CREATE TABLE tb_page( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(56) NOT NULL, module_id INT(10) NOT NULL, introduction TEXT NULL, template VARCHAR(128) NULL, FOREIGN KEY (module_id) REFERENCES tb_module (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * action table * request_type: * 1 - get * 2 - post * 3 - ajax get * 4 - ajax post */CREATE TABLE tb_action( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(256) NOT NULL, description TEXT NULL, /* request block */ request_type INT NOT NULL COMMENT '请求类型get/post/put/delete等等 request type' DEFAULT 1, /** request_type = 99, mount type **/ request_url TEXT NULL, disable_cache TINYINT NOT NULL COMMENT '禁用Mock缓存 disable mock cache' DEFAULT 0, /* response block */ response_template TEXT NULL COMMENT '响应模板地址, 暂时弃用。 response template address, temply deprecated.') ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * action and page table * used for creating multiple to multiple mapping */CREATE TABLE tb_action_and_page( action_id INT(10) NOT NULL, page_id INT(10) NOT NULL, FOREIGN KEY (action_id) REFERENCES tb_action (id), FOREIGN KEY (page_id) REFERENCES tb_page (id), PRIMARY KEY (action_id, page_id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * parameter and parameter mapping * complex_parameter has so many parameters(List&lt;Map&gt; or Map) */CREATE TABLE tb_complex_parameter_list_mapping( complex_parameter_id INT(10) NOT NULL, parameter_id INT(10) NOT NULL, PRIMARY KEY (complex_parameter_id, parameter_id), FOREIGN KEY (complex_parameter_id) REFERENCES tb_parameter (id), FOREIGN KEY (parameter_id) REFERENCES tb_parameter (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * parameter and action's request mapping */CREATE TABLE tb_request_parameter_list_mapping( action_id INT(10) NOT NULL, parameter_id INT(10) NOT NULL, PRIMARY KEY (action_id, parameter_id), FOREIGN KEY (action_id) REFERENCES tb_action (id), FOREIGN KEY (parameter_id) REFERENCES tb_parameter (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * parameter and action's response mapping */CREATE TABLE tb_response_parameter_list_mapping( action_id INT(10) NOT NULL, parameter_id INT(10) NOT NULL, PRIMARY KEY (action_id, parameter_id), FOREIGN KEY (action_id) REFERENCES tb_action (id), FOREIGN KEY (parameter_id) REFERENCES tb_parameter (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/************************************************** * * * workspace module * * * **************************************************//** * workspace, deprecated 工作区，暂时未使用 */CREATE TABLE tb_workspace( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, project_id INT(10) NOT NULL, user_id INT NOT NULL, create_date TIMESTAMP NOT NULL DEFAULT now(), update_date DATETIME NOT NULL, project_data LONGTEXT NOT NULL, project_data_original LONGTEXT NOT NULL, FOREIGN KEY (project_id) REFERENCES tb_project (id), FOREIGN KEY (user_id) REFERENCES tb_user (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * workspace save, deprecated 工作区保存草稿，暂时未使用 */CREATE TABLE tb_workspace_save( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, workspace_id INT(10) NOT NULL, update_date DATETIME NOT NULL, project_data LONGTEXT NOT NULL, FOREIGN KEY (workspace_id) REFERENCES tb_workspace (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * check in table * every API document submit saved here, used for version control. * 每一次提交记录在这里，用于版本管理和回滚控制 * workspaceMode 1-VSS 2-SVN */CREATE TABLE tb_check_in( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, create_date TIMESTAMP NOT NULL DEFAULT now(), tag VARCHAR(128) NULL COMMENT 'tag标签 暂时未使用 deprecated', user_id INT(10) NOT NULL COMMENT '提交人 submit user id', project_id INT(10) NOT NULL COMMENT '提交的项目ID submit project id', description TEXT NULL COMMENT '提交描述 submit description', version VARCHAR(128) NOT NULL COMMENT '版本号 version no.', project_data LONGTEXT NOT NULL COMMENT '项目JSON数据 project json data', workspace_mode INT(10) NOT NULL COMMENT '工作区模式(弃用) workspace mode(deprecated)', log TEXT NULL COMMENT '更新日志，用于存储与最近一个版本的对比差异。暂时未使用。update log, used for calculate versions differences. Deprecated.', FOREIGN KEY (user_id) REFERENCES tb_user (id), FOREIGN KEY (project_id) REFERENCES tb_project (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * user settings table * 用户配置表 */CREATE TABLE tb_user_settings( user_id INT(10) NOT NULL, `key` VARCHAR(128) NOT NULL COMMENT '配置KEY config key', `value` VARCHAR(128) NOT NULL COMMENT '配置VALUE config value', PRIMARY KEY (user_id, `key`), FOREIGN KEY (user_id) REFERENCES tb_user (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * user notification table * 用户通知表 */CREATE TABLE tb_notification( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, user_id INT(10) NOT NULL COMMENT '接受通知的用户id; user id to be notified.', target_user_id INT(10) NOT NULL COMMENT '上下文用户id; context user id', type_id SMALLINT NOT NULL COMMENT '1-文档修改,2-被加入新项目', param1 VARCHAR(128) NULL COMMENT '1,2-项目id', param2 VARCHAR(128) NULL COMMENT ' 1,2-项目名称', param3 TEXT NULL COMMENT '备用预留 reserved', create_time TIMESTAMP NOT NULL COMMENT '创建时间 create time' DEFAULT now(), is_read SMALLINT NOT NULL COMMENT '是否已读 is notification read' DEFAULT 0, FOREIGN KEY (user_id) REFERENCES tb_user (id), FOREIGN KEY (target_user_id) REFERENCES tb_user (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * corporation table * 公司表 */CREATE TABLE tb_corporation( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(256) NOT NULL, logo_url VARCHAR(256) NULL, user_id INT(10) NULL, access_type TINYINT NOT NULL COMMENT '权限控制, 10普通, 20公开' DEFAULT 10, `desc` TEXT NOT NULL COMMENT '备注', FOREIGN KEY (user_id) REFERENCES tb_user (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * product line table * 生产线表 */CREATE TABLE tb_production_line( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(256) NOT NULL, project_num INT(10) NOT NULL DEFAULT 0, corporation_id INT(10) NOT NULL, user_id INT(10) NOT NULL, FOREIGN KEY (user_id) REFERENCES tb_user (id), FOREIGN KEY (corporation_id) REFERENCES tb_corporation (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * project group table * 项目分组表 */CREATE TABLE tb_group( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(256) NOT NULL, production_line_id INT(10) NOT NULL, user_id INT(10) NOT NULL, FOREIGN KEY (user_id) REFERENCES tb_user (id), FOREIGN KEY (production_line_id) REFERENCES tb_production_line (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * 规则表，存储通过Open API设置的Mock规则 * Stored mock rules set by Open API */CREATE TABLE tb_rule ( action_id INT(10) NOT NULL PRIMARY KEY, rules TEXT NOT NULL, -- JSON规则 update_time DATETIME NOT NULL DEFAULT NOW(), -- 最近更新时间 FOREIGN KEY (action_id) REFERENCES tb_action (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;CREATE TABLE tb_corporation_and_user( user_id INT(10) NOT NULL, corporation_id INT(10) NOT NULL, role_id INT(10) NOT NULL, PRIMARY KEY (user_id, corporation_id), FOREIGN KEY (user_id) REFERENCES tb_user (id), FOREIGN KEY (corporation_id) REFERENCES tb_corporation (id), FOREIGN KEY (role_id) REFERENCES tb_role (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;-- required base dataINSERT INTO tb_role (name) VALUES ('god');INSERT INTO tb_role (name) VALUES ('admin');INSERT INTO tb_role (name) VALUES ('user');-- removed unused qa/pm/rd rolesINSERT INTO tb_user (account, password, email, create_date, last_login_date, name) VALUES ('admin', 'RESERVED', 'admin@example.com', NOW(), NOW(), 'admin');INSERT INTO tb_role_and_user (user_id, role_id) VALUES (1, 1);-- INSERT INTO tb_corporation (name, logo_url, user_id) VALUES ('MyTeam', 'empty', 1);-- 新版RAP可以自建团队，不需要插入默认团队了。-- RAP v0.11.5+ users can create teams by their own, so there's no need to set default team. 注意，因最新的mysql的sql_mode设置的比较严格，需要手动配置下SQL_MODE来禁止full_group检查，可以改MySQL配置文件，或者运行如下SQL语句来修改SQL_MODE： 1SET @@global.sql_mode = 'STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION'; 安装redis请参见：http://blog.csdn.net/erlian1992/article/details/54382443 在redis根目录下启动redis： 启动redis命令：1redis-server.exe redis.windows.conf 测试使用开启tomcat和redis，浏览器输入：localhost:8803(我tomcat设置了端口号，默认为8080) 进入RAP的WEB页面说明部署成功了。 首先我们注册一个普通账户，并登陆： 在tb_role_and_user中添加一条记录将我们的账户进行提权，user_id是管理员的id，role_id是1(超级管理员)或2(管理员)。 提权之后我们注册的用户就有超级管理员的权限了。 RAP接口管理的使用方式十分简单，大家自己操作几遍就会了，这里给小白说几个常用的功能点，避免遇到太多坑： 1、 参数录入问题 在进行RAP接口文档编写时，有些接口参数比较多，里大家可以不要浪费时间一个一个去添加参数，直接把我们服务端返回给前端的json导入，会自动生成参数及对应的数据，我们只需要输入每个字段的含义就可以了。 导入以下json：1&#123;"age":24,"id":1,"password":"345","userName":"Maven1库"&#125; 效果如下： 2、 Http请求问题 这个应该是大家比较关心的问题，既然RAP这么强大，如何根据URL请求RAP中编写好的接口，让前端调用该接口和调用服务端一样返回数据呢？ 点击这里进入该接口的控制台： 在控制台中点击请求，这里返回了我们之前导入的JSON数据： 点击请求时，右下角出现了一个请求url，该url就是以页面右上角的请求根路径拼上我们编写接口文档时设置的请求Url获得的，前端可通过该路径进行开发测试，切换到线上版本注释掉该路径更换为线上版本的路径就可以了，是不是很方便？ 1http://localhost:8803/mockjs/2/user/showUser? RAP的使用方式就写到这里，我目前主要进行服务端开发，编写好接口后直接在RAP中进行同步，前端不需要等我把最新的项目部署到服务器，直接根据RAP接口进行开发，提升了工作效率，减少了沟通时间。 Linux 下的部署与windws下没有太大区别，无非是启动redis、将RAP的war包修改成ROOT放到Tomcat的webapp下（RAP官方指出该项目必须放在ROOT下），启动tomcat进行编译，修改RAP的数据库配置文件，再次进行发布就可以了，如果公司有需要可以换换logo，就可以拿出来用了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx使用小结]]></title>
      <url>%2Fblog%2F2017%2F03%2F21%2Fnginx%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[相信很多人都听过nginx，这个小巧的东西慢慢地在吞食apache和IIS的份额。那究竟它有什么作用呢？可能很多人未必了解。 说到反向代理，可能很多人都听说，但具体什么是反向代理，很多人估计就不清楚了。摘一段百度百科上的描述： 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 这里讲得很直白。反向代理方式实际上就是一台负责转发的代理服务器，貌似充当了真正服务器的功能，但实际上并不是，代理服务器只是充当了转发的作用，并且从真正的服务器那里取得返回的数据。这样说，其实nginx完成的就是这样的工作。我们让nginx监听一个端口，譬如80端口，但实际上我们转发给在8080端口的tomcat，由它来处理真正的请求，当请求完成后，tomcat返回，但数据此时没直接返回，而是直接给nginx，由nginx进行返回，这里，我们会以为是nginx进行了处理，但实际上进行处理的是tomcat。说到上面的方式，也许很多人又会想起来，这样可以把静态文件交由nginx来进行处理。对，很多用到nginx的地方都是作为静态伺服器，这样可以方便缓存那些静态文件，比如CSS，JS，html，htm等文件。 闲话就不多说了，我们直接来看看nginx怎么使用。 nginx下载部署要用到的软件当然要下载啦。到nginx官网下一个。http://nginx.org/en/download.html 可以到这里去下。我现在用的版本是nginx-1.8.1，但基本上以后的版本都兼容，而且我们用到的并不涉及到太底层的，应该不会有什么变化。 这里，由于我的是windows，当然下windows版啦。下完后首先要启动吧。进入到nginx根目录，直接启动nginx.exe就OK了。 这里也许你会看到一个窗口一闪而过，根据我们使用tomcat的经验，如果一闪而过，证明有错误了，是吧？但实际上不是。 此时我们打开任务管理器，可以看到两个nginx.exe进程在那里好好的。这说明我们已经启动了，这两个进程一个是nginx的master进程,为主进程,用于控制nginx各个进程之间的协调工作关系 另一个是nginx的worker进程,用于处理用户的请求。 现在，我们已经启动了nginx，这时就可以启动tomcat，想着直接访问http://localhost就可以直接访问tomcat了。 先不急，我们来看看启动后的nginx是怎样的。直接访问http://localhost可以看到： 我们可以看到nginx启动成功，现在访问是直接进到nginx的目录里面了。 nginx配置那么这些实际上是在哪里配置的。这就涉及到nginx的一个重要配置文件nginx.conf了。 我们可以看到nginx文件夹内有一个conf文件夹，其中有好几个文件，其他先不管，我们打开nginx.conf，可以看到一段： 这段代码在server里面，相当于一个代理服务器，当然可以配置多个。下面我们仔细来分析一下： listen：表示当前的代理服务器监听的端口，默认的是监听80端口。注意，如果我们配置了多个server，这个listen要配置不一样，不然就不能确定转到哪里去了。server_name：表示监听到之后需要转到哪里去，这时我们直接转到本地，这时是直接到nginx文件夹内。 location：表示匹配的路径，这时配置了/表示所有请求都被匹配到这里root：里面配置了root这时表示当匹配这个请求的路径时，将会在这个文件夹内寻找相应的文件，这里对我们之后的静态文件伺服很有用。 index：当没有指定主页时，默认会选择这个指定的文件，它可以有多个，并按顺序来加载，如果第一个不存在，则找第二个，依此类推。 下面的error_page是代表错误的页面，这里我们暂时不用，先不管它。那我们知道了具体的配置了，怎么让它访问localhost时转到tomcat时。实际上就修改两个地方：12345server_name localhost:8080; location / &#123; proxy_pass http://localhost:8080;&#125; 我们就修改了上面两个地方，我的tomcat在8080端口，可以根据自己的需要修改。这里有一个新元素proxy_pass，它表示代理路径，相当于转发，而不像之前说的root必须指定一个文件夹。(这里注意，增加配置时需要加;号的地方一定要加上，不然会报错) 此时我们修改了文件，是不是就意思着必须先关了nginx再重新启动了，其实不必，nginx可以重新加载文件的。 我们直接运行：1nginx -s reload 如果不想直接加载，而只是想看看自己的配置文件有没有问题，可以直接输入：1nginx -t 这可以检查配置文件中是否有错。 下面我们所有的修改都假设我们修改完成后运行了nginx -s reload进行重新加载配置文件，请注意。 一切没问题了，然后我们再重新打开http://localhost，我们看到下面的页面： 这时，我们发现它并不是刚才的welcome页面了，而是tomcat的管理页面了，不管我们点击什么链接都是没问题的，相当于直接访问http://localhost:8080一样。 使用nginx做静态伺服上面我们直接试了一个小例子，让nginx进行转发，即所谓的反向代理。但实际上我们的需求不会是这样的，我们需要分文件类型来进行过滤，比如jsp直接给tomcat处理，因为nginx并不是servlet容器，没办法处理JSP，而html,js,css这些不需要处理的，直接给nginx进行缓存。 下面我们来进行一下配置，让JSP页面直接给tomcat，而html,png等一些图片和JS等直接给nginx进行缓存。 这时最主要用的还是location这个元素，并且涉及到一部分正则，但不难： 1234567location ~ \.jsp$ &#123; proxy_pass http://localhost:8080; &#125; location ~ \.(html|js|css|png|gif)$ &#123; root D:\apache-tomcat-8.0.9\webapps\ROOT; &#125; 我们先要去掉之前配的location /，避免全部请求被拦截了。 执行nginx的reload进行重新加载配置文件：1nginx -s reload 然后我们再来看看http://localhost 当我们不指定jsp页面的时候，它会出现找不到，因为，此时并没有相应的location匹配，所以就会有404错误，这时就跳到了nginx自定义的error页面去了。 而当我们用http://localhost/index.jsp去访问时，我们看到了熟悉的页面： 而且图片那些都显示正常，因为图片是png的，所以直接在tomcat/webapps/ROOT目录下直接查找，当然，如果我们点击Manager Application HOW-TO这个链接，我们发现： 它还是找不到，为什么呢？因为这是个html页面，但它并不在ROOT目录下，而是在docs目录下，但当我们匹配html时，我们却到ROOT目录下去找，所以还是找不到这个页面。 一般情况下，如果我们需要用nginx来进行静态文件伺服，一般都会把所有静态文件，html,htm,js,css等都放在同一个文件夹下，这样就不会有tomcat这样的情况了，因为tomcat下的是属于不同的项目，这个我们就没办法了。 nginx 负载均衡有些人会说，这些都只会找一台服务器，但如果我们想在一台服务器挂了的时候，自动去找另外一台，这怎么办？这实际上nginx都考虑到了。 这时，我们之前用的proxy_pass就有大用途了。 我们把之前的第一个例子，即全部都代理的修改一下： 最后修改如下： 12345678910upstream local_tomcat &#123; server localhost:8080; &#125; server&#123; location / &#123; proxy_pass http://local_tomcat; &#125; #......其他省略 &#125; 我们在server外添加了一个upstream，而直接在proxy_pass里面直接用http://+upstream的名称来使用。 我们还是直接来http://localhost，还是和第一个一样的效果，所有链接都没问题，说明我们配置正确。 upstream中的server元素必须要注意，不能加http://，但proxy_pass中必须加。 我们刚才说可以在一个服务器挂了的情况下连到另外一个，那怎么弄呢？ 其实很简单，在upstream中的local_tomcat中配置多一个server。比如我现在再启动RabbitMq的Web管理界面，端口在15672，所以我们配置如下： 1234upstream local_tomcat &#123; server localhost:8080; server localhost:15672; &#125; 执行nginx的reload进行重新加载配置文件：1nginx -s r 此时，我们关闭tomcat，而只开端口为15672的项目。我们来运行http://localhost看看效果： 我们看到它请求到了我端口为15672的RabbitMq的Web管理页面，我们的在一个服务器挂的情况下自动使用另外一个的功能实现了。 但有时我们就不想它挂的时候访问另外一个，而只是希望一个服务器访问的机会比另外一个大，这个可以在server最后加上一个weight=数字来指定，数字越大，表明请求到的机会越大。 1234upstream local_tomcat &#123; server localhost:8080 weight=1; server localhost:15672 weight=5; &#125; 执行nginx的reload进行重新加载配置文件：1nginx -s r 这时我们给了RabbitMq Web管理界面一个更高的权重值，让它更有机会访问到，实际上当我们刷新http://localhost访问的时候发现RabbitMq Web管理界面访问机率大很多，tomcat几乎没机会访问，一般情况下，如果我们必须这样用，不要相关太大，以免一个服务器负载太大。 当然,server还有一些其他的元素，比如down表示暂时不用到该服务器等等。这些可以参考nginx的wiki。也许写了一大堆，有人会有问题，那nginx怎么关闭呢？这倒是个问题，其实直接运行nginx -s stop就可以关闭了。 基本上nginx的用法是这样，深入的以后我们如果用到再学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RabbitMQ与Spring结合讲解(使用amqp消息协议)]]></title>
      <url>%2Fblog%2F2017%2F03%2F16%2FRabbitMQ%E4%B8%8ESpring%E7%BB%93%E5%90%88%E8%AE%B2%E8%A7%A3(%E4%BD%BF%E7%94%A8amqp%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE)%2F</url>
      <content type="text"><![CDATA[RabbitMQ是一个消息代理。它的核心原理非常简单：接收和发送消息。你可以把它想像成一个邮局：你把信件放入邮箱，邮递员就会把信件投递到你的收件人处。在这个比喻中，RabbitMQ是一个邮箱、邮局、邮递员。RabbitMQ和邮局的主要区别是，它处理的不是纸，而是接收、存储和发送二进制的数据——消息。一般提到RabbitMQ和消息。RabbitMQ中文文档： 传送门 rabbitMQ简介rabbitMQ的应用场景你是否遇到过两个（多个）系统间需要通过定时任务来同步某些数据？你是否在为异构系统的不同进程间相互调用、通讯的问题而苦恼、挣扎？如果是，那么恭喜你，消息服务让你可以很轻松地解决这些问题。消息服务擅长于解决多系统、异构系统间的数据交换（消息通知/通讯）问题，你也可以把它用于系统间服务的相互调用（RPC）。 rabbitMQ的优点 基于erlang语言开发具有高可用高并发的优点，适合集群服务器。 健壮、稳定、易用、跨平台、支持多种语言、文档齐全。 有消息确认机制和持久化机制，可靠性高。 开源 其他MQ的优势： Apache ActiveMQ曝光率最高，但是可能会丢消息。 ZeroMQ延迟很低、支持灵活拓扑，但是不支持消息持久化和崩溃恢复。 几个相关概念说明AMQP 即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 RabbitMQ 是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 producer&amp;Consumer producer指的是消息生产者，consumer消息的消费者。 Queue 消息队列，提供了FIFO的处理机制，具有缓存消息的能力。rabbitmq中，队列消息可以设置为持久化，临时或者自动删除。 设置为持久化的队列，queue中的消息会在server本地硬盘存储一份，防止系统crash，数据丢失 设置为临时队列，queue中的数据在系统重启之后就会丢失 设置为自动删除的队列，当不存在用户连接到server，队列中的数据会被自动删除Exchange Exchange类似于数据通信网络中的交换机，提供消息路由策略。rabbitmq中，producer不是通过信道直接将消息发送给queue，而是先发送给Exchange。一个Exchange可以和多个Queue进行绑定，producer在传递消息的时候，会传递一个ROUTING_KEY，Exchange会根据这个ROUTING_KEY按照特定的路由算法，将消息路由给指定的queue。和Queue一样，Exchange也可设置为持久化，临时或者自动删除。 Exchange有4种类型：direct(默认)，fanout，topic，和headers，不同类型的Exchange转发消息的策略有所区别： Direct 直接交换器，工作方式类似于单播，Exchange会将消息发送完全匹配ROUTING_KEY的Queue fanout 广播是式交换器，不管消息的ROUTING_KEY设置为什么，Exchange都会将消息转发给所有绑定的Queue。 topic 主题交换器，工作方式类似于组播，Exchange会将消息转发和ROUTING_KEY匹配模式相同的所有队列，比如，ROUTING_KEY为user.stock的Message会转发给绑定匹配模式为 .stock,user.stock， . 和#.user.stock.#的队列。（ 表是匹配一个任意词组，#表示匹配0个或多个词组） headers 消息体的header匹配（ignore） Binding 所谓绑定就是将一个特定的 Exchange 和一个特定的 Queue 绑定起来。Exchange 和Queue的绑定可以是多对多的关系。 virtual host 在rabbitmq server上可以创建多个虚拟的message broker，又叫做virtual hosts (vhosts)。每一个vhost本质上是一个mini-rabbitmq server，分别管理各自的exchange，和bindings。vhost相当于物理的server，可以为不同app提供边界隔离，使得应用安全的运行在不同的vhost实例上，相互之间不会干扰。producer和consumer连接rabbit server需要指定一个vhost。 消息队列的使用过程 客户端连接到消息队列服务器，打开一个channel。 客户端声明一个exchange，并设置相关属性。 客户端声明一个queue，并设置相关属性。 客户端使用routing key，在exchange和queue之间建立好绑定关系。 客户端投递消息到exchange。 exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里 环境配置与安装Erlang环境安装windows下搭建教程：http://blog.csdn.net/u014308482/article/details/53994401 Linux下搭建教程：http://blog.csdn.net/evankaka/article/details/50495437 我只在本机windows环境下使用安装版搭建测试，具体如果大家在安装环境时遇到问题多百度一下，过程还是很简单的。 Rbbitmq与Spring结合使用整合依旧是基于之前教程中所搭建的SSM框架，以下是新增的项目结构： 在pom.xml中添加依赖123456&lt;!--rabbitmq依赖,amqp队列服务 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 这里要注意，如果使用高版本的spring-rabbit，比如1.7.0，会抛一个org.springframework.util.backoff.BackOff的空指针异常，这里google了一个老外的回答，貌似这个类只在4.1.X的版本上才会有，所以要更改spring核心类的版本到4.1.x以上才可以使用。 MessageProducer 消息生产者12345678910111213141516171819202122package com.zh.producer;import javax.annotation.Resource;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.stereotype.Service;/** * 功能概要：消息产生,提交到队列中去 * */@Servicepublic class MessageProducer &#123; @Resource private AmqpTemplate amqpTemplate; public void sendMessage(Object message)&#123; System.out.println("我是生产者，我发送了消息"+message); amqpTemplate.convertAndSend("queueTestKey",message); &#125;&#125; MessageConsumer 消息消费者1234567891011121314151617181920package com.zh.consumer;import org.springframework.amqp.core.Message;import org.springframework.amqp.core.MessageListener;import org.springframework.stereotype.Service;/** * 功能概要：消费接收 * */@Servicepublic class MessageConsumer implements MessageListener &#123; public void onMessage(Message message) &#123; System.out.println("我是消费者，我接收到了消息："+message); &#125;&#125; rabbitMq.xml配置信息123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.0.xsd"&gt; &lt;!--配置connection-factory，指定连接rabbit server参数 --&gt; &lt;rabbit:connection-factory id="connectionFactoryRabbit" username="guest" password="guest" host="localhost" port="5672" /&gt; &lt;!--定义rabbit template用于数据的接收和发送 --&gt; &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactoryRabbit" exchange="exchangeTest" /&gt; &lt;!--通过指定下面的admin信息，当前producer中的exchange和queue会在rabbitmq服务器上自动生成 --&gt; &lt;rabbit:admin connection-factory="connectionFactoryRabbit" /&gt; &lt;!--定义queue --&gt; &lt;rabbit:queue name="queueTest" durable="true" auto-delete="false" exclusive="false" /&gt; &lt;!-- 定义direct exchange，绑定queueTest --&gt; &lt;rabbit:direct-exchange name="exchangeTest" durable="true" auto-delete="false"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="queueTest" key="queueTestKey"&gt;&lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:direct-exchange&gt; &lt;!-- 消息接收者 --&gt; &lt;bean id="messageReceiver" class="com.zh.consumer.MessageConsumer"&gt;&lt;/bean&gt; &lt;!-- queue litener 观察 监听模式 当有消息到达时会通知监听在对应的队列上的监听对象--&gt; &lt;rabbit:listener-container connection-factory="connectionFactoryRabbit"&gt; &lt;rabbit:listener queues="queueTest" ref="messageReceiver"/&gt; &lt;/rabbit:listener-container&gt; &lt;/beans&gt; 这里我之前将connection-factory的id配置成了connectionFactory，结果报了一个无法注入的异常，排查了很久，发现是我注册redies的服务中心时，用的id也是connectionFactory，两个id相同，导致出现冲突，修改了rabbit的connection-factory的id为connectionFactoryRabbit，问题解决。 spring集成rabbitMq在spring的配置文件(spring-mybatis.xm)中引入rabbitmq配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd"&gt; &lt;!-- cxf整合Spring start--&gt; &lt;import resource="classpath:META-INF/cxf/cxf.xml"/&gt; &lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml"/&gt; &lt;!-- 自动扫描webService --&gt; &lt;context:component-scan base-package="com.zh.cxf" /&gt; &lt;!-- 定义webservice的发布接口 --&gt; &lt;jaxws:endpoint implementor="#helloWorld" address="/HelloWorld"&gt; &lt;/jaxws:endpoint&gt; &lt;!--cxf整合Spring end --&gt; &lt;!-- 自动扫描 --&gt; &lt;!-- 扫描指定package下所有带有如@controller,@services,@resource,@ods并把所注释的注册为Spring Beans --&gt; &lt;context:component-scan base-package="com.zh" /&gt; &lt;!-- 引入properties配置文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:config/jdbc.properties&lt;/value&gt; &lt;value&gt;classpath:config/redis.properties&lt;/value&gt; &lt;!--要是有多个配置文件，只需在这里继续添加即可 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- dbcp dataSource 配置 &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- druid dataSource 配置 --&gt; &lt;!-- 数据源1 --&gt; &lt;bean id="ssmdataSource1" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;url1&#125;" /&gt; &lt;property name="username" value="$&#123;username1&#125;" /&gt; &lt;property name="password" value="$&#123;password1&#125;" /&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;" /&gt; &lt;property name="filters" value="$&#123;filters&#125;" /&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;" /&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;" /&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;" /&gt; &lt;!-- 用来检测连接是否有效的sql，要求是一个查询语句。 --&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;" /&gt; &lt;!-- 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。 --&gt; &lt;property name="testWhileIdle" value="$&#123;testWhileIdle&#125;" /&gt; &lt;!-- 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 --&gt; &lt;property name="testOnBorrow" value="$&#123;testOnBorrow&#125;" /&gt; &lt;!-- 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 --&gt; &lt;property name="testOnReturn" value="$&#123;testOnReturn&#125;" /&gt; &lt;!-- 要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100 --&gt; &lt;property name="maxOpenPreparedStatements" value="$&#123;maxOpenPreparedStatements&#125;" /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;" /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;" /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name="logAbandoned" value="$&#123;logAbandoned&#125;" /&gt; &lt;/bean&gt; &lt;!-- 数据源2 --&gt; &lt;bean id="ssmdataSource2" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;url2&#125;" /&gt; &lt;property name="username" value="$&#123;username2&#125;" /&gt; &lt;property name="password" value="$&#123;password2&#125;" /&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;" /&gt; &lt;property name="filters" value="$&#123;filters&#125;" /&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;" /&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;" /&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;" /&gt; &lt;!-- 用来检测连接是否有效的sql，要求是一个查询语句。 --&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;" /&gt; &lt;!-- 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。 --&gt; &lt;property name="testWhileIdle" value="$&#123;testWhileIdle&#125;" /&gt; &lt;!-- 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 --&gt; &lt;property name="testOnBorrow" value="$&#123;testOnBorrow&#125;" /&gt; &lt;!-- 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 --&gt; &lt;property name="testOnReturn" value="$&#123;testOnReturn&#125;" /&gt; &lt;!-- 要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100 --&gt; &lt;property name="maxOpenPreparedStatements" value="$&#123;maxOpenPreparedStatements&#125;" /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;" /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;" /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name="logAbandoned" value="$&#123;logAbandoned&#125;" /&gt; &lt;/bean&gt; &lt;!-- Spring的依赖注入方式将两个数据源设置进targetDataSources。 --&gt; &lt;bean id="dataSource" class="com.zh.util.DynamicDataSource"&gt; &lt;property name="targetDataSources"&gt; &lt;map key-type="java.lang.String"&gt; &lt;entry key="sss1" value-ref="ssmdataSource1"/&gt; &lt;entry key="sss2" value-ref="ssmdataSource2"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--默认数据源--&gt; &lt;property name="defaultTargetDataSource" ref="ssmdataSource1"/&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:com/zh/mapping/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zh.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理) 配置spring的PlatformTransactionManager，名字为默认值 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 事物切面配置 --&gt; &lt;tx:advice id="advice" transaction-manager="transactionManager" &gt; &lt;tx:attributes&gt; &lt;tx:method name="update*" propagation="REQUIRED" read-only="false" rollback-for="java.lang.Exception"/&gt; &lt;tx:method name="insert" propagation="REQUIRED" read-only="false" rollback-for="java.lang.Exception"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 事务拦截器，拦截com.zh.service下所有方法 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="testService" expression="execution (* com.zh.service.*.*(..))"/&gt; &lt;aop:advisor advice-ref="advice" pointcut-ref="testService"/&gt; &lt;/aop:config&gt; &lt;!-- Redis和缓存配置开始 --&gt; &lt;!-- jedis 配置 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig" &gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt; &lt;property name="maxWaitMillis" value="$&#123;redis.maxWait&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;" /&gt; &lt;/bean &gt; &lt;!-- redis服务器中心 --&gt; &lt;bean id="connectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;property name="poolConfig" ref="poolConfig" /&gt; &lt;property name="port" value="$&#123;redis.port&#125;" /&gt; &lt;property name="hostName" value="$&#123;redis.host&#125;" /&gt; &lt;!-- &lt;property name="password" value="$&#123;redis.password&#125;" /&gt; --&gt; &lt;property name="timeout" value="$&#123;redis.timeout&#125;" &gt;&lt;/property&gt; &lt;/bean &gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" &gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="keySerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="valueSerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;/bean &gt; &lt;!-- cache配置插入、更新数据时从redis中清除缓存 --&gt; &lt;bean id="putCache" class="com.zh.redis.cache.PutCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- cache配置从redis获取缓存数据 --&gt; &lt;bean id="getCache" class="com.zh.redis.cache.GetCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置结束 --&gt; &lt;!-- Shiro 开始 --&gt; &lt;!-- 配置自定义Realm --&gt; &lt;bean id="myRealm" class="com.zh.shiro.MyRealm"/&gt; &lt;!-- 安全管理器 --&gt; &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="myRealm"/&gt; &lt;/bean&gt; &lt;!-- Shiro过滤器 核心--&gt; &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;!-- Shiro的核心安全接口,这个属性是必须的 --&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;!-- 身份认证失败，则跳转到登录页面的配置 --&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;!-- 权限认证失败，则跳转到指定页面 --&gt; &lt;property name="unauthorizedUrl" value="/nopower.jsp"/&gt; &lt;!-- Shiro连接约束配置,即过滤链的定义 --&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--anon 表示匿名访问，不需要认证以及授权--&gt; /shiroUser/loginAdmin=anon &lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt; /shiroUser/admin*=authc /shiroUser/student=roles[teacher] /shiroUser/teacher=perms["user:create"] &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt; &lt;bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/&gt; &lt;!-- 开启Shiro注解 --&gt; &lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor"/&gt; &lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;/bean&gt; &lt;!-- Shiro 结束 --&gt; &lt;!-- 引入rabbitmq配置 --&gt; &lt;import resource="classpath*:config/rabbitmq.xml" /&gt; &lt;/beans&gt; 主要是以下这两句配置: 12345&lt;!-- 自动扫描 --&gt; &lt;!-- 扫描指定package下所有带有如@controller,@services,@resource,@ods并把所注释的注册为Spring Beans --&gt;&lt;context:component-scan base-package="com.zh" /&gt; &lt;!-- 引入rabbitmq配置 --&gt;&lt;import resource="classpath*:config/rabbitmq.xml" /&gt; 测试我在这使用Maven编译一下mavenDemo这个项目，将编译好的war包发布到tomcat下，使用tomcat进行启动。同时在eclipse使用jetty启动mavenDemo，确保其都在启动状态。在其中一个项目中发送消息到rabbitMq服务器。由rabbitMq将消息分发到我的两个项目。 两个项目同时启动后: WEB控制台监听到名称为queueTest的队列： 点击连接模块也可以发现有两个连接在线： 点击queueTest队列进入详情页面，发现监听到两个消费者，分别对应我的mavenDemo项目和rabbit_c2项目 在我eclipse的mavenDemo项目中执行单元测试： 测试类 MessageTest.java： 1234567891011121314151617181920212223242526272829303132333435363738package com.javen.testmybatis;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.zh.producer.MessageProducer;/** * 功能概要： * * @author zhanghao */@RunWith(SpringJUnit4ClassRunner.class) //表示继承了SpringJUnit4ClassRunner类 @ContextConfiguration(locations = &#123;"classpath:spring-mybatis.xml"&#125;) public class MessageTest &#123; @Resource private MessageProducer messageProducer; @Test public void should_send_a_amq_message() throws Exception &#123; int a = Integer.MAX_VALUE; while (a &gt; 0) &#123; messageProducer.sendMessage("Hello World:" + a--); try &#123; //暂停一下，好让消息消费者去取消息打印出来 Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 执行JUnit单元测试控制台输出：1234567我是生产者，我发送了消息Hello World:2147483647我是生产者，我发送了消息Hello World:2147483646我是生产者，我发送了消息Hello World:2147483645我是生产者，我发送了消息Hello World:2147483644我是生产者，我发送了消息Hello World:2147483643我是生产者，我发送了消息Hello World:2147483642.... MavenDemo控制台输出：123456I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483647&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=1, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483644&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=2, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483641&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=3, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483638&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=4, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483635&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=5, messageCount=0])...... 这时我们再来看下另外一个的用tomcat直接发布的项目，控制台输出:1234567I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483626&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=8, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483623&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=9, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483620&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=10, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483617&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=11, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483614&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=12, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483611&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=13, messageCount=0])..... 测试通过，以上就是使用RabbitMQ与Spring整合并测试通过的全部流程。 项目地址：https://github.com/mhkzh/SSM 个人博客地址：http://zhfeat.cc GitHub地址：https://github.com/mhkzh/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring事务配置声明式事务管理和基于注解的使用]]></title>
      <url>%2Fblog%2F2017%2F03%2F08%2Fspring%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%92%8C%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。 Spring编程式事务管理和声明式事务管理spring支持编程式事务管理和声明式事务管理两种方式。 编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。 声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。 显然声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要加上注解就可以获得完全的事务支持。和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。 声明式事务管理也有两种常用的方式，一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用，更清爽。 spring事务特性spring所有的事务管理策略类都继承自org.springframework.transaction.PlatformTransactionManager接口 其中TransactionDefinition接口定义以下特性： 事务隔离级别隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATIONREADCOMMITTED。 TransactionDefinition.ISOLATIONREADUNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。 TransactionDefinition.ISOLATIONREADCOMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 TransactionDefinition.ISOLATIONREPEATABLEREAD：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。 TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 事务传播行为所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量： TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。 TransactionDefinition.PROPAGATIONREQUIRESNEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 TransactionDefinition.PROPAGATIONNOTSUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。 TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 TransactionDefinition.PROPAGATIONNESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATIONREQUIRED。 事务超时所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。 默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是none，没有超时限制。 事务只读属性只读事务用于客户代码只读但不修改数据的情形，只读事务用于特定情景下的优化，比如使用Hibernate的时候。 默认为读写事务。 “只读事务”并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。但是你非要在“只读事务”里面修改数据，也并非不可以，只不过对于数据一致性的保护不像“读写事务”那样保险而已。因此，“只读事务”仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可。 spring事务回滚规则指示spring事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常。spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务。 默认配置下，spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。可以明确的配置在抛出那些异常时回滚事务，包括checked异常。也可以明确定义那些异常抛出时不回滚事务。还可以编程性的通过setRollbackOnly()方法来指示一个事务必须回滚，在调用完setRollbackOnly()后你所能执行的唯一操作就是回滚。 基于注解的声明式事务管理配置@Transactional以下配置基于本博客SSM框架整合系列所搭建的框架 spring-mybatis.xml123456789101112131415161718 &lt;!-- (事务管理) 配置spring的PlatformTransactionManager，名字为默认值 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 事物切面配置 --&gt; &lt;tx:advice id="advice" transaction-manager="transactionManager" &gt; &lt;tx:attributes&gt; &lt;tx:method name="update*" propagation="REQUIRED" read-only="false" rollback-for="java.lang.Exception"/&gt; &lt;tx:method name="insert" propagation="REQUIRED" read-only="false" rollback-for="java.lang.Exception"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 事务拦截器，拦截com.zh.service下所有方法 --&gt;&lt;aop:config&gt; &lt;aop:pointcut id="testService" expression="execution (* com.zh.service.*.*(..))"/&gt; &lt;aop:advisor advice-ref="advice" pointcut-ref="testService"/&gt; &lt;/aop:config&gt; 添加tx名字空间12345678910111213141516171819202122&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd "&gt; MyBatis自动参与到spring事务管理中，无需额外配置，只要org.mybatis.spring.SqlSessionFactoryBean引用的数据源与DataSourceTransactionManager引用的数据源一致即可，否则事务管理会不起作用。 @Transactional注解@Transactional属性 属性 类型 描述 value String 可选的限定描述符，指定使用的事务管理器 propagation enum: Propagation 可选的事务传播行为设置 isolation enum: Isolation 可选的事务隔离级别设置 readOnly boolean 读写或只读事务，默认读写 timeout int (in seconds granularity) 事务超时时间设置 rollbackFor Class对象数组，必须继承自Throwable 导致事务回滚的异常类数组 rollbackForClassName 类名数组，必须继承自Throwable 导致事务回滚的异常类名字数组 noRollbackFor Class对象数组，必须继承自Throwable 不会导致事务回滚的异常类数组 noRollbackForClassName 类名数组，必须继承自Throwable 不会导致事务回滚的异常类名字数组 用法@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。 虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。 默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。 例子（不以本项目举例，我的源码中有单元测试，可以自己自己体验一下）： 123456789@Autowired private MyBatisDao dao; @Transactional @Override public void insert(Test test) &#123; dao.insert(test); throw new RuntimeException("test");//抛出unchecked异常，触发事物，回滚 &#125; noRollbackFor 1234567@Transactional(noRollbackFor=RuntimeException.class) @Override public void insert(Test test) &#123; dao.insert(test); //抛出unchecked异常，触发事物，noRollbackFor=RuntimeException.class,不回滚 throw new RuntimeException("test"); &#125; 类，当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性 12345678910111213@Transactional public class MyBatisServiceImpl implements MyBatisService &#123; @Autowired private MyBatisDao dao; @Override public void insert(Test test) &#123; dao.insert(test); //抛出unchecked异常，触发事物，回滚 throw new RuntimeException("test"); &#125; propagation=Propagation.NOT_SUPPORTED123456@Transactional(propagation=Propagation.NOT_SUPPORTED) @Override public void insert(Test test) &#123; //事物传播行为是PROPAGATION_NOT_SUPPORTED，以非事务方式运行，不会存入数据库 dao.insert(test); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单切换数据源]]></title>
      <url>%2Fblog%2F2017%2F03%2F08%2F%E7%AE%80%E5%8D%95%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
      <content type="text"><![CDATA[在现在开发的过程中应该大多数朋友都有遇到过切换数据源的需求。比如现在常用的数据库读写分离，或者就是有两个数据库的情况，这些都需要用到切换数据源。 手动切换数据源源码剖析使用Spring的AbstractRoutingDataSource类来进行拓展多数据源。 该类就相当于一个dataSource的路由，用于根据key值来进行切换对应的dataSource。 下面简单来看下AbstractRoutingDataSource类的几段关键源码： 123456789101112131415161718192021222324252627282930313233343536@Overridepublic Connection getConnection() throws SQLException &#123; return determineTargetDataSource().getConnection();&#125;@Overridepublic Connection getConnection(String username, String password) throws SQLException &#123; return determineTargetDataSource().getConnection(username, password);&#125;/** * Retrieve the current target DataSource. Determines the * &#123;@link #determineCurrentLookupKey() current lookup key&#125;, performs * a lookup in the &#123;@link #setTargetDataSources targetDataSources&#125; map, * falls back to the specified * &#123;@link #setDefaultTargetDataSource default target DataSource&#125; if necessary. * @see #determineCurrentLookupKey() */protected DataSource determineTargetDataSource() &#123; Assert.notNull(this.resolvedDataSources, "DataSource router not initialized"); Object lookupKey = determineCurrentLookupKey(); DataSource dataSource = this.resolvedDataSources.get(lookupKey); if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) &#123; dataSource = this.resolvedDefaultDataSource; &#125; if (dataSource == null) &#123; throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]"); &#125; return dataSource;&#125;/** * Determine the current lookup key. This will typically be * implemented to check a thread-bound transaction context. * &lt;p&gt;Allows for arbitrary keys. The returned key needs * to match the stored lookup key type, as resolved by the * &#123;@link #resolveSpecifiedLookupKey&#125; method. */protected abstract Object determineCurrentLookupKey(); 可以看到其中获取链接的方法getConnection()调用的determineTargetDataSource则是关键方法。该方法用于返回我们使用的数据源。 其中呢又是determineCurrentLookupKey()方法来返回当前数据源的key值。之后通过该key值在resolvedDataSources这个map中找到对应的value(该value就是数据源)。 resolvedDataSources这个map则是在： 123456789101112131415@Overridepublic void afterPropertiesSet() &#123; if (this.targetDataSources == null) &#123; throw new IllegalArgumentException("Property 'targetDataSources' is required"); &#125; this.resolvedDataSources = new HashMap&lt;Object, DataSource&gt;(this.targetDataSources.size()); for (Map.Entry&lt;Object, Object&gt; entry : this.targetDataSources.entrySet()) &#123; Object lookupKey = resolveSpecifiedLookupKey(entry.getKey()); DataSource dataSource = resolveSpecifiedDataSource(entry.getValue()); this.resolvedDataSources.put(lookupKey, dataSource); &#125; if (this.defaultTargetDataSource != null) &#123; this.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource); &#125;&#125; 这个方法通过targetDataSources这个map来进行赋值的。targetDataSources则是我们在配置文件中进行赋值的，下面会讲到。 再来看看determineCurrentLookupKey()方法，从protected来修饰就可以看出是需要我们来进行重写的。 DynamicDataSource 和 DataSourceHolder于是我新增了DynamicDataSource类，代码如下： 12345678910111213141516package com.zh.util;import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;public class DynamicDataSource extends AbstractRoutingDataSource&#123; /** 使用Spring的AbstractRoutingDataSource类来进行拓展多数据源。 该类就相当于一个dataSource的路由，用于根据key值来进行切换对应的dataSource。 **/ @Override protected Object determineCurrentLookupKey() &#123; return DataSourceHolder.getDataSources(); &#125;&#125; 代码很简单，继承了AbstractRoutingDataSource类并重写了其中的determineCurrentLookupKey()方法。 这里直接用DataSourceHolder返回了一个数据源。 DataSourceHolder代码如下： 123456789101112131415161718package com.zh.util;/** * 数据源 * @author zh * */public class DataSourceHolder &#123; //这里我使用了ThreadLocal来保存了数据源，提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。 private static final ThreadLocal&lt;String&gt; dataSources = new ThreadLocal&lt;String&gt;(); public static void setDataSources(String dataSource) &#123; dataSources.set(dataSource); &#125; public static String getDataSources() &#123; return dataSources.get(); &#125;&#125; 这里我使用了ThreadLocal来保存了数据源，关于ThreadLocal的知识点可以查看以下这篇文章解密ThreadLocal 之后在Spring的配置文件中配置我们的数据源，就是上文讲到的为targetDataSources赋值：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 &lt;!-- 数据源1 --&gt; &lt;bean id="ssmdataSource1" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;url1&#125;" /&gt; &lt;property name="username" value="$&#123;username1&#125;" /&gt; &lt;property name="password" value="$&#123;password1&#125;" /&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;" /&gt; &lt;property name="filters" value="$&#123;filters&#125;" /&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;" /&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;" /&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;" /&gt; &lt;!-- 用来检测连接是否有效的sql，要求是一个查询语句。 --&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;" /&gt; &lt;!-- 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。 --&gt; &lt;property name="testWhileIdle" value="$&#123;testWhileIdle&#125;" /&gt; &lt;!-- 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 --&gt; &lt;property name="testOnBorrow" value="$&#123;testOnBorrow&#125;" /&gt; &lt;!-- 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 --&gt; &lt;property name="testOnReturn" value="$&#123;testOnReturn&#125;" /&gt; &lt;!-- 要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100 --&gt; &lt;property name="maxOpenPreparedStatements" value="$&#123;maxOpenPreparedStatements&#125;" /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;" /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;" /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name="logAbandoned" value="$&#123;logAbandoned&#125;" /&gt; &lt;/bean&gt; &lt;!-- 数据源2 --&gt; &lt;bean id="ssmdataSource2" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;url2&#125;" /&gt; &lt;property name="username" value="$&#123;username2&#125;" /&gt; &lt;property name="password" value="$&#123;password2&#125;" /&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;" /&gt; &lt;property name="filters" value="$&#123;filters&#125;" /&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;" /&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;" /&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;" /&gt; &lt;!-- 用来检测连接是否有效的sql，要求是一个查询语句。 --&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;" /&gt; &lt;!-- 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。 --&gt; &lt;property name="testWhileIdle" value="$&#123;testWhileIdle&#125;" /&gt; &lt;!-- 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 --&gt; &lt;property name="testOnBorrow" value="$&#123;testOnBorrow&#125;" /&gt; &lt;!-- 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 --&gt; &lt;property name="testOnReturn" value="$&#123;testOnReturn&#125;" /&gt; &lt;!-- 要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100 --&gt; &lt;property name="maxOpenPreparedStatements" value="$&#123;maxOpenPreparedStatements&#125;" /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;" /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;" /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name="logAbandoned" value="$&#123;logAbandoned&#125;" /&gt; &lt;/bean&gt; 这里分别配置了两个数据源：ssmdataSource1和ssmdataSource2。之后再通过Spring的依赖注入方式将两个数据源设置进targetDataSources。1234567891011&lt;!-- Spring的依赖注入方式将两个数据源设置进targetDataSources。 --&gt;&lt;bean id="dataSource" class="com.zh.util.DynamicDataSource"&gt; &lt;property name="targetDataSources"&gt; &lt;map key-type="java.lang.String"&gt; &lt;entry key="sss1" value-ref="ssmdataSource1"/&gt; &lt;entry key="sss2" value-ref="ssmdataSource2"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--默认数据源--&gt; &lt;property name="defaultTargetDataSource" ref="ssmdataSource1"/&gt; &lt;/bean&gt; 接下来就是在每次调用数据库之前我们都要先通过DataSourceHolder来设置当前的数据源。看下demo： 123456 @Testpublic void selectByPrimaryKey() throws Exception &#123; DataSourceHolder.setDataSources(Constants.DATASOURCE_ONE); User user = userService.getUserByIdTest(1); System.out.println(user.getUserName());&#125; 这样在查询数据库之前，用setDataSources根据key设置了数据源，那么就会以该数据源操作数据库，如果不设置，就会以我们设置的默认数据源来操作数据库。 动态切换数据源使用动态获取数据源的思路是，使用AOP切面，在进入我们的方法前根据我们的包名对我们要查询的数据源进行判断,从而达到动态切换数据源的目的。 Spring中的事务是通过aop来实现的，当我们自己写aop拦截的时候，会遇到跟spring的事务aop执行的先后顺序问题，比如说动态切换数据源的问题，如果事务在前，数据源切换在后，会导致数据源切换失效，所以就用到了Order（排序）这个关键字。 在这个地方遇到了几个异常，导致aop切面无法正常拦截，目前手动切换数据源的方式暂且够用，后续会补上具体的开发步骤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSONP跨域传输]]></title>
      <url>%2Fblog%2F2017%2F03%2F07%2FJSONP%E8%B7%A8%E5%9F%9F%E4%BC%A0%E8%BE%93%2F</url>
      <content type="text"><![CDATA[什么是跨域问题？只要协议、域名、端口有任何一个不同，都被当作是不同的域 只要是在不同域中是无法进行通信的。 基于以上的的出发点，我们又有跨域共享资源的需求(譬如现在流行的前后端分离之后分别部署的情况)，本博客中采用的办法是JSONP。 JSONP其实网上关于JSONP的讲解有很多，但却千篇一律，而且云里雾里，对于很多刚接触的人来讲理解起来有些困难，小可不才，试着用自己的方式来阐释一下这个问题，看看是否有帮助。 一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准； 不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如script、img、iframe等html标记）； 于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理； 恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据； 这样子解决方案就呼之欲出了，web客户端通过与调用脚本(script)一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。 客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 web端(这里我直接在本地创建了一个html): 1234567891011121314151617181920212223242526272829&lt;html lang="zh"&gt;&lt;head&gt; &lt;script src="https://code.jquery.com/jquery-3.1.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(document).ready(function()&#123; $.ajax(&#123; type: "get", async: false, url: "http://localhost:8000/user/jsonpInfo?callback=getUser&amp;userId=1", dataType: "jsonp", jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(//一般默认为:callback) jsonpCallback:"getUser",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据 success: function(json)&#123; /** * 获得服务器返回的信息。 * 可以做具体的业务处理。 */ alert('用户信息：ID： ' + json.id + ' ，姓名： ' + json.userName + '。'); &#125;, error: function()&#123; alert('fail'); &#125; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body oncontextmenu="return false"&gt;&lt;/body&gt;&lt;/html&gt; jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用。 服务端代码： 12345678//跨域问题@RequestMapping(value = "/jsonpInfo",method = &#123; RequestMethod.GET &#125;)@ResponseBodypublic Object jsonpInfo(String callback,Integer userId) throws IOException &#123; User user = userService.getUserByIdTest(userId); JSONPObject jsonpObject = new JSONPObject(callback,user) ; return jsonpObject ;&#125; 后端采用了jackson中的JSONPObject这个类的一个构造方法，只需要将callback字段和需要转成JSON字符串的对象放进去即可。需要主要的是需要使用@ResponseBody注解才能成功返回。 直接打开html进行测试 如上如所示，成功调用服务端返回了数据 使用谷歌进行调试，查看返回的json数据： 可以看到我们所传递的callback参数带着查询的数据又原封不动的返回给我们了，这样的话即使我们不使用JQuery给我封装好的函数，我们自定义一个和callback名称一样的函数一样是可以解析其中的数据的，只是Jquery帮我们做了而已。 总结 ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装； 但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加script标签来调用服务器提供的js脚本。 所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变这一点！ 同样JSONP也是有缺点的，比如：只支持GET方式的HTTP请求。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebServie集成]]></title>
      <url>%2Fblog%2F2017%2F03%2F07%2FWebServie%E9%9B%86%E6%88%90%2F</url>
      <content type="text"><![CDATA[WebService到底是什么？ 一言以蔽之：WebService是一种跨编程语言和跨操作系统平台的远程调用技术。 所谓跨编程语言和跨操作平台，就是说服务端程序采用java编写，客户端程序则可以采用其他编程语言编写，反之亦然！跨操作系统平台则是指服务端程序和客户端程序可以在不同的操作系统上运行。 所谓远程调用，就是一台计算机a上的一个程序可以调用到另外一台计算机b上的一个对象的方法，譬如，银联提供给商场的pos刷卡系统，商场的POS机转账调用的转账方法的代码其实是跑在银行服务器上。再比如，amazon，天气预报系统，淘宝网，校内网，百度等把自己的系统服务以webservice服务的形式暴露出来，让第三方网站和程序可以调用这些服务功能，这样扩展了自己系统的市场占有率，往大的概念上吹，就是所谓的SOA应用。 其实可以从多个角度来理解WebService，从表面上看，WebService就是一个应用程序向外界暴露出一个能通过Web进行调用的API，也就是说能用编程的方法通过Web来调用这个应用程序。我们把调用这个WebService的应用程序叫做客户端，而把提供这个WebService的应用程序叫做服务端。从深层次看，WebService是建立可互操作的分布式应用程序的新平台，是一个平台，是一套标准。它定义了应用程序如何在Web上实现互操作性，你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service ，只要我们可以通过Web service标准对这些服务进行查询和访问。 WebService平台技术 XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术。 XML+XSD： WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务对象的返回结果是什么）。XML是WebService平台中表示数据的格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关的。无关性是比技术优越性更重要的：软件厂商是不会选择一个由竞争对手所发明的技术的。 XML解决了数据表示的问题，但它没有定义一套标准的数据类型，更没有说怎么去扩展这套数据类型。例如，整形数到底代表什么？16位，32位，64位？这些细节对实现互操作性很重要。XML Schema(XSD)就是专门解决这个问题的一套标准。它定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。WebService平台就是用XSD来作为其数据类型系统的。当你用某种语言(如VB.NET或C#)来构造一个Web service时，为了符合WebService标准，所有你使用的数据类型都必须被转换为XSD类型。你用的工具可能已经自动帮你完成了这个转换，但你很可能会根据你的需要修改一下转换过程。 SOAP： WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议。SOAP提供了标准的RPC方法来调用Web Service。 SOAP协议 = HTTP协议 + XML数据格式 SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。打个比喻：HTTP就是普通公路，XML就是中间的绿色隔离带和两边的防护栏，SOAP就是普通公路经过加隔离带和防护栏改造过的高速公路。 WSDL： 好比我们去商店买东西，首先要知道商店里有什么东西可买，然后再来购买，商家的做法就是张贴广告海报。 WebService也一样，WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。 WSDL(Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。它是WebService客户端和服务器端都能理解的标准格式。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。一些最新的开发工具既能根据你的Web service生成WSDL文档，又能导入WSDL文档，生成调用相应WebService的代理类代码。 WSDL文件保存在Web服务器上，通过一个url地址就可以访问到它。客户端要调用一个WebService服务之前，要知道该服务的WSDL文件的地址。WebService服务提供商可以通过两种方式来暴露它的WSDL文件地址：1.注册到UDDI服务器，以便被人查找；2.直接告诉给客户端调用者。 WebService开发WebService开发可以分为服务器端开发和客户端开发两个方面： 服务端开发：把公司内部系统的业务方法发布成WebService服务，供远程合作单位和个人调用。(借助一些WebService框 架可以很轻松地把自己的业务对象发布成WebService服务，Java方面的典型WebService框架包括：axis，xfire，cxf等，java ee服务器通常也支持发布WebService服务，例如JBoss。) 客户端开发：调用别人发布的WebService服务，大多数人从事的开发都属于这个方面，例如，调用天气预报WebService服务。（使用厂商的WSDL2Java之类的工具生成静态调用的代理类代码；使用厂商提供的客户端编程API类；使用SUN公司早期标准的jax-rpc开发包；使用SUN公司最新标准的jax-ws开发包。当然SUN已被ORACLE收购) WebService的工作调用原理：对客户端而言，我们给这各类WebService客户端API传递wsdl文件的url地址，这些API就会创建出底层的代理类，我调用这些代理，就可以访问到webservice服务。代理类把客户端的方法调用变成soap格式的请求数据再通过HTTP协议发出去，并把接收到的soap数据变成返回值返回。对服务端而言，各类WebService框架的本质就是一个大大的Servlet，当远程调用客户端给它通过http协议发送过来soap格式的请求数据时，它分析这个数据，就知道要调用哪个java类的哪个方法，于是去查找或创建这个对象，并调用其方法，再把方法返回的结果包装成soap格式的数据，通过http响应消息回给客户端。 WebService框架1、Axis2是Apache下的一个重量级WebService框架，准确说它是一个Web Services / SOAP / WSDL 的引擎，是WebService框架的集大成者，它能不但能制作和发布WebService，而且可以生成Java和其他语言版WebService客户端和服务端代码。这是它的优势所在。但是，这也不可避免的导致了Axis2的复杂性，使用过的开发者都知道，它所依赖的包数量和大小都是很惊人的，打包部署发布都比较麻烦，不能很好的与现有应用整合为一体。但是如果你要开发Java之外别的语言客户端，Axis2提供的丰富工具将是你不二的选择。 2、XFire是一个高性能的WebService框架，在Java6之前，它的知名度甚至超过了Apache的Axis2，XFire的优点是开发方便，与现有的Web整合很好，可以融为一体，并且开发也很方便。但是对Java之外的语言，没有提供相关的代码工具。XFire后来被Apache收购了，原因是它太优秀了，收购后，随着Java6 JWS的兴起，开源的WebService引擎已经不再被看好，渐渐的都败落了。 3、CXF是Apache旗下一个重磅的SOA简易框架，它实现了ESB（企业服务总线）。CXF来自于XFire项目，经过改造后形成的，就像目前的Struts2来自WebWork一样。可以看出XFire的命运会和WebWork的命运一样，最终会淡出人们的视线。CXF不但是一个优秀的Web Services / SOAP / WSDL 引擎，也是一个不错的ESB总线，为SOA的实施提供了一种选择方案，当然他不是最好的，它仅仅实现了SOA架构的一部分。 Http接口和WebService接口的区别什么是web service？ soap请求是HTTP POST的一个专用版本，遵循一种特殊的xml消息格式Content-type设置为: text/xml任何数据都可以xml化。 为什么要学习web service？ 大多数对外接口会实现web service方法而不是http方法，如果你不会，那就没有办法对接。 web service相对http (post/get)有好处吗？ 1.接口中实现的方法和要求参数一目了然 2.不用担心大小写问题 3.不用担心中文urlencode问题 4.代码中不用多次声明认证(账号,密码)参数 5.传递参数可以为数组，对象等… web service相对http（post/get）快吗？ 由于要进行xml解析，速度可能会有所降低。 web service 可以被http（post/get）替代吗？ 完全可以，而且现在的开放平台都是用的HTTP（post/get）实现的。 如何通俗的解释什么是CxfCXF的目的是为了开发web service，web service是SOAP的具体实现，web service的一个主要作用是解决不同语言通信的问题。举个例子，现在iteye不是希望和csdn整合吗(iteye用的ruby语言，csdn用的asp.net)，你看iteye上的通告，以后可以用csdn帐号登录了。那么这个登录系统肯定是在iteye下的，但是帐号密码一定要发送给csdn验证，ruby怎么把帐号密码发给asp.net？不同语言怎么识别？这里就用到web service了，因为web service是一个统一标准，asp.net可以定义一个登录验证的web service接口，提供一个checkLogin方法，参数是传入帐号密码，具体实现是asp.net内部的事，如果验证成功则返回true即可：public bool checkLogin(string loginCode,string password); 因为web service本身规则比较多，为了减少我们程序员的负担，往往会有一些框架来实现web service，比如java的CXF，.net也会有自己的框架，最后web service编写成功后通过部署到服务器，ruby就可以通过web service的形式调用asp.net代码了，这样就实现了不同语言的通信。 Spring整合CXF在Java中实现webservice有多种方法，java本身在jdk1.7之后也对webservice有了默认的实现，但是在我们实际开发中一般还是会使用框架来，比如这里所提到的CXF就有着广泛的应用。以下配置依然依赖于之前那篇SSM框架整合的博客所搭建的框架。 pom.xml配置添加Mava依赖(这里我统一使用了3.0.0版本。使用高版本如3.1.6版本会出现异常，初步判定是因为jar包引起了冲突，目前还没有排查出具体的原因)： 1234567891011121314151617 &lt;!--cxf CXF是apache旗下的开源框架，由Celtix + XFire这两门经典的框架合成，是一套非常流行的web service框架。 start--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-core&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; &lt;!--cxf end--&gt; web.xml配置接着我们需要配置一个CXF的servlet： 123456789&lt;!--定义一个cxf的servlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/webservice/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 之后只要我们访问webservice/*这个地址就会进入CXF的servlet中。 整合Spring配置接下来是最重要的一部，用Spring整合CXF： 在这之前我有新建一个CXF的包，如下图： 这里有两个主要类 HelloWorld接口。 实现HelloWorld接口的HelloWorldImpl类。 代码如下：HelloWorld.java 12345678package com.zh.cxf;import javax.jws.WebService;@WebServicepublic interface HelloWorld &#123; public String say(String str);&#125; 其中就只定义了一个简单的say()方法。 HelloWorldImpl.java 1234567891011package com.crossoverJie.cxf.impl;import com.crossoverJie.cxf.HelloWorld;import org.springframework.stereotype.Component;import javax.jws.WebService;@Component("helloWorld")@WebServicepublic class HelloWorldImpl implements HelloWorld &#123; public String say(String str) &#123; return "Hello"+str; &#125;&#125; 这里就是对say()方法的简单实现。 接下来就是整合Spring了，由于需要使用到CXF的标签，所以我们需要添加额外的命名路径如下： 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd "&gt; &lt;!-- cxf整合Spring start--&gt; &lt;import resource="classpath:META-INF/cxf/cxf.xml"/&gt; &lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml"/&gt; &lt;!-- 自动扫描webService --&gt; &lt;context:component-scan base-package="com.zh.cxf" /&gt; &lt;!-- 定义webservice的发布接口 --&gt; &lt;jaxws:endpoint implementor="#helloWorld" address="/HelloWorld"&gt; &lt;/jaxws:endpoint&gt; &lt;!--cxf整合Spring end --&gt; 更加具体的配置可以查看官方给出的文档:传送门 #helloWorld指的是我们在HelloWorldImpl类中所自定义的名字，/HelloWorld则是我们需要访问的地址。之后我们运行项目输入该地址：http://127.0.0.1:8000/webservice/HelloWorld?wsdl如果出现如下界面： 则说明我们的webservice发布成功了。 客户端调用webservice接口客户端调用cxf webservice接口时可以分为静态调用和动态调用。 他们的区别：静态调用需要依赖service类，因为客户端调用cxf webservice接口的过程中需要服务器端提供service，很不方便，如果同一个项目中则没有区别。动态调用完全不依赖service类，服务器端只要提供接口名和路径就可以方便的调用。 静态调用代码：1234567891011121314151617181920212223242526272829package com.zh.cxf;import org.apache.cxf.interceptor.LoggingInInterceptor;import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;public class WebServiceUtil &#123; public static void main(String[] args) &#123; /**静态调用**/ // 创建WebService客户端代理工厂 JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean(); // 判断是否抛出异常 factory.getOutInterceptors().add(new LoggingInInterceptor()); // 注册webservice接口 factory.setServiceClass(HelloWorld.class); // 配置webservice地址 factory.setAddress("http://127.0.0.1:8000/webservice/HelloWorld?wsdl"); // 获得接口对象 HelloWorld service = (HelloWorld) factory.create(); // 调用接口方法 String result = service.say("111"); System.out.println("调用结果:" + result); // 关闭接口连接 System.exit(0); &#125; &#125; 启动项目服务，执行后控制台输出结果：1234log4j:WARN No appenders could be found for logger (org.apache.cxf.common.logging.LogUtils).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.调用结果:Hello111 动态调用代码： 1234567891011121314151617181920212223242526272829303132package com.zh.cxf;import javax.xml.namespace.QName;import org.apache.cxf.jaxws.endpoint.dynamic.JaxWsDynamicClientFactory;public class WebServiceUtil &#123; /**区别：静态调用需要依赖service类，因为客户端调用cxf webservice接口的过程中需要服务器端提供service，很不方便，如果同一个项目中则没有区别。 动态调用完全不依赖service类，服务器端只要提供接口名和路径就可以方便的调用。**/ public static void main(String[] args) &#123; /**动态调用**/ JaxWsDynamicClientFactory dcf = JaxWsDynamicClientFactory.newInstance(); org.apache.cxf.endpoint.Client client = dcf .createClient("http://127.0.0.1:8000/webservice/HelloWorld?wsdl"); // url为调用webService的wsdl地址 QName name = new QName("http://cxf.zh.com/", "say"); // namespace是命名空间，methodName是方法名 String xmlStr = "aaaaaaaa"; // paramvalue为参数值 Object[] objects; try &#123; objects = client.invoke(name, xmlStr); System.out.println(objects[0].toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 启动项目服务，执行后控制台输出结果： 1234log4j:WARN No appenders could be found for logger (org.apache.cxf.common.logging.LogUtils).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.Helloaaaaaaaa 总结以上是我总结的比较简单的一篇webService入门博客，从概念、原理、应用场景到实际的配置、调用、测试。是对自己所学知识的一次梳理，同时也希望对大家以后的面试、工作能有一些帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shiro安全框架集成]]></title>
      <url>%2Fblog%2F2017%2F03%2F03%2FShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90%2F</url>
      <content type="text"><![CDATA[做企业级开发必须要了解权限和安全相关的开发知识，之前的一个项目我采用的是建立用户表、角色表、权限表、用户角色表、角色权限表五张经典表。之后使用自定义注解+拦截器的方式，在拦截器中对每一个请求进行拦截，再到SESSION或者数据库中进行查询，判断当前用户是否有该权限，这样的设计能满足大多数中小型系统的需求。本文介绍的Shiro既能满足之前的所有需求，安全性高，不跟任何的框架或者容器捆绑，可以独立运行。对比SpringSecurity安全框架使用相对简单，易于理解。而且现在越来越的多企业都在使用Shiro，值得在项目中引用尝试。 本篇博客的框架搭建请参考我之前的文章《SSM框架整合Maven+Spring+SpringMVC+MyBatis》 在项目中添加依赖pom.xml 12345678910111213141516171819&lt;!-- Apache Shiro --&gt;&lt;!-- shiro 核心包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- shiro Web相关包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring 整合shiro需要的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt; 配置shiro过滤器web.xml 该filter最好放在字符编码filter下面: 123456789101112131415 &lt;!-- shiro过滤器定义 --&gt;&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;!-- 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 --&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;!-- 拦截所有请求 --&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 这样会过滤所有的请求。 创建自定义MyRealm类逻辑与表结构首先在使用Shiro的时候我们要考虑在什么样的环境下使用： 登录的验证 对指定角色的验证 对URL的验证 在本篇博客中，我们需要这三个方法： findUserByUserName(String username)根据username查询用户，之后Shiro会根据查询出来的User的密码来和提交上来的密码进行比对。 findRoles(String username)根据username查询该用户的所有角色，用于角色验证。 findPermissions(String username)根据username查询他所拥有的权限信息，用于权限判断。 由于本篇博客着重讲解shiro的配置和使用，在实际开发工作中，最好建立五张表，用户表、角色表、权限表、用户角色中间表、角色权限中间表，拓展性更强。 通过中间表来配置用户与角色的对应关系，角色与权限的对应关系，更灵活。 大概流程为：验证通过后，通过用户名从用户表中查询用户ID，根据用户ID从用户角色中间表中查询该用户所对应的所有角色ID，通过所有角色ID从角色权限中间表中查询各个角色都含有哪些权限，并进行权限的去重操作。 我的ShiroUserMapper.xml代码(Mybatis自动构建请参考我之前的文章SSM整合，可以节省掉很大一部分写重复代码的时间)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.zh.dao.ShiroUserMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.zh.model.ShiroUser" &gt; &lt;id column="id" property="id" jdbcType="INTEGER" /&gt; &lt;result column="userName" property="username" jdbcType="VARCHAR" /&gt; &lt;result column="roleId" property="roleid" jdbcType="INTEGER" /&gt; &lt;result column="password" property="password" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, userName, roleId, password &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from t_user where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from t_user where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.zh.model.ShiroUser" &gt; insert into t_user (id, userName, roleId, password) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;roleid,jdbcType=INTEGER&#125;, #&#123;password,jdbcType=VARCHAR&#125;) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.zh.model.ShiroUser" &gt; insert into t_user &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; id, &lt;/if&gt; &lt;if test="username != null" &gt; userName, &lt;/if&gt; &lt;if test="roleid != null" &gt; roleId, &lt;/if&gt; &lt;if test="password != null" &gt; password, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="username != null" &gt; #&#123;username,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="roleid != null" &gt; #&#123;roleid,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.zh.model.ShiroUser" &gt; update t_user &lt;set &gt; &lt;if test="username != null" &gt; userName = #&#123;username,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="roleid != null" &gt; roleId = #&#123;roleid,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.zh.model.ShiroUser" &gt; update t_user set userName = #&#123;username,jdbcType=VARCHAR&#125;, roleId = #&#123;roleid,jdbcType=INTEGER&#125;, password = #&#123;password,jdbcType=VARCHAR&#125; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;select id="findUserByUsername" parameterType="String" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List"/&gt; from t_user where userName=#&#123;userName&#125; &lt;/select&gt; &lt;select id="findRoles" parameterType="String" resultType="String"&gt; select r.roleName from t_user u,t_role r where u.roleId=r.id and u.userName=#&#123;userName&#125; &lt;/select&gt; &lt;select id="findPermissions" parameterType="String" resultType="String"&gt; select p.permissionName from t_user u,t_role r,t_permission p where u.roleId=r.id and p.roleId=r.id and u.userName=#&#123;userName&#125; &lt;/select&gt; &lt;/mapper&gt; 以上提到的三个方法，分别对应xml文件中最下面的三个方法。 所需的表结构(包含后面要用的测试数据)： MyRealm类创建自定义的MyRealm类，这个还是比较重要的。继承至Shiro的AuthorizingRealm类，用于处理自己的验证逻辑，下面贴一下我的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.zh.shiro;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import com.zh.model.ShiroUser;import com.zh.service.ShiroUserService;import javax.annotation.Resource;import java.util.Set;/** * Shiro自定义域 */public class MyRealm extends AuthorizingRealm &#123; @Resource private ShiroUserService t_userService; /** * 用于的权限的认证。 * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; String username = principalCollection.getPrimaryPrincipal().toString() ; SimpleAuthorizationInfo info = new SimpleAuthorizationInfo() ; //根据用户名获取角色名称 Set&lt;String&gt; roleName = t_userService.findRoles(username) ; //获取角色所对应的权限名称 Set&lt;String&gt; permissions = t_userService.findPermissions(username) ; info.setRoles(roleName); info.setStringPermissions(permissions); return info; &#125; /** * 首先执行这个登录验证 * @param token * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //获取用户账号 String username = token.getPrincipal().toString(); ShiroUser user = t_userService.findUserByUsername(username); if (user != null)&#123; //这里将查询出的用户名密码与用户输入的进行匹配，并存放到 authenticationInfo用于后面的权限判断。第三个参数随便放一个就行了。 AuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(user.getUsername(),user.getPassword(), "a") ; return authenticationInfo ; &#125;else&#123; return null ; &#125; &#125;&#125; 继承AuthorizingRealm类之后就需要覆写它的两个方法： doGetAuthorizationInfo (登录验证) 和 doGetAuthenticationInfo (用户权限的认证) doGetAuthenticationInfo是用于登录验证的，在请求controller层进行登录的时候需要将数据封装到Shiro的一个token中，执行shiro的login()方法，之后只要我们将MyRealm这个类配置到Spring中，登录的时候Shiro就会自动的调用doGetAuthenticationInfo()方法进行登录验证。 ShiroUserController.java代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zh.controller;import com.zh.model.ShiroUser;import com.zh.service.ShiroUserService;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.subject.Subject;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;/** * 后台Controller */@Controller@RequestMapping("/shiroUser")public class ShiroUserController &#123; @Resource private ShiroUserService t_userService ; @RequestMapping("/loginAdmin") public String login(ShiroUser user, Model model)&#123; Subject subject = SecurityUtils.getSubject() ; UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(),user.getPassword()) ; try &#123; subject.login(token); return "admin" ; &#125;catch (Exception e)&#123; //这里将异常打印关闭是因为如果登录失败的话会自动抛异常// e.printStackTrace(); model.addAttribute("error","用户名或密码错误") ; return "../../login" ; &#125; &#125; @RequestMapping("/admin") public String admin()&#123; return "admin"; &#125; @RequestMapping("/student") public String student()&#123; return "admin" ; &#125; @RequestMapping("/teacher") public String teacher()&#123; return "admin" ; &#125;&#125; 在请求的Controller层中，主要就是shiro的login()方法。 登录验证的时候不是直接查询数据库返回是否有用户了，而是调用subject的login()方法，调用login()方法时Shiro会自动调用我们自定义的MyRealm类中的doGetAuthenticationInfo()方法进行验证。 验证逻辑是先根据用户名从数据库中查询用户，如果查询到的话再将查询到的用户名和密码放到SimpleAuthenticationInfo对象中，Shiro会自动根据用户输入的密码和查询到的密码进行匹配，如果匹配不上就会抛出异常，匹配上之后就会执行doGetAuthorizationInfo()进行相应的权限验证。 doGetAuthorizationInfo()方法的处理逻辑也比较简单，根据用户名获取到他所拥有的角色以及权限，然后赋值到SimpleAuthorizationInfo对象中即可，Shiro就会按照我们配置的XX角色对应XX权限来进行判断，这个配置在下面的整合中会讲到。 整合Spring我是在之前的Spring SpringMVC Mybatis框架的基础上进行整合的。 spring-mybatis.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package="com.zh" /&gt; &lt;!-- 引入properties配置文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:config/jdbc.properties&lt;/value&gt; &lt;value&gt;classpath:config/redis.properties&lt;/value&gt; &lt;!--要是有多个配置文件，只需在这里继续添加即可 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- dbcp dataSource 配置 &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- druid dataSource 配置 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;" /&gt; &lt;property name="filters" value="$&#123;filters&#125;" /&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;" /&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;" /&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;" /&gt; &lt;!-- 用来检测连接是否有效的sql，要求是一个查询语句。 --&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;" /&gt; &lt;!-- 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。 --&gt; &lt;property name="testWhileIdle" value="$&#123;testWhileIdle&#125;" /&gt; &lt;!-- 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 --&gt; &lt;property name="testOnBorrow" value="$&#123;testOnBorrow&#125;" /&gt; &lt;!-- 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 --&gt; &lt;property name="testOnReturn" value="$&#123;testOnReturn&#125;" /&gt; &lt;!-- 要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100 --&gt; &lt;property name="maxOpenPreparedStatements" value="$&#123;maxOpenPreparedStatements&#125;" /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;" /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;" /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name="logAbandoned" value="$&#123;logAbandoned&#125;" /&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:com/zh/mapping/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zh.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置开始 --&gt; &lt;!-- jedis 配置 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig" &gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt; &lt;property name="maxWaitMillis" value="$&#123;redis.maxWait&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;" /&gt; &lt;/bean &gt; &lt;!-- redis服务器中心 --&gt; &lt;bean id="connectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;property name="poolConfig" ref="poolConfig" /&gt; &lt;property name="port" value="$&#123;redis.port&#125;" /&gt; &lt;property name="hostName" value="$&#123;redis.host&#125;" /&gt; &lt;!-- &lt;property name="password" value="$&#123;redis.password&#125;" /&gt; --&gt; &lt;property name="timeout" value="$&#123;redis.timeout&#125;" &gt;&lt;/property&gt; &lt;/bean &gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" &gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="keySerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="valueSerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;/bean &gt; &lt;!-- cache配置插入、更新数据时从redis中清除缓存 --&gt; &lt;bean id="putCache" class="com.zh.redis.cache.PutCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- cache配置从redis获取缓存数据 --&gt; &lt;bean id="getCache" class="com.zh.redis.cache.GetCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置结束 --&gt; &lt;!-- Shiro 开始 --&gt; &lt;!-- 配置自定义Realm --&gt; &lt;bean id="myRealm" class="com.zh.shiro.MyRealm"/&gt; &lt;!-- 安全管理器 --&gt; &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="myRealm"/&gt; &lt;/bean&gt; &lt;!-- Shiro过滤器 核心--&gt; &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;!-- Shiro的核心安全接口,这个属性是必须的 --&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;!-- 身份认证失败，则跳转到登录页面的配置 --&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;!-- 权限认证失败，则跳转到指定页面 --&gt; &lt;property name="unauthorizedUrl" value="/nopower.jsp"/&gt; &lt;!-- Shiro连接约束配置,即过滤链的定义 --&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--anon 表示匿名访问，不需要认证以及授权--&gt; /shiroUser/loginAdmin=anon &lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt; /shiroUser/admin*=authc /shiroUser/student=roles[teacher] /shiroUser/teacher=perms["user:create"] &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt; &lt;bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/&gt; &lt;!-- 开启Shiro注解 --&gt; &lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor"/&gt; &lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;/bean&gt; &lt;!-- Shiro 结束 --&gt;&lt;/beans&gt; 在这里配置了上文中自定义的myRealm,这样Shiro就可以按照我们自定义的逻辑来进行权限验证了。 着重讲解一下：12345678910&lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--anon 表示匿名访问，不需要认证以及授权--&gt; /shiroUser/loginAdmin=anon &lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt; /shiroUser/admin*=authc /shiroUser/student=roles[teacher] /shiroUser/teacher=perms["user:create"] &lt;/value&gt;&lt;/property&gt; /shiroUser/loginAdmin=anon的意思的意思是，发起/shiroUser/loginAdmin这个请求是不需要进行身份认证的，这个请求在这次项目中是一个登录请求，一般对于这样的请求都是不需要身份认证的。 /shiroUser/admin*=authc表示 /admin,/admin1,/admin2这样的请求都是需要进行身份认证的，不然是不能访问的。 /shiroUser/student=roles[teacher]表示访问/student请求的用户必须是teacher角色，不然是不能进行访问的。 /shiroUser/teacher=perms[“user:create”]表示访问/teacher请求是需要当前用户具有user:create权限才能进行访问的。 这里注意下，如果你的controller层配置了全局的@RequestMapping(“/xxxx”)，在上面进行权限配置的时候一定以这个格式进行配置(格式:/xxxx/loginAdmin=anon)，不然会拦截失效。 更多相关权限过滤的资料可以访问shiro的官方介绍：传送门 使用Shiro标签库Shiro还有着强大标签库，可以在前端帮我获取信息和做判断。我贴一下我这里登录完成之后显示的界面：1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ taglib prefix="shiro" uri="http://shiro.apache.org/tags" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;后台&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;shiro:hasRole name="admin"&gt; 这是admin角色登录：&lt;shiro:principal&gt;&lt;/shiro:principal&gt;&lt;/shiro:hasRole&gt;&lt;shiro:hasPermission name="user:create"&gt; 有user:create权限信息&lt;/shiro:hasPermission&gt;&lt;br&gt;登录成功&lt;/body&gt;&lt;/html&gt; 要想使用Shiro标签，只需要引入一下标签即可： &lt;%@ taglib prefix=”shiro” uri=”http://shiro.apache.org/tags“ %&gt; 具有admin角色才会显示标签内的信息。 获取用户信息。默认调用Subject.getPrincipal()获取，即Primary Principal。 用户拥有user:create这个权限才回显示标签内的信息。 更多的标签可以查看官网：传送门 （图片待续。。。） 首先来验证一下登录： 先输入一个错误的账号和密码： 接下来输入一个正确的： 可以看到我登录的用户是zhfeat他是有admin的角色，并且拥有user:*(ps:系统数据详见上面的数据库截图)的权限，所以在这里： 123456&lt;shiro:hasRole name="admin"&gt; 这是admin角色登录：&lt;shiro:principal&gt;&lt;/shiro:principal&gt;&lt;/shiro:hasRole&gt;&lt;shiro:hasPermission name="user:create"&gt; 有user:create权限信息&lt;/shiro:hasPermission&gt; 是能显示出标签内的信息，并把用户信息也显示出来了。 接着我们来访问一下/student这个请求，因为在Spring的配置文件中： 12345678910&lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--anon 表示匿名访问，不需要认证以及授权--&gt; /shiroUser/loginAdmin=anon &lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt; /shiroUser/admin*=authc /shiroUser/student=roles[teacher] /shiroUser/teacher=perms["user:create"] &lt;/value&gt;&lt;/property&gt; 只有teacher角色才能访问/student这个请求的： 果然，Shiro做了安全控制是不能进行访问的。 然后我们换aaa用户登录，他正好是teacher角色，看能不能访问/student。 果然是能访问的。 因为我在控制器里访问/student返回的是同一个界面所以看到的还是这个界面。 1234@RequestMapping("/teacher")public String teacher()&#123; return "admin" ;&#125; 并且没有显示之前Shiro标签内的内容。 其他的我就不测了，大家可以自己在数据库里加一些数据，或者是改下拦截的权限多试试，这样对Shiro的理解就会更加深刻。 MD5加密Shiro还封装了一个非常不错的功能，那就是MD5加密，代码如下：12345678910111213141516package com.crossoverJie.shiro;import org.apache.shiro.crypto.hash.Md5Hash;/** * Created with IDEA * 基于Shiro的MD5加密 * Created by $&#123;jie.chen&#125; on 2016/7/13. */public class MD5Util &#123; public static String md5(String str,String salt)&#123; return new Md5Hash(str,salt).toString() ; &#125; public static void main(String[] args) &#123; String md5 = md5("abc123","crossoverjie") ; System.out.println(md5); &#125;&#125; 只需要调用Md5Hash(str,salt)方法即可，这里多了一个参数，第一个参数不用多解释，是需要加密的字符串。第二个参数salt中文翻译叫盐，加密的时候我们传一个字符串进去，只要这个salt不被泄露出去，那原则上加密之后是无法被解密的，在存用户密码的时候可以使用，感觉还是非常屌的。 总结以上就是Shiro实际使用的案例，文章讲的比较初略，还需要后面自己拓展，但是关于Shiro的核心东西都在里面了，大家可以自己配一下试试，才更能体会其中的逻辑。 项目地址：https://github.com/mhkzh/SSM 个人博客地址：http://zhfeat.cc GitHub地址：https://github.com/mhkzh/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[应用Druid监控SQL语句的执行情况]]></title>
      <url>%2Fblog%2F2017%2F03%2F01%2F%E5%BA%94%E7%94%A8Druid%E7%9B%91%E6%8E%A7SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%83%85%E5%86%B5%2F</url>
      <content type="text"><![CDATA[Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource Druid是什么？ Druid是一个JDBC组件，它包括三个部分： 基于Filter－Chain模式的插件体系。 DruidDataSource 高效可管理的数据库连接池。 SQLParser(一个经典的词法分析器,可解析各种复杂的SQL语句) 官方文档地址：https://github.com/alibaba/druid/wiki/常见问题 Druid可以做什么？ 替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。 可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。 数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver和DruidDataSource都支持PasswordCallback。 SQL执行日志，Druid提供了不同的LogFilter，能够支持Common-Logging、Log4j和JdkLog，你可以按需要选择相应的LogFilter，监控你应用的数据库访问情况。 扩展JDBC，如果你要对JDBC层有编程的需求，可以通过Druid提供的Filter机制，很方便编写JDBC层的扩展插件。 Druid在项目中配置使用pom.xml中添加Druid依赖123456&lt;!-- druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.28&lt;/version&gt; &lt;/dependency&gt; jdbc.properties属性文件中配置Druid所需参数123456789101112131415161718192021222324252627282930313233343536#druid连接池配置url:jdbc:mysql://localhost:3306/maven?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8 driverClassName:com.mysql.jdbc.Driverusername:rootpassword:rootfilters:stat#最大并发连接数maxActive:20#初始化连接数量initialSize:1#配置获取连接等待超时的时间maxWait:60000#最小空闲连接数minIdle:10#最大空闲连接数maxIdle:15#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒timeBetweenEvictionRunsMillis:60000#配置一个连接在池中最小生存的时间，单位是毫秒minEvictableIdleTimeMillis:300000#用来检测连接是否有效的sql，要求是一个查询语句。 如果validationQuery为null，testOnBorrow、testOnReturn、 testWhileIdle都不会其作用。validationQuery:SELECT 'x'#建议配置为true，不影响性能，并且保证安全性。 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。testWhileIdle:true#申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。testOnBorrow:false#归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能testOnReturn:false#要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100maxOpenPreparedStatements:20#打开removeAbandoned功能removeAbandoned:true#1800秒，也就是30分钟removeAbandonedTimeout:1800#关闭abanded连接时输出错误日志logAbandoned:true web.xml中配置123456789101112131415161718192021222324252627 &lt;!-- druid start--&gt; &lt;!-- 配置sql监控 start--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;!-- 网页监控路径放在了项目路径下的 druid路径中 --&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置sql监控 end--&gt; &lt;!-- 监控jsp和do请求，exclusions参数其实可以去掉的 start --&gt;&lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 监控jsp和do请求，exclusions参数其实可以去掉的 end --&gt; &lt;!-- druid end--&gt; 查看Druid监控页面，测试效果启动项目，在浏览器输入：http://localhost:8000/druid/sql.html 下图为Druid监控主界面： 点击sql监控，调用接口，测试是否监控到了sql的各项信息 下图为DruidSQL监控功能界面： 结果：测试通过，以上为项目引入Druid连接池并启动Druid监控页面的流程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用自定义注解+AOP实现redis缓存]]></title>
      <url>%2Fblog%2F2017%2F03%2F01%2F%E5%88%A9%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%2BAOP%E5%AE%9E%E7%8E%B0redis%E7%BC%93%E5%AD%98%2F</url>
      <content type="text"><![CDATA[数据查询时每次都需要从数据库查询数据，特别是通过复杂sql查询大量数据时，数据库压力很大，查询速度很慢，因此设置缓存层，查询数据时先从redis中查询，如果查询不到，则到数据库中查询然后将数据库中查询的数据放到redis中一份，下次查询时就能直接从redis中查到，不需要查询数据库了。进行增删改操作时，先从redis中查询，如果查询出数据，则在redis中将该数据清除。 redis作为缓存的优势 内存级别缓存，查询速度毋庸置疑。 高性能的K-V存储系统，支持String，Hash，List，Set，Sorted Set等数据类型，能够应用在很多场景中。 redis3.0版本以上支持集群部署。 redis支持数据的持久化，AOF，RDB方式。 redis安装部署请参见：http://blog.csdn.net/erlian1992/article/details/54382443 实现过程 搭建ssm的框架(请参考前一篇博文) 引入redis、jedis、SpringAOP依赖包 编写redis缓存方法、jedis操作Redis以及序列化所用到的工具类。 目录结构 maven依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;!-- modelVersion 这个元素指定了POM的版本，Maven2或者Maven3都只能是4.0.0 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- groupId 是项目组的ID，一般是com.公司组织名.项目名 --&gt; &lt;groupId&gt;com.zh.mavenDemo&lt;/groupId&gt; &lt;!-- artifactId 是该项目在项目组中的ID --&gt; &lt;artifactId&gt;mavenDemo&lt;/artifactId&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- ersion 是项目的版本号，用于维护项目的升级和发布 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 一般没有实际的用处，只是用于标识该项目 --&gt; &lt;name&gt;mavenDemo Maven Webapp&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用--&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 在spring的依赖中，我们需要引用一系列版本的spring，如版本4.0.2.RELEASE，每次都写不利于维护， 所以使用properties标签来统一维护版本号，这样有利于维护，不用大量修改，引用格式 &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; --&gt; &lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;!-- slf4j入口就是众多接口的集合，它不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。 --&gt; &lt;!-- 通俗的讲，slf4j是个数据线，一端嵌入程序，另一端链接日志系统，从而实现将程序中的信息导入到日志系统并记录。 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;!-- log4j是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终日志的输出。 --&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;/properties&gt; &lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;!-- &lt;scope&gt;test&lt;/scope&gt; --&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;!-- spring核心包 --&gt; &lt;!-- 这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring对于object/xml映射的支持，可以让JAVA与XML之间来回切换 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含对Spring对JDBC数据访问进行封装的所有类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含在应用中使用Spring的AOP特性(Spring的面向切面编程)时所需的类。使用基于AOP的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop注解 start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop注解 end --&gt; &lt;!-- redies start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.6.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- redies end --&gt; &lt;!-- Spring context的扩展支持，用于MVC方面。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 对JUNIT等测试框架的简单封装 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.36&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp(数据库连接池)的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 记录日志的，封装好的一个包，通过配置文件配置，在程序中直接调用，记录需要记录的日志，一般日志保存在文件中， --&gt; &lt;!-- SLF4J作用：如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无语忍受加载和维护一个新的日志框架的痛苦。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j-log4j12是链接slf4j-api和log4j中间的适配器。它实现了slf4j-apiz中StaticLoggerBinder接口 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON java对象和json相互转化,JSON串解析--&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传组件包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--构建项目需要的信息--&gt; &lt;build&gt; &lt;finalName&gt;mavenDemo&lt;/finalName&gt; &lt;!--使用的插件列表 。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。--&gt; &lt;plugin&gt; &lt;!-- Jetty 是一个开源的servlet容器，它为基于Java的web容器，例如JSP和servlet提供运行环境。Jetty是使用Java语言编写的，它的API以一组JAR包的形式发布。开发人员可以将Jetty容器实例化成一个对象，可以迅速为一些独立运行（stand-alone）的Java应用提供网络和web连接。 --&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.2.8.v20150217&lt;/version&gt; &lt;configuration&gt; &lt;httpConnector&gt; &lt;port&gt;8000&lt;/port&gt; &lt;/httpConnector&gt; &lt;stopKey&gt;shutdown&lt;/stopKey&gt; &lt;stopPort&gt;9966&lt;/stopPort&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; redis相关配置由于我spring配置文件和mybatis写在了一块，所以在spring-mybatis.xml里添加redis相关配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package="com.zh.*" /&gt; &lt;!-- 引入properties配置文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:config/jdbc.properties&lt;/value&gt; &lt;value&gt;classpath:config/redis.properties&lt;/value&gt; &lt;!--要是有多个配置文件，只需在这里继续添加即可 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:com/zh/mapping/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zh.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置开始 --&gt; &lt;!-- jedis 配置 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig" &gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt; &lt;property name="maxWaitMillis" value="$&#123;redis.maxWait&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;" /&gt; &lt;/bean &gt; &lt;!-- redis服务器中心 --&gt; &lt;bean id="connectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;property name="poolConfig" ref="poolConfig" /&gt; &lt;property name="port" value="$&#123;redis.port&#125;" /&gt; &lt;property name="hostName" value="$&#123;redis.host&#125;" /&gt; &lt;!-- &lt;property name="password" value="$&#123;redis.password&#125;" /&gt; --&gt; &lt;property name="timeout" value="$&#123;redis.timeout&#125;" &gt;&lt;/property&gt; &lt;/bean &gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" &gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="keySerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="valueSerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;/bean &gt; &lt;!-- cache配置插入、更新数据时从redis中清除缓存 --&gt; &lt;bean id="putCache" class="com.zh.redis.cache.PutCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- cache配置从redis获取缓存数据 --&gt; &lt;bean id="getCache" class="com.zh.redis.cache.GetCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置结束 --&gt;&lt;/beans&gt; redis.properties相关配置：1234567891011121314151617#redis中心 #绑定的主机地址 redis.host=127.0.0.1#指定Redis监听端口，默认端口为6379 redis.port=6379 #授权密码（本例子没有使用） redis.password=#最大空闲数：空闲链接数大于maxIdle时，将进行回收 redis.maxIdle=100 #最大连接数：能够同时建立的“最大链接个数” redis.maxActive=300 #最大等待时间：单位msredis.maxWait=1000 #使用连接时，检测连接是否成功 redis.testOnBorrow=true#当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 redis.timeout=10000 spring-mvc.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package="com.zh.controller" /&gt; &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源处理 css js imgs --&gt; &lt;mvc:resources location="/resources/**" mapping="/resources"/&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id="mappingJacksonHttpMessageConverter" class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;ref bean="mappingJacksonHttpMessageConverter" /&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 默认编码 --&gt; &lt;property name="defaultEncoding" value="utf-8" /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name="maxUploadSize" value="10485760000" /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name="maxInMemorySize" value="40960" /&gt; &lt;!-- 启用是为了推迟文件解析，以便捕获文件大小异常 --&gt; &lt;property name="resolveLazily" value="true"/&gt; &lt;/bean&gt; &lt;!-- 配置ViewResolver 。可用多个ViewResolver 。使用order属性排序。 InternalResourceViewResolver 放在最后--&gt; &lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;property name="order" value="1"&gt;&lt;/property&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;!-- 告诉视图解析器，返回的类型为json格式 --&gt; &lt;entry key="json" value="application/json" /&gt; &lt;entry key="xml" value="application/xml" /&gt; &lt;entry key="htm" value="text/htm" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="defaultViews"&gt; &lt;list&gt; &lt;!-- ModelAndView里的数据变成JSON --&gt; &lt;bean class="org.springframework.web.servlet.view.json.MappingJacksonJsonView" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="ignoreAcceptHeader" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;!-- 激活自动代理功能，开启注解 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; &lt;!-- 解决使用@ResponseBody 的中文乱码。 --&gt; &lt;bean class="com.zh.common.UTF8StringBeanPostProcessor"&gt;&lt;/bean&gt; &lt;/beans&gt; 开启注解这个一定要写到springmvc.xml里，否则注解会不起作用。 创建自定义注解、切面PutCache.java12345678910/** * 自定义注解,在插入、更新或者删除的时候更新对应的版本 * @author zh */ @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.METHOD&#125;) public @interface PutCache &#123; String name() default ""; String value() default ""; &#125; 被PutCache.java类中自定义的注解所标记的方法将实现下面的切面：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/**@Component * 注解用来将这个切面类实例化为bean， * 这样的操作也可以在Spring的配置文件中通过&lt;bean id="" class=""/&gt;来实现， * 效果一致。但是注解实现和配置实现两者不能共存， * 因为共存后Spring容器会同时管理两个同样的切面bean， * 导致的结果将是所有的通知都会执行两次， * 因为会有两个一样的切面被切入到业务代码中。**///@Component //实例化为bean，并交由Spring容器管理@Aspect //声明这是一个切面public class PutCacheAOP &#123; @Autowired //声明这个变量将由Spring容器注入 private RedisTemplate&lt;Serializable, Object&gt; redisTemplate; private RedisCache redisCache = new RedisCache(); //定义切入点 @Pointcut("@annotation(com.zh.redis.cache.PutCache)") public void putCache()&#123; System.out.println("我是一个切入点"); &#125; /** * 环绕通知,在所有标注@putCache的地方切入 * @param joinPoint */ @Around("putCache()") public Object beforeExec(ProceedingJoinPoint joinPoint)&#123; //前置：到redis中查询缓存 System.out.println("调用从redis中查询的方法..."); //redis中key格式：id String redisKey = getCacheKey(joinPoint); Object object = null; //获取从redis中查询到的对象 Object objectFromRedis = redisCache.getDataFromRedis(redisKey); //如果查询到了 if(null != objectFromRedis)&#123; System.out.println("从redis中查到数据,从redis中清空缓存"); //清空缓存 redisCache.delDataToRedis(redisKey); try &#123; object = joinPoint.proceed();//启动目标方法执行 System.out.println("操作数据库..."); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; &#125;else&#123; System.out.println("从redis中未查到数据..."); //没有查到，那么直接操作数据库 try &#123; object = joinPoint.proceed(); //启动目标方法执行 &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; System.out.println("操作数据库..."); &#125; return object; &#125; /** * 根据类名、方法名和参数值获取唯一的缓存键 * @return 格式为 "包名.类名.方法名.参数类型.参数值"，类似 "your.package.SomeService.getById(int).123" */ @SuppressWarnings("unused") private String getCacheKey(ProceedingJoinPoint joinPoint) &#123; MethodSignature ms=(MethodSignature) joinPoint.getSignature(); Method method=ms.getMethod(); String ActionName = method.getAnnotation(PutCache.class).name(); String fieldList = method.getAnnotation(PutCache.class).value(); //System.out.println("签名是"+ms.toString()); for (String field:fieldList.split(",")) ActionName +="."+field; //先获取目标方法参数，确保redis-Key的唯一性，由于我在更新或者插入时需要根据相同的key清除缓存，这里暂不做处理。 //String id = null; //Object[] args = joinPoint.getArgs(); //if (args != null &amp;&amp; args.length &gt; 0) &#123; // id = String.valueOf(args[0]); //&#125; //ActionName += "="+id; //String redisKey = ms+"."+ActionName; return ActionName; &#125; public void setRedisTemplate( RedisTemplate&lt;Serializable, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125;&#125; GetCache.java12345678910/** * 自定义注解,对于查询使用缓存的方法加入该注解 * @author Chenth */ @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.METHOD&#125;) public @interface GetCache &#123; String name() default ""; String value() default ""; &#125; 被GetCache.java类中自定义的注解所标记的方法将实现下面的切面：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * GetCache对应的切面 * @author zh * *//**@Component * 注解用来将这个切面类实例化为bean， * 这样的操作也可以在Spring的配置文件中通过&lt;bean id="" class=""/&gt;来实现， * 效果一致。但是注解实现和配置实现两者不能共存， * 因为共存后Spring容器会同时管理两个同样的切面bean， * 导致的结果将是所有的通知都会执行两次， * 因为会有两个一样的切面被切入到业务代码中。**///@Component //实例化为bean，并交由Spring容器管理@Aspect //声明这是一个切面public class GetCacheAOP &#123; @Autowired //声明这个变量将由Spring容器注入 private RedisTemplate&lt;Serializable, Object&gt; redisTemplate; private RedisCache redisCache = new RedisCache(); //定义切入点 @Pointcut("@annotation(com.zh.redis.cache.GetCache)") public void getCache()&#123; System.out.println("我是一个切入点"); &#125; /** * 环绕通知,在所有标注@getCache的地方切入 * @param joinPoint */ @Around("getCache()") public Object beforeExec(ProceedingJoinPoint joinPoint)&#123; //前置：到redis中查询缓存 System.out.println("调用从redis中查询的方法..."); //redis中key格式：id String redisKey = getCacheKey(joinPoint); //获取从redis中查询到的对象 Object objectFromRedis = redisCache.getDataFromRedis(redisKey); //如果查询到了 if(null != objectFromRedis)&#123; System.out.println("从redis中查询到了数据...不需要查询数据库"); return objectFromRedis; &#125; System.out.println("没有从redis中查到数据..."); //没有查到，那么查询数据库 Object object = null; try &#123; object = joinPoint.proceed(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; System.out.println("从数据库中查询的数据..."); //后置：将数据库中查询的数据放到redis中 System.out.println("调用把数据库查询的数据存储到redis中的方法..."); redisCache.setDataToRedis(redisKey, object);; System.out.println("redis中的数据..."+object.toString()); //将查询到的数据返回 return object; &#125; /** * 根据类名、方法名和参数值获取唯一的缓存键 * @return 格式为 "包名.类名.方法名.参数类型.参数值"，类似 "your.package.SomeService.getById(int).123" */ @SuppressWarnings("unused") private String getCacheKey(ProceedingJoinPoint joinPoint) &#123; MethodSignature ms=(MethodSignature) joinPoint.getSignature(); Method method=ms.getMethod(); String ActionName = method.getAnnotation(GetCache.class).name(); String fieldList = method.getAnnotation(GetCache.class).value(); //System.out.println("签名是"+ms.toString()); for (String field:fieldList.split(",")) ActionName +="."+field; //先获取目标方法参数 //String id = null; //Object[] args = joinPoint.getArgs(); //if (args != null &amp;&amp; args.length &gt; 0) &#123; // id = String.valueOf(args[0]); //&#125; //ActionName += "="+id; //String redisKey = ms+"."+ActionName; return ActionName; &#125; public void setRedisTemplate( RedisTemplate&lt;Serializable, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125;&#125; @Pointcut(“@annotation(com.zh.redis.cache.GetCache)”) 这个切入点的作用是在所有标注@getCache的地方切入 @Around(“getCache()”)这里用的是后置通知，即查询之前先查询redis，如果有数据就返回数据，没有就使用AOP的“启动目标方法函数”执行数据库查询数据，之后再缓存到redis中。 编写mapper层,service层,controller层 在上篇文章中已经进行详细介绍，这里不再讲解。 缓存要用到的工具类 RedisCache 12345678910111213141516171819202122232425262728293031323334353637383940public class RedisCache &#123; @Autowired private JedisPool jedisPool = new JedisPool(); //从redis缓存中查询，反序列化 public Object getDataFromRedis(String redisKey)&#123; //查询 Jedis jedis = jedisPool.getResource(); byte[] result = jedis.get(redisKey.getBytes()); //如果查询没有为空 if(null == result)&#123; return null; &#125; //查询到了，反序列化 return SerializeUtil.unSerialize(result); &#125; //将数据库中查询到的数据放入redis public void setDataToRedis(String redisKey, Object obj)&#123; //序列化 byte[] bytes = SerializeUtil.serialize(obj); //存入redis Jedis jedis = jedisPool.getResource(); String success = jedis.set(redisKey.getBytes(), bytes); if("OK".equals(success))&#123; System.out.println("数据成功保存到redis..."); &#125; &#125; //根据redisKey清除缓存 public void delDataToRedis(String redisKey)&#123; Jedis jedis = jedisPool.getResource(); jedis.del(redisKey); System.out.println("缓存数据已清空..."); &#125; 缓存要用到的序列化和反序列化工具123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * * @Description: 序列化反序列化工具 */public class SerializeUtil &#123; /** * * 序列化 */ public static byte[] serialize(Object obj)&#123; ObjectOutputStream oos = null; ByteArrayOutputStream baos = null; try &#123; //序列化 baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(obj); byte[] byteArray = baos.toByteArray(); return byteArray; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * * 反序列化 * @param bytes * @return */ public static Object unSerialize(byte[] bytes)&#123; ByteArrayInputStream bais = null; try &#123; //反序列化为对象 bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 测试redis是否生效在测试过程中遇到了springMvc返回json数据中文乱码问题，使用spring的BeanPostProcessor接口实现。123456789101112131415161718/** * 解决spring MVC3 中@ResponseBody的中文乱码问题 */ public class UTF8StringBeanPostProcessor implements BeanPostProcessor &#123; public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof StringHttpMessageConverter) &#123; MediaType mediaType = new MediaType("text", "plain", Charset.forName("UTF-8")); List&lt;MediaType&gt; types = new ArrayList&lt;MediaType&gt;(); types.add(mediaType); ((StringHttpMessageConverter) bean).setSupportedMediaTypes(types); &#125; return bean; &#125; public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; &#125; 再在springMvc的xml中注册： 12 &lt;!-- 解决使用@ResponseBody 的中文乱码。 --&gt; &lt;bean class="com.zh.common.UTF8StringBeanPostProcessor"&gt;&lt;/bean&gt; 为UserController.java 中的增加方法添加自定义注解@PutCache： 12345678910111213141516171819 // /user/test?id=1@PutCache(name="newsList",value="com.zh.UserController.showUser(String).123") @RequestMapping(value="/test",method=RequestMethod.GET) public String test(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user=null; if (userId==1) &#123; user = new User(); user.setAge(11); user.setId(1); user.setPassword("123"); user.setUserName("javen"); &#125; log.debug(user.toString()); model.addAttribute("user", user); return "index"; &#125; 为UserController.java 中的查询方法添加自定义注解@GetCache： 123456789101112131415 // /user/showUser?id=1// 从请求里面获取参数@GetCache(name="newsList",value="com.zh.UserController.showUser(String).123") @RequestMapping(value="/showUser",method=RequestMethod.GET) @ResponseBodypublic String toIndex(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.debug(user.toString()); String json = JSON.toJSONString(user); return json; //model.addAttribute("user", user); //return "showUser"; &#125; 启动redis服务并启动项目，执行查询方法，控制台输出日志如下所示： http://localhost:8000/user/showUser?id=1 1234567调用从redis中查询的方法...没有从redis中查到数据...userId:1从数据库中查询的数据...调用把数据库查询的数据存储到redis中的方法...数据成功保存到redis...redis中的数据...&#123;&quot;age&quot;:24,&quot;id&quot;:1,&quot;password&quot;:&quot;345&quot;,&quot;userName&quot;:&quot;测试&quot;&#125; 再次执行查询方法，控制台输出日志如下所示： http://localhost:8000/user/showUser?id=1 12调用从redis中查询的方法...从redis中查询到了数据...不需要查询数据库 执行增加方法，控制台输出日志如下所示： http://localhost:8000/user/test?id=1 12345调用从redis中查询的方法...从redis中查到数据,从redis中清空缓存缓存数据已清空...userId:1操作数据库... 再次执行查询方法，控制台输出日志如下所示： http://localhost:8000/user/showUser?id=1 1234567调用从redis中查询的方法...没有从redis中查到数据...userId:1从数据库中查询的数据...调用把数据库查询的数据存储到redis中的方法...数据成功保存到redis...redis中的数据...&#123;&quot;age&quot;:24,&quot;id&quot;:1,&quot;password&quot;:&quot;345&quot;,&quot;userName&quot;:&quot;测试&quot;&#125; 测试通过，由此完成了SSM + redies的整合，降低了应用的数据库请求次数和时间消耗，提高了查询效率。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSM框架整合（Maven+Spring+SpringMVC+MyBatis）]]></title>
      <url>%2Fblog%2F2017%2F02%2F24%2FSSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%EF%BC%88Maven%2BSpring%2BSpringMVC%2BMyBatis%EF%BC%89%2F</url>
      <content type="text"><![CDATA[以下是参考网上的资料自己实践操作的详细步骤。作为日后开发学习的参考。文中JAVA类及配置文件中加入了许多自己的理解和注释，后续会在此框架基础上引入更多的功能，使其更加完善。 基本概念SpringSpring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 SpringMVC Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring MVC分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。 MyBatis MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。 开发环境搭建以及创建Maven Web项目参看博文：http://www.cnblogs.com/zyw-205520/p/4767633.html SSM整合下面主要介绍SSM三大框架的整合，至于环境的搭建以及项目的创建，参看上面的博文。项目依赖包主要由spring核心包、mybatis核心包、dbcp数据库连接池、log4j、slf4j等日志记录相关依赖包、json处理包、junit单元测试包、javaEE核心包、jstl标签所需包、fileupload上传组件包、Jetty容器插件组成，整合分为了2个配置文件，分别是spring-mybatis.xml，包含spring和mybatis的配置文件，还有个是spring-mvc的配置文件，配置文件可以根据实际情况进行调整，此外有2个资源文件：jdbc.propertis和log4j.properties。完整目录结构如下（最后附上源码下载地址）： 使用框架的版本：Spring 4.0.2 RELEASESpring MVC 4.0.2 RELEASEMyBatis 3.2.6 Maven引入需要的JAR包在pom.xml中引入jar包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;!-- modelVersion 这个元素指定了POM的版本，Maven2或者Maven3都只能是4.0.0 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- groupId 是项目组的ID，一般是com.公司组织名.项目名 --&gt; &lt;groupId&gt;com.zh.mavenDemo&lt;/groupId&gt; &lt;!-- artifactId 是该项目在项目组中的ID --&gt; &lt;artifactId&gt;mavenDemo&lt;/artifactId&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- ersion 是项目的版本号，用于维护项目的升级和发布 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 一般没有实际的用处，只是用于标识该项目 --&gt; &lt;name&gt;mavenDemo Maven Webapp&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用--&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 在spring的依赖中，我们需要引用一系列版本的spring，如版本4.0.2.RELEASE，每次都写不利于维护， 所以使用properties标签来统一维护版本号，这样有利于维护，不用大量修改，引用格式 &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; --&gt; &lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;!-- slf4j入口就是众多接口的集合，它不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。 --&gt; &lt;!-- 通俗的讲，slf4j是个数据线，一端嵌入程序，另一端链接日志系统，从而实现将程序中的信息导入到日志系统并记录。 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;!-- log4j是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终日志的输出。 --&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;/properties&gt; &lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;!-- &lt;scope&gt;test&lt;/scope&gt; --&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;!-- spring核心包 --&gt; &lt;!-- 这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring对于object/xml映射的支持，可以让JAVA与XML之间来回切换 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含对Spring对JDBC数据访问进行封装的所有类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含在应用中使用Spring的AOP特性(Spring的面向切面编程)时所需的类。使用基于AOP的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring context的扩展支持，用于MVC方面。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 对JUNIT等测试框架的简单封装 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.36&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp(数据库连接池)的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 记录日志的，封装好的一个包，通过配置文件配置，在程序中直接调用，记录需要记录的日志，一般日志保存在文件中， --&gt; &lt;!-- SLF4J作用：如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无语忍受加载和维护一个新的日志框架的痛苦。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j-log4j12是链接slf4j-api和log4j中间的适配器。它实现了slf4j-apiz中StaticLoggerBinder接口 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON java对象和json相互转化,JSON串解析--&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传组件包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--构建项目需要的信息--&gt; &lt;build&gt; &lt;finalName&gt;mavenDemo&lt;/finalName&gt; &lt;!--使用的插件列表 。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。--&gt; &lt;plugin&gt; &lt;!-- Jetty 是一个开源的servlet容器，它为基于Java的web容器，例如JSP和servlet提供运行环境。Jetty是使用Java语言编写的，它的API以一组JAR包的形式发布。开发人员可以将Jetty容器实例化成一个对象，可以迅速为一些独立运行（stand-alone）的Java应用提供网络和web连接。 --&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.2.8.v20150217&lt;/version&gt; &lt;configuration&gt; &lt;httpConnector&gt; &lt;port&gt;8000&lt;/port&gt; &lt;/httpConnector&gt; &lt;stopKey&gt;shutdown&lt;/stopKey&gt; &lt;stopPort&gt;9966&lt;/stopPort&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 整合SpringMVC配置spring-mvc.xml配置里面的注释也很详细，主要是自动扫描控制器，视图模式，注解的启动这三个。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package="com.zh.controller" /&gt; &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源处理 css js imgs --&gt; &lt;mvc:resources location="/resources/**" mapping="/resources"/&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id="mappingJacksonHttpMessageConverter" class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;ref bean="mappingJacksonHttpMessageConverter" /&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 默认编码 --&gt; &lt;property name="defaultEncoding" value="utf-8" /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name="maxUploadSize" value="10485760000" /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name="maxInMemorySize" value="40960" /&gt; &lt;!-- 启用是为了推迟文件解析，以便捕获文件大小异常 --&gt; &lt;property name="resolveLazily" value="true"/&gt; &lt;/bean&gt; &lt;!-- 配置ViewResolver 。可用多个ViewResolver 。使用order属性排序。 InternalResourceViewResolver 放在最后--&gt; &lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;property name="order" value="1"&gt;&lt;/property&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;!-- 告诉视图解析器，返回的类型为json格式 --&gt; &lt;entry key="json" value="application/json" /&gt; &lt;entry key="xml" value="application/xml" /&gt; &lt;entry key="htm" value="text/htm" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="defaultViews"&gt; &lt;list&gt; &lt;!-- ModelAndView里的数据变成JSON --&gt; &lt;bean class="org.springframework.web.servlet.view.json.MappingJacksonJsonView" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="ignoreAcceptHeader" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;/beans&gt; 配置web.xml文件配置的spring-mvc的Servlet就是为了完成SpringMVC+MAVEN的整合。 web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring和mybatis的配置文件 --&gt; &lt;!-- &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; --&gt; &lt;!-- 编码过滤器 Spring中的字符编码过滤器（CharacterEncodingFilter），可以很方便的为我们解决项目中出现的中文乱码问题；--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- Filter负责拦截的URL 全部以/的请求,如果&lt;url-pattern&gt;/*.action &lt;/&gt;,将会以拦截*.action的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器,配合它一起使用的，经常是context-param，用来指定Spring要加载的配置文件，本质上是创建了一个 WebApplicationContext--&gt; &lt;!-- &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; --&gt; &lt;/listener&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;!-- &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; --&gt; &lt;!-- Spring MVC servlet --&gt; &lt;!-- DispatcherServlet则定义了mvc的相关内容，并配置拦截的url，所有/开头的请求，都会通过SpringMVC这个servlet进行处理。 --&gt; &lt;!-- Servlet拦截匹配规则要自已定义，把拦截下来的请求，交给对于对应的@RequestMapping方法进行处理,也就是依据某某规则分发到目标Controller(我们写的Action)来处理。 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- default servlet映射，此处可以可以配置成*.do，对应struts的后缀习惯 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; Log4j的配置为了方便调试，一般都会使用日志来输出信息，Log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 Log4j的配置很简单，而且也是通用的，下面给出一个基本的配置，换到其他项目中也无需做多大的调整，如果想做调整或者想了解Log4j的各种配置，可见：http://blog.csdn.net/zhshulin/article/details/37937365下面给出配置文件目录：log4j.properties123456789101112131415161718log4j.rootLogger=INFO,Console,File #定义日志输出目的地为控制台 log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.out #可以灵活地指定日志输出格式，下面一行是指定具体的格式 log4j.appender.Console.layout = org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%c] - %m%n #文件大小到达指定尺寸的时候产生一个新的文件 log4j.appender.File = org.apache.log4j.RollingFileAppender #指定输出目录 log4j.appender.File.File = logs/ssm.log #定义文件最大大小 log4j.appender.File.MaxFileSize = 10MB # 输出所有日志，如果换成DEBUG表示输出DEBUG以上级别日志 log4j.appender.File.Threshold = ALL log4j.appender.File.layout = org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%c]%m%n 使用Jetty测试 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zh.model;public class User &#123; private Integer id; private String userName; private String password; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName == null ? null : userName.trim(); &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password == null ? null : password.trim(); &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package package com.zh.controller;import javax.servlet.http.HttpServletRequest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod;import com.zh.model.User; @Controller @RequestMapping("/user") // /user/**public class UserController &#123; private static Logger log=LoggerFactory.getLogger(UserController.class); // /user/test?id=1 @RequestMapping(value="/test",method=RequestMethod.GET) public String test(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user=null; if (userId==1) &#123; user = new User(); user.setAge(11); user.setId(1); user.setPassword("123"); user.setUserName("javen"); &#125; log.debug(user.toString()); model.addAttribute("user", user); return "index"; &#125; &#125; 在浏览器中输入：http://localhost:8000/user/test?id=1 到此 SpringMVC+Maven 整合完毕 Spring与MyBatis的整合取消3.2.2 web.xml中注释的代码(全部) 建立JDBC属性文件jdbc.properties（文件编码修改为utf-8）1234567891011121314driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mavenusername=rootpassword=root#定义初始连接数initialSize=0#定义最大连接数maxActive=20#定义最大空闲maxIdle=20#定义最小空闲minIdle=1#定义最长等待时间maxWait=60000 建立spring-mybatis.xml配置文件这个文件就是用来完成spring和mybatis的整合的。这里面也没多少行配置，主要的就是自动扫描，自动注入，配置数据库。注释也很详细，大家看看就明白了。 spring-mybatis.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package="com.zh.*" /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties" /&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:com/zh/mapping/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zh.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;/beans&gt; JUnit测试经过以上步骤，我们已经完成了Spring和mybatis的整合，这样我们就可以编写一段测试代码来试试是否成功了。 创建测试用表既然我们需要测试，那么我们就需要建立在数据库中建立一个测试表，这个表建的很简单，SQL语句为：1234567891011121314151617-- ------------------------------ Table structure for `user_t`-- ----------------------------DROP TABLE IF EXISTS `user_t`;CREATE TABLE `user_t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_name` varchar(40) NOT NULL, `password` varchar(255) NOT NULL, `age` int(4) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_t-- ----------------------------INSERT INTO `user_t` VALUES ('1', '测试', '345', '24');INSERT INTO `user_t` VALUES ('2', 'javen', '123', '10'); 利用MyBatis Generator自动创建代码参考博文：http://blog.csdn.net/zhshulin/article/details/23912615 这篇文章可根据表自动创建实体类、MyBatis映射文件以及DAO接口，完成后将文件复制到工程中。如图： 建立Service接口和实现类下面给出具体的内容： IUserService.jave12345678package com.javen.service; import com.javen.model.User; public interface IUserService &#123; public User getUserById(int userId); &#125; IUserServiceImpl.java123456789101112131415161718192021package com.zh.service.impl;import javax.annotation.Resource;import org.springframework.stereotype.Service;import com.zh.dao.UserMapper;import com.zh.model.User;import com.zh.service.IUserService; @Service("userService") public class IUserServiceImpl implements IUserService &#123; @Resource private UserMapper userDao; public User getUserByIdTest(int userId) &#123; // TODO Auto-generated method stub return this.userDao.selectByPrimaryKey(userId); &#125; &#125; 建立测试类测试类在src/test/java中建立，下面测试类中注释掉的部分是不使用Spring时，一般情况下的一种测试方法；如果使用了Spring那么就可以使用注解的方式来引入配置文件和类，然后再将service接口对象注入，就可以进行测试了。 如果测试成功，表示Spring和Mybatis已经整合成功了。输出信息使用的是Log4j打印到控制台。123456789101112131415161718192021222324252627282930313233343536373839package com.javen.testmybatis;import javax.annotation.Resource; import org.apache.log4j.Logger; import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.alibaba.fastjson.JSON;import com.zh.model.User;import com.zh.service.IUserService; @RunWith(SpringJUnit4ClassRunner.class) //表示继承了SpringJUnit4ClassRunner类 @ContextConfiguration(locations = &#123;"classpath:spring-mybatis.xml"&#125;) public class TestMyBatis &#123; private static Logger logger = Logger.getLogger(TestMyBatis.class); //private ApplicationContext ac = null; //@Autowired(Spring)与@Resource(J2EE)都可以用来装配bean. 都可以写在字段上,或写在setter方法上。@Resource比较优雅 @Resource private IUserService userService = null; // @Before // public void before() &#123; // ac = new ClassPathXmlApplicationContext("applicationContext.xml"); // userService = (IUserService) ac.getBean("userService"); // &#125; @Test public void test1() &#123; User user = userService.getUserByIdTest(1); // System.out.println(user.getUserName()); // logger.info("值："+user.getUserName()); logger.info(JSON.toJSONString(user)); &#125; &#125; 测试结果： 建立UserController类UserController.java 控制器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.zh.controller;import java.io.File;import java.io.IOException;import java.util.Map;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import org.apache.commons.io.FileUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import com.zh.model.User;import com.zh.service.IUserService;@Controller @RequestMapping("/user") // /user/**public class UserController &#123; private static Logger log = LoggerFactory.getLogger(UserController.class); @Resource private IUserService userService; // /user/test?id=1 @RequestMapping(value="/test",method=RequestMethod.GET) public String test(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user=null; if (userId==1) &#123; user = new User(); user.setAge(11); user.setId(1); user.setPassword("123"); user.setUserName("javen"); &#125; log.debug(user.toString()); model.addAttribute("user", user); return "index"; &#125; // /user/showUser?id=1 // 从请求里面获取参数 @RequestMapping(value="/showUser",method=RequestMethod.GET) public String toIndex(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.debug(user.toString()); model.addAttribute("user", user); return "showUser"; &#125; // /user/showUser2?id=1 //用注解@RequestParam直接获取参数名为id的值。 @RequestMapping(value="/showUser2",method=RequestMethod.GET) public String toIndex2(@RequestParam("id") String id,Model model)&#123; int userId = Integer.parseInt(id); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.debug(user.toString()); model.addAttribute("user", user); return "showUser"; &#125; // /user/showUser3/&#123;id&#125; // @pathVariable 从路径中获取变量，把路径当做变量 @RequestMapping(value="/showUser3/&#123;id&#125;",method=RequestMethod.GET) public String toIndex3(@PathVariable("id")String id,Map&lt;String, Object&gt; model)&#123; int userId = Integer.parseInt(id); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.debug(user.toString()); model.put("user", user); return "showUser"; &#125; // /user/&#123;id&#125; @RequestMapping(value="/&#123;id&#125;",method=RequestMethod.GET) public @ResponseBody User getUserInJson(@PathVariable String id,Map&lt;String, Object&gt; model)&#123; int userId = Integer.parseInt(id); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.info(user.toString()); return user; &#125; // /user/&#123;id&#125; @RequestMapping(value="/jsontype/&#123;id&#125;",method=RequestMethod.GET) public ResponseEntity&lt;User&gt; getUserInJson2(@PathVariable String id,Map&lt;String, Object&gt; model)&#123; int userId = Integer.parseInt(id); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.info(user.toString()); return new ResponseEntity&lt;User&gt;(user,HttpStatus.OK); &#125; //文件上传 @RequestMapping(value="/upload") public String showUploadPage()&#123; return "user_admin/file"; &#125; @RequestMapping(value="/doUpload",method=RequestMethod.POST) public String doUploadFile(@RequestParam("file")MultipartFile file) throws IOException&#123; if (!file.isEmpty()) &#123; log.info("Process file:&#123;&#125;",file.getOriginalFilename()); &#125; FileUtils.copyInputStreamToFile(file.getInputStream(), new File("E:\\",System.currentTimeMillis()+file.getOriginalFilename())); return "succes"; &#125;&#125; 新建jsp页面jsp/user_admin/file.jsp1234567891011121314151617&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;上传文件&lt;/h1&gt; &lt;form method="post" action="/user/doUpload" enctype="multipart/form-data"&gt; &lt;input type="file" name="file"/&gt; &lt;input type="submit" value="上传文件"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; jsp/index.jsp12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; jsp/showUser.jsp1234567891011&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; $&#123;user.userName&#125; &lt;/body&gt; &lt;/html&gt; 至此，完成Spring+SpingMVC+mybatis这三大框架整合完成。 部署项目输入地址：http://localhost/user/jsontype/2 项目下载地址：https://github.com/mhkzh/SSM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven日常-你应该知道的一二三]]></title>
      <url>%2Fblog%2F2017%2F02%2F22%2FMaven%E6%97%A5%E5%B8%B8-%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%8C%E4%B8%89%2F</url>
      <content type="text"><![CDATA[在日常工作中，使用Maven只是机械的执行Maven clean、Maven install,对其中的原理与过程并无了解，本文根据《Maven实战》一书，对Maven的日常使用相关的知识进行总结与归纳，浅显易懂。 什么是Maven？如果没有Maven,你可能不得不经历下面的过程：1 如果使用了spring，去spring的官网下载jar包；如果使用hibernate，去hibernate的官网下载Jar包；如果使用Log4j，去log4j的官网下载jar包…..2 当某些jar包有依赖的时候，还要去下载对应的依赖jar包3 当jar包依赖有冲突时，不得不一个一个的排查4 执行构建时，需要使用ant写出很多重复的任务代码5 当新人加入开发时，需要拷贝大量的jar包，然后重复进行构建6 当进行测试时，需要一个一个的运行….检查有了Maven，它提供了三种功能：1 依赖的管理：仅仅通过jar包的几个属性，就能确定唯一的jar包，在指定的文件pom.xml中，只要写入这些依赖属性，就会自动下载并管理jar包。2 项目的构建：内置很多的插件与生命周期，支持多种任务，比如校验、编译、测试、打包、部署、发布…3 项目的知识管理：管理项目相关的其他内容，比如开发者信息，版本等等 Maven如何管理jar包关于jar包的坐标，有过使用经验的都应该有所了解，maven是通过groupId，artifactId，以及version确定一个唯一的jar包。这部分的内容可以参考前一篇：Maven构建过程例如,最常使用的Junit的声明就是如下：123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; 这是声明的范围，不同的生命周期所要求的范围是不一样的，详情参考《Maven实战》&lt;/dependency&gt; 首先先来说说Maven下载jar包的过程：在Maven中会涉及到几种仓库：1 工作空间，即我们的项目工程，这里面可能会放着pom.xml文件，这个pom.xml就是maven的配置文件2 本地仓库，本地仓库用于存放jar包，其实Jar包并不是直接放入工作空间的，它是存放在本地仓库，然后在执行发布打包的时候，添加依赖路径3 私库：私库是使用者自己搭建的maven仓库，用于缓解频繁从外网下载jar包资源的压力。而且使用私库作为缓存层，也相对安全一些。4 共享仓库：书中所说的中央仓库或者一些常用的镜像网站都属于这种，国内比较著名的oschina以及163都是不错的maven仓库。当我们在pom中声明了依赖关系后，参考上面的图： 1 Maven在执行相关的任务时，会先去本地仓库查看是否有该资源，如果有的话，判断版本是否正确，如果一切都没问题则直接使用；否则，执行下一步2 Maven会去配置的共享仓库中查找，如果找到就拷贝到本地仓库中；找不到则会给出相关的提示3 Maven在本地如果搭建了私库，则会去私库中查找，找到就拷贝到本地仓库；找不到就会去共享仓库中查找，然后放入私库和本地库。有了私库，局域网内的开发者可以共享依赖，就不用每个人都去外网下载jar包，浪费带宽了。 关于本地仓库和共享仓库的配置都在settings.xml中，这个文件位于conf中。 settings.xml中本地仓库的配置为：1&lt;localRepository&gt;F:\apache-maven-3.3.9\repo&lt;/localRepository&gt; 默认是在 用户的本地目录/.m2/repository中。 共享仓库的地址配置为:12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; Maven的生命周期与阶段Maven中有三大生命周期，他们相互独立，分别是：1 clean 清理2 default 构建3 site 建站一般来说，clean和default比较常用。 每个生命周期又有不同的阶段，阶段按顺序执行，并且可以指定执行结束的阶段。构建的时候，会依次从最上面的阶段执行到指定的那个阶段。 比如,clean有3个阶段： 1 pre-clean 执行清理前要完成的工作2 clean 清理上一次构建生成的文件3 post-clean 执行清理后需要完成的工作 当我们输入mvn clean的时候，执行的是pre-clean和clean两个阶段。 default的阶段比较多： validateinitializegenerate-sourcesprocess-sourcesgenerate-resourcesprocess-resourcescompileprocess-classesgenerate-test-sourcesprocess-test-sourcesgenerate-test-resourcesprocess-test-resourcestest-compileprocess-test-classestetprepare-packagepackagepre-integration-testintegration-testpost-integration-testverifyinstalldeploy 看名字大概就能理解，当执行mvn install的时候，实际会执行validate–&gt;initialize–&gt;…–&gt;verify–&gt;install等二十几个阶段。 为了操作方便，不同的声明周期可以在一起执行，比如mvn clean install，会先执行clean的阶段，在执行install的阶段。 在IDE开发环境中，当我们Run as的时候，就可以执行maven clean进行清理，或者执行maven install进行构建，也可以执行maven build同时执行clean和install两个任务。 基本上了解上面两个知识点，就足够日常工作使用了。当然Maven可不止这么一点点的东西，比如它还涉及到自定义构建任务、间接依赖的管理、插件的使用、私库的搭建等等，如果需要的话，读者可以参考《Maven实战》，这本书讲述的很全面了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven构建过程]]></title>
      <url>%2Fblog%2F2017%2F02%2F22%2FMaven%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Maven是一款进行 依赖管理、项目构建、信息管理 为一体的工具。它不像Make具有复杂的命令、也不像Ant需要手动编写大量的重复代码就能进行项目的构建；还能提供强大的依赖库管理，避免jar包混乱与冲突；还可以方便的管理项目的信息、知识产权等内容。 下载目前高版本的Eclipse已经集成了Maven，但是考虑到插件的稳定性，还是推荐使用自己安装的Maven(需要在Eclipse中进行绑定)。 手动安装需要在官网下载Maven,目前最新的版本是3.3.9：http://maven.apache.org/download.cgi 一般windows下的用户下载这个zip就可以了，如果要学习源码，可以下载src那版的。 安装1 首先需要安装JDK,在命令行中输入java -version验证版本： 2 然后解压下载好的压缩包： 3 配置环境变量：在“环境变量”中配置： M2_HOME:xxxx/apache-maven-3.3.9在path中添加：”;%M2_HOME%/bin” 4 在命令行中输入 mvn -v测试： 编写如果使用过Ant都知道Ant是通过build.xml执行构建任务的，Maven中是通过pom.xml来执行任务。POM,project object model，即项目对象模型，它通过这个pom.xml描述一个项目的构建以及信息。 1234567891011&lt;?&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xinoo.test&lt;/groupId&gt; &lt;artifactId&gt;first-maven&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;First Maven Project&lt;/name&gt;&lt;/project&gt; 第一行指定了文档的XML版本和编码第二行即每个pom.xml的核心元素——projectproject下面有几个子元素，这几个子元素一般是每个项目都会使用到的：1 modelVersion 这个元素指定了POM的版本，Maven2或者Maven3都只能是4.0.02 groupId 是项目组的ID，一般是com.公司组织名.项目名3 artifactId 是该项目在项目组中的ID,比如当前的项目是项目组的一个代理项目，就可以叫做myproxy4 version 是项目的版本号，用于维护项目的升级和发布5 name 一般没有实际的用处，只是用于标识该项目比较重要的参数是 groupId、artifactId、version，这三个属性确定唯一的一个项目。 执行任务一般的Maven项目会包含这样一个目录树： project |-src–main–java–你的源代码 | |–test—-java–你的单元测试代码 |-target–编译出的文件和jar包 |-pom.xml–项目信息以及任务定义 因此我们在上面的pom.xml同级目录中，创建src/main/java/com/xingoo/test/firstmaven 文件夹然后再该文件夹中创建HelloWorld.java 12345678910package com.xingoo.test.firstmaven;public class HelloWorld&#123; public String sayHello()&#123; return "Hello Maven"; &#125; public static void main(String[] args)&#123; System.out.println(new HelloWorld().sayHello()); &#125;&#125; 然后再pom.xml所在的目录中运行mvn clean compile命令: 会发现目录中多了一个target文夹，文件夹中增加了两个文件夹： 其中classes中是java编译出的class文件、maven-status是依赖的compile插件。 附：maven的基本命令//查看maven版本： mvn -v //编译maven： mvn compile //test： mvn test //清除： mvn clean //打包： mvn package //安装： mvn install]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一次没有最后期限的编程之旅]]></title>
      <url>%2Fblog%2F2017%2F02%2F22%2F%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E6%9C%80%E5%90%8E%E6%9C%9F%E9%99%90%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%97%85(%E8%BD%AC)%2F</url>
      <content type="text"><![CDATA[写的真的很好，一名老程序员独自去探索陌生的技术，陌生的世界。引用文章中的一句话：这个世界，无从选择。也许，走出去，是旅行；只在一处，也是旅行。 今年上半年，是我工作以来最繁忙的六个月，总之遇到了最艰难的教程、最冗长的文档、最繁琐的代码以及最窘迫的合作，最终的极度疲劳成了压垮了我的最后一根稻草。那年杭州，接连40摄氏度以上的连续高温，忽然一天39度，竟然觉得整个世界都清凉了。人，就是这么犯贱，稍有舒缓，便全然忘记曾经的抓狂。“写一个Apple Watch APP玩玩”，忽然闪过这么一个念头。这对执着于《证明论》和《集合论》的苦行者而言，浮现的不过是一次短暂的旅行。旅行，不是迁移，抑或流浪，终究是要回归的。记得还是在2003年的时候，万老师曾不经意间对我说过一句话，“编程这东西，如果不是每次都催得很急的话，其实还是蛮有乐趣的。”从96年初次接触Pascal开始到现在，整整19年了。我不知道编程这东西在满足一切诡异的条件下，是否依旧还有当年的乐趣。譬如，重返19岁。 图1 Turbo Pasca 没有什么需要整理的行囊，也没有什么设定的归期，说走就走，不知何时归来的编程之旅。我并非坚定的要找寻一些所谓编程的乐趣，只是一路风景，一路散心。写点什么呢？我没有做过移动端开发，可生活却早已离不开移动端的APP，使用频率极高的不外是“微信”、“网易新闻”、“QQ”、“支付宝”、“淘宝”、“百度地图”、“哔哩哔哩动画”、“大众点评”以及“Uber”。我想一款优秀的移动端APP，除了移动便携的基本特征之外，还应能充分利用碎片时间以及丰富多源的感知设备。事实上，游离了好久，没有什么惊艳想法。随意翻阅早已在案头，却无暇顾及的两册图书《Objective-C基础教程》和《精通iOS开发》，大致都是一些移动客户端面向对象的可视化设计。我想拥有一个优秀的IDE，一整套API以及丰富文档的支持，iOS开发的学习曲线应该不会太陡峭。于是，关注点就自然转移到了Web服务端的开发。Web服务端的开发是熟悉的，也是陌生的。最早接触Web开发是在2000年春，用的是ASP2.0，VB5.0编写的ActiveX作为控件，浏览器通过数字签名下载到客户端，实现服务器端文件的下载以及数据库的连接。第二次系统性的开发Web应用程序是2005年，用的是WebLogic 8.1提供的一整套解决方案，包括IDE、页面标签、web服务器、中间件、工作流等，这是一次真正意义上的J2EE开发，但因其优秀的封装，却让我无意间失去了一次自主搭建和配置Java web开发环境的绝好机会。2010年经历了第三次Web工程项目的开发，用的是ASP.NET 4.0，整个解决方案除了web工程之外，其余都是C#编写的类库工程，Web Service、自定义网站模板、自定义页面控件以及各种支付接口，在微软从开发环境到部署的一系列支持下，ASP.NET异常强大，超乎我的想象。我搜了一些iOS服务端的开发，也不乏使用ASP.NET的Web Service的案例。既然是一次漫无目的的旅行，不妨选择一些对我而言极为陌生的技术。然而，仅仅才是初步的调研，就发现我面对的不是一种或几种陌生的技术，而是一个陌生的世界。你好，世界。Java还是PHP，形而上的选择Java。形而上，也不全是信仰。杭州两家大型互联网公司，阿里巴巴和网易（网易杭州研发中心）的应用服务端也是用Java开发的。每次选择JDK的版本，通常只是偷懒的做法，我不是什么资深的Java程序员，也没有成熟老旧的代码需要兼容，直接在Oracle主页上下载最新的1.8版本，虽然1.6和1.7依旧是主流。继续Eclipse么？这次终于可以选择了，因为这次选择权掌握在自己手里。2007年使用Eclipse Plug-in参与开发一个无线传感网络（WSN）自定义语言的集成开发环境，尤其是开发Debug功能，简直是噩梦，到现在都还有恐惧的后遗症。论文的最终版本终于废弃了调试功能，但在presentation的时候还是被人问到。我用蹩脚的口语搪塞道，“It’s very difficult to implement, and need further research.”其实，这还算不得research，只是真的没法implement。虽然还不至于到达算法边界，但早已在我的编程能力之外了。据我了解，现在很多Java程序员在使用Intellij IDEA开发。有一个毛估估的统计数据，网易杭州研发中心的开发人员中使用Eclipse和Intellij IDEA的比例已经达到了1:1。相比免费的Eclipse，2000多元的Personal License可能是贵了点，不过对于如此一款优秀的IDE，这个价格真不算高。我下载了试用版，这就算开始了。可选的经典Darcula主题确实相当美观。至于和Maven完美结合之类优点，我自然体会不到的，因为这将是我第一次使用Maven开发。 图2 Darcula主题的Intellij IDEA 此前，对于Maven，我是极度陌生的。好在现在互联网上学习教程太多了，首先从Apache官网上下载最新的Maven应用程序，接着配置 Maven的环境变量，然后Intellij IDEA设置下Maven的home directory，当然也可直接使用Intellij IDEA内嵌的Bundled (Maven 3)插件。现在可以使用Intellij IDEA开发Maven Project了。建立maven-archetype-webapp工程，在pom.xml中配置好Maven插件，以及各种需要引用的库。使用Maven管理库，确实非常方便，真是一种全新的开发体验。直到要运行了，才想起web服务器都没有安装。不管三七二十一，下了Tomcat8.0.23，照着网上的教程，在Intellij IDEA配置好了运行环境。浏览器中出现了“hello, world”，“全小写，有逗号，逗号后空一格，且无感叹号。”至此，JDK 1.8, Maven3.3.3, Intellij IDEA14.1.4, Tomcat8.0.23以及一个“Hello,World”程序，一个很美好的开端。“Hello, World”写完了，没有下一步的计划和目标。Spring是主流么？反正阿里巴巴和网易都用Spring。于是，买本书《Spring MVC学习指南》看看，翻了三两个小时，对Web服务端开发依旧没有什么清晰的概念。看来我的这次没有计划的旅行似乎有了下一个目标，把Java web开发的架构搞搞清楚。毕竟搞清楚了架构，剩下的无非是算法了。寻找并学习Jave web架构的最佳实践，比我预想的困难的多。疯狂搜索的结果是各种技术及其框架浩如烟海，完全没有概念，直到发现在GitHub上有一个叫quick4j的开源项目(https://github.com/starzou/quick4j)，让我对Jave web开发的架构有了初步认识。我很快在IntellijIDEA中导入了quick4j这个项目，并根据README.md的说明在MySQL中运行了数据库脚本，建立了数据库及表。关于MySQL，我不得不多数几句。MySQL是2015年9月DB-Engines排名第二的数据库，我却从来没有使用过，主要因为2010年以后再无开发数据库相关系统，而2010年以前几次开发数据库的工程主要使用Oracle和SQL Server。现在大型互联网公司大都使用根据自身业务优化的特定分布式实时数据库。当然，对于中小企业的开发，MySQL依旧是上佳选择。此外，在一个应用中同时建立与MySQL和MongoDB的连接，合理利用每一种数据库的优点也是一种趋势。 图3 SQL Server存储过程 quick4j采用Druid作为数据库连接池。我查了下才知道，Druid是阿里巴巴的开源项目，是JDBC的一个扩展，项目负责人的年纪应该和我差不多。既然是开源，用的人似乎也不少，那就学习下。在pom.xml中配置好依赖（dependency），然后在applicationContext.xml中配置bean的一些系列参数，除了修改url，username以及password外，其余参数留着以后有兴趣提升性能的时候再去研究罢。在Druid之上，quick4j采用的是Mybatis，也是完全没用过，查了下和Hibernate是一个层次的东西，属于对象关系模型（ORM）范畴。Hibernate很久以前似乎还用过，当年的学习曲线如何，已没了印象。不过，Mybatis的入门似乎非常简单，在applicationContext.xml中将Mybatis和Druid关联好，就可以在xml中编写SQL了。quick4j对于Mybatis的XML文件写得还是很不错的，是一个非常好的范例，尤其对我这样一个初学者，比网上一些介绍Mybatis概念的示例强得多。几乎就是一张表对应一个XML配置文件和一个DAO接口，这些DAO接口很容易被上层调用。在quick4j中，最初使用Mybatis的是一个叫Shiro的安全框架，用于用户的权限管理。当然quick4j在DAO（Mapper）层和Shiro调用之间还封装了一层Service。权限管理是一件令人头疼的事情，好在权限管理再复杂，其关系不过张二维表。根据quick4j的5张表（user、user_role、role、role_permission、permission），我建立了一个权限的示意关系表，三个字段名分别是“Username”、“Role”、“Permission”，Username表示用户名称，如admin、lace；Role表示用户角色，如Admin（管理员）、Guest（访客）；Permission表示许可，如user: create、user: read、user: update、user: delete等。在概要设计时，通常先建立这张权限的示意关系表，然后再转化为实际的数据表。至于Shiro基本功能使用，如SecurityRealm中doGetAuthorizationInfo和doGetAuthenticationInfo的编写并不太复杂，而且quick4j也给出了很好的样例。终于到了Spring MVC这一层，因为这东西刚看过书，整体的概念要比什么Druid、Mybatis、Shiro强的多。除了配置pom.xml, web.xml, dispatcher-servlet.xml外，主要就是这个Controller类。其实也就是request和response了，根据@RequestMapping注解指定访问的URL，关联的方法处理提交的数据，处理完了return一个网页回去，就这么简明。只是封装的过于完美，让我感觉都不像在编程。旅行，不是定居，亦非常年生活，浅尝即止。所谓服务端开发似乎浏览完了，顺便也了解下quick4j的前端开发。quick4j采用了一套被称为“响应式后台管理模板”Metronic来实现（这里指的“后台”是业务的后台），版本是1.5.5，不过即使是1.5.5，其效果也足以让我惊讶了。我上网查了下，最新版本已经是4.1.0了。Metronic是收费的，Regular License价格为28美元，而Extended License价格达到了1400美元。国内也有演示的版本，的确非常精美，万能的淘宝也必然是有的卖的，最新的版本仅仅9块钱人民币。Metronic1.5.5是基于Bootstrap v3.0.3，而Bootstrap则大名鼎鼎，不过我也是刚才知道的。Bootstrap基于HTML5、CSS3以及Javascript，是一套极为优秀的前端开发框架。不过我粗粗看了下，似乎把Metronic以及相关的JQuery用下，前端的UI开发基本也算了解了，Bootstrap暂时是不用学习了。既然Metronic已经4.1.0了，不如替换quick4j的1.5.5。Metronic4.1.0非常大，居然有644M。Metronic4.1.0其实已经支持AngularJS，不过我还是选用了JQuery。原因很简单，据说AngularJS2.0较1.3有非常大的变化，虽然2.0是革命性的，但1.3巨大的用户还处于摇摆不定的状态，可以预见2.0出现需要一大波小白鼠。显然，作为游客，是没有太多精力的。我选择了“v4.1.0\theme\templates\admin4”模板，并没有仔细甄别“\v4.1.0\theme\assets”文件夹，因为引用的目录过于复杂，全部拷贝到webapp目录下，虽然这个assets达到了125M，但模板中引用文件的路径中只要删除“../../”，修改为相对目录即可，因为quick4j在前端页面通过JSP获取了根目录。偷懒是偷懒了点，但增加新的模板文件其实真的很方便。至此，整个开发架构似乎清晰了。数据库采用MySQL；后端包括Druid, Mybatis,Shiro, Spring MVC；前端采用Metronic (HTML5, CSS3, JQuery, Bootstrap)和JSP；IDE、库管理以及Web服务器分别采用IntellijIDE、Maven以及Tomcat。架子终于搭好了，不写个啥的，真是太可惜了。毕竟动手写点什么才叫编程之旅么。先从完善用户登录开始吧。第一个小功能，“记住我”。“记住我”功能仅用前端技术是无法实现的，因为只有在用户名和密码在后台验证正确后，记录这个选项才有意义，记录的方式通过Cookie是最为方便的。后端在验证通过后，将记住我状态，用户名和密码都保存到Cookie中，这样前端页面每次刷新时就可通过js读取Cookie中记住我的状态，并在需要的时候填充到文本框中。此外，还要考虑的一个小问题是用户输入密码不是加密的，而提交的密码是通过sha256加密的，就在每次提交表单时加密。但前端js通过Cookie读取的已经是加密的密码，提交时应防止再次加密。我一下子也没有想到好的办法，只是利用了sha256加密后的长度均为64，而用户密码均小于64这个假设条件来判断。下一个小功能是用户注册，用户注册显然需要用到验证，前端验证自然用到了基于JQuery的jquery.validate验证框架。jquery.validate虽然是前端验证，但也提供通过ajax提交后台验证，正是这个后台验证让我遇到了不少小问题。一般对于格式的验证，比如用户名长度，邮件格式什么的，jquery.validate的前端验证完全胜任。但对于用户名已经被注册这样的功能，则需要通过后台验证。jquery.validate毕竟是一个常用功能，网上的样例非常多，但适用于目前这个架构的却不多。将几种样例反复尝试，始终进入不了Controller中的设置的断点。直到查阅了官方最新样例，竟没有“contentType : “json””这行数据的，我删除之后果然成功了。显然，网上众多的样例是基于不同版本的写法。各种框架集成的首要问题必然是明确各种框架所用的版本，也应多从官方文档中寻找样例。验证通过后，用户信息的提交和后台的处理则没有遇到什么问题，后台Controller直接通过request获取前端的数据，直接调用DAO接口，并插入了新的记录。既然注册都实现了，接下来不妨写一个用户管理功能吧，CRUD么。Create功能似乎和注册功能疑似，唯一的不同是想做一个导航的功能，也就是说左侧是导航菜单，右侧是目标页面。网页框架的设计原本是很熟悉的，核心不过是用边框为0的表格打框架，iframe用作容器，在超链接的target设置iframe的名字，当年几十个核心页面就是这样搭建起来的。世界毕竟变了，Metronic、Bootstrap这些框架都是用DIV来搭建的。那么如何实现导航功能呢？现在JQuery主流的做法是DIV上通过load来实现。一条核心语句就是$(‘#main-content’).load(url);其中main-content为目标DIV的id。明白了这个做法，底气足了很多，很快通过导航左侧点击，右侧出现添加用户页面就做好了。但提交页面数据的方式，我却改用了Ajax，毕竟这是局部刷新。首先，将form中的数据转化为json格式，通过JQuery的$.ajax方式提交，当然后台Controller对应的方法也@ResponseBody的方式，直接接受json数据，这样的写法似乎更有Spring MVC的样式，最后返回个带有success信息的Map给前端意思下。用户管理功能应该有个表，表的每行都可以删除，编辑啥的，表自然是要分页的。接下来，就被这个DataTables搞死了。为了实现数据列表，我想用JQuery的一个插件库DataTables来实现。最初，我使用原生态的DataTables，样式是难看点，先搞清楚数据渲染么。可前端使用DataTables，后端使用Spring MVC响应的几乎没有正确的样例。将网上最为接近的一个样例反复调试和修改，这才关联了后台数据。接下来是前端分页，还是后端分页这个棘手问题了。quick4j其实已经提供后端分页取数据的方法了，因为DataTables前端可以传入当前即将显示记录页面的“记录的起始索引”和“每页显示的行数”，只要将起始索引转换为页码的索引，即可直接调用后端分页方法，从而获取“记录的起始索引”开始，并且长度为“每页显示的行数”的记录列表了，这是一种典型的后端分页方法，实现过程比我想象的要顺利些。数据渲染正确后，使用Metronic中的DataTables替换原生态的DataTables，发现表格数据并没有显示。调试后发现，Metronic4.1修改了原生态DataTables提交的参数名，比如将“iDisplayStart”改为“start”，“iDisplayLength”改为“length”，不明白Metronic 4.1为何如此修改，因为Metronic 1.5.5和标准的DataTables参数还是一致的。最后，通过查看DataTables提交json的参数，修改了Controller的解析方式，使用Metronic样式的DataTables终于可以显示表格数据了。在每行最后添加“编辑”和“删除”链接之后，真正麻烦的问题出现了，在每次点击“上一页”、“下一页”以及“搜索”等操作都会触发向后台取数据的操作，然而返回后“编辑”和“删除”对应的操作完全丢失，反复出现，不得其解。最后还是在强哥的提醒下，这可能是DOM重建的原因，我恍然大悟。将“编辑”和“删除”对应的功能都写在DataTables的fnDrawCallback回调函数，因为fnDrawCallback回调函数会在“初始化、上一页、下一页以及搜索”等情况下会触发。至于编写“编辑”链接相应的功能则较为简单，特别要注意的是，在DIV load的时候要传递当前需要编辑的记录信息，传递的格式为json，毕竟在编辑功能是在原有数据上进行修改，而jsp页面则可通过request.getParameter来获取数据。只剩下删除操作了，不同于编辑功能，点击编辑时会在列表的上方DIV中显示编辑界面，点击删除链接时，应弹出用于提示用户确认的模式对话框。我看了下Metronic的模板页，正好利用原有页面中的id=”portlet-config”的一个div，可以用作模式对话框。接下来的问题是如何通过js向这个div传递当前记录的编号。我在portlet-config这个div中添加了一个隐藏输入框，然后在js中将该隐藏输入框的值设置为当前记录编号。这样，在提交模式对话框时，当前记录编号便被传递至模式对话框所对应的js中，之后再将该记录编号组建成一个json数据，通过Ajax向后台发送一个异步请求，后台的响应和“编辑”类似。当然为了获取模式对话框“确定”还是“取消”，还需要一个页面级的开关变量来控制。至此，这个想到哪写到哪的程序，已经具备了用户登录，注册以及关于用户的添加、编辑、删除以及通过列表方式查看等基本功能。不过，从业务上来讲，超级用户可通过管理员页面登录，具备管理用户的基本功能，而一般的用户则通过前台页面登录。忽然想到，是否能借助Shiro来实现这些功能。首先要做的是分别建立管理员和一般用户登录页面，以及登录后的主页面。管理员登录后，可以添加、列表查看、删除、编辑以及退出功能。而一般用户可登录、注册以及退出操作。建立好两张登录一页面以及对应的js文件后，分别编写对应的Controller，这样写得目的主要区分不同的url，同时也更加清晰。在处理登录url提交时，首先通过Shiro进行身份验证，然后通过subject记录的用户权限判断是否可跳转到相应的主页。此外，为了防止只有超级用户访问的主页被一般用户访问，可在相应的Controller方法上方添加@RequiresRoles(value = RoleSign.ADMIN)。于是，通过Shiro不仅管理了用户登录、退出，而且能根据权限访问指定页面，实现前台、后台的权限管理。 图 4 MyCRUD的DataTables 给这个程序取了个名MyCRUD，这次编码过程中从GitHub学到了不少，深切的感受了开源的力量。因此，也将此代码上传至GitHub，https://github.com/lacelove/MyCRUD。同时也好好学习了下GitHub的基本用法。首先，在本地安装msysgit以及一个客户端TortoiseGit，利用客户端工具中的puttygen生成一个公钥和私钥。然后注册一个GitHub的账号，在创建repository之后，设置SSH key，也就是客户端生成的公钥。此后，客户端设置好GitHub账号后，就可以Clone、Commit和Push了。其他用户如果获取上述私钥后，也可以直接Commit和Push。当然，其他用户没有私钥的话，则可通过pull request方式贡献自己代码。最后还顺便学习了下GitHub Flavored Markdown来编写RAEDME.md，是用标签控制格式的语法，Latex的感觉，难度不大，简单的写了点。旅行，有些累了，就暂且休息下。过去五年，埋头实时控制系统的设计、开发与测试，忽然抬头看世界，真的变了。这是一次没有最后期限的编程之旅，也是一次陌生世界的探索之旅。一路上，好奇、惊叹一次次冲淡了旅途的疲倦。在没有最后期限，没有需求的设定下，多少重拾了一些编程的乐趣。记得有两部影片，《楚门的世界》和《土拨鼠之日》，主人公的环境非常类似，可最后突破自我的方式却截然不同。在《楚门的世界》里，主人公冒着死亡的危险，也要冲出去看看外面的世界；而《土拨鼠之日》主人公无奈到只能在不断死亡中寻找乐趣，最终还是在这个城市里改变了自我。这个世界，无从选择。也许——走出去，是旅行；只在一处，也是旅行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[运用Fluxion社工高效破解WiFi密码]]></title>
      <url>%2Fblog%2F2017%2F02%2F08%2F%E8%BF%90%E7%94%A8Fluxion%E9%AB%98%E6%95%88%E7%A0%B4%E8%A7%A3WiFi%E5%AF%86%E7%A0%81%2F</url>
      <content type="text"><![CDATA[fluxion是一款无线安全测试工具，其攻击的原理更偏向于社会工程学中的钓鱼。fluxion有一个人性化的脚本，可以迅速帮你检查所需要的插件并进行安装，可以在短时间内搭建出一个完整的wifi渗透环境。省去了敲命令行的繁琐，新版本增加了对中文的支持。 github地址：deltaxflux/fluxion 工作原理（大体步骤） 1.扫描能够接收到的WIFI信号 2.抓取握手包(这一步的目的是为了验证WiFi密码是否正确) 3.使用WEB接口 4.启动一个假的AP实例来模拟原本的接入点 5.然后会生成一个MDK3进程。如果普通用户已经连接到这个WiFi，也会输入WiFi密码 6.随后启动一个模拟的DNS服务器并且抓取所有的DNS请求，并且会把这些请求重新定向到一个含有恶意脚本的HOST地址 7.随后会弹出一个窗口提示用户输入正确的WiFi密码 8.用户输入的密码将和第二步抓到的握手包做比较来核实密码是否正确 9.这个程序是自动化运行的，并且能够很快的抓取到WiFi密码 环境设置 目标WIFI SSID:WIFITEST(360安全路由器p1) 目标设备：Redmi Note 3（模拟目标wifi的主人） 操作机：Kali 2016.2（Penetration Testing and Ethical Hacking Linux Distribution） 安装我们直接在github将所有文件克隆到本机，当然你也可以自行下载然后解压。git clone https://github.com/deltaxflux/fluxion.git下载完成所有文件及文件路径启动 ./fluxion 启动后会自动检测本机是否安装其所依赖的其他软件，如果任意一项不存在软件会自动退出并提示缺少的工具 fluxion目录下有一个‘Installer.sh’脚本文件，运行后会自动更新或安装缺少的工具。 ./Installer.sh 这个过程可能需要很长一段时间，更新安装完成如图 再次启动，出现用户协议 正菜开始在经过用户协议及软件检查更新后，就进入了我们今天的正菜，下面我将介绍每一步的作用。 选择语种，这个工具在更新后增加了对中文的支持，虽然有部分菜单翻译不全，但是还是很良心的，这次我们使用中文，选择‘6’选择信道，我们选择‘1’所有信道fluxion调用aircrack扫描附近WIFI 在找到目标WIFI后按‘Ctrl+c’，fluxion会列出扫描结果并通过id进行选择选择目标后 出现WIFI的基本信息及攻击选项 选择‘1 伪装AP’输入握手包存放路径 我们按回车使用默认路径选择抓取握手包的工具 我们选择第一个 aircrack-ag套件 选择攻击方式 我们选择‘1’对所有目标发起deauthentication攻击（详细介绍：无线攻击利器-mdk3） 出现两个窗口，一个是deauthentication攻击，此时连在目标路由器的客户端会强制解除验证解除连接掉线；另一个是aircrack等待抓取握手包，客户端在掉线后重新连接时会抓取握手包。当在aircrack窗口出现WPA handshake时证明已经抓到握手包，然后我们选择‘1 检查握手包’选择获取密码的方式，第一种 web注入 也是我们今天只要介绍的 第二种跑包（暴力破解）之前的文章已经说过 这里我们选泽‘1’ 选择web页面语言，包括了大部分路由器品牌的页面，当然我们也可以根据自己的需要在 /fluxion/Sites/ 修改页面。本次演示我们选择7 中文通用页面 这时fluxion会调用多个工具对原有路由器进行攻击，并迫使客户端连接到我们伪造的ap中，同时对dns进行欺骗将客户端流量转到我们的钓鱼页面 手机会断开原来的wifi 并连接到我们伪造的ap 并弹出认证页面 由于对dns进行了转发，所以即时关闭认证页面 只要打开任意页面都会转到到这 我们输入错误密码 输入正确密码 在通过对比密码正确后，fluxion会关闭伪造的ap 使客户端重新连接到原来的ap 并给出ap密码 退出程序 你们都说不明白 这次加了一个短视频 可以结合文章步骤作参考。 视频地址： fluxion的使用http://www.iqiyi.com/w_19ru5vgdjt.html 更新： Kali支持的网卡类型： http://www.wirelesshack.org/best-kali-linux-compatible-usb-adapter-dongles-2016.html https://www.aircrack-ng.org/doku.php?id=compatibility_drivers&amp;DokuWiki=ha1cljqc5mnki5hpvmhv1tkfm0#compatibility]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WPA-PSK无线网络破解原理及过程]]></title>
      <url>%2Fblog%2F2017%2F02%2F06%2FWPA-PSK%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E7%A0%B4%E8%A7%A3%E5%8E%9F%E7%90%86%E5%8F%8A%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[无线密码破解的方式主要分为一下几种,抓握手包破解、穷举破解pin码、创建伪AP钓鱼等。以下这篇文章主要讲解利用Kali Linux进行的抓包和跑pin的两种wifi破解方式,文章中所涉及到的命令均为最新版本的Kail Linux命令，请放心食用。 本文将主要讲讲WPA-PSK类型的无线网络安全问题，首先我们看下802.11协议相关的基础知识。 802.11常见的几种认证方式 不启用安全 WEP WPA/WPA2-PSK（预共享密钥） WPA/WPA2 802.1X （radius认证）具体在路由器的配置界面一般如下图所示：WPA-PSK的认证过程由于我这里主要分析wpa-psk类型的认证方式，所以这里就不讨论其他的认证方式了，通过抓包分析，我们可以看到wpa-psk的大致认证过程分为以下几步。 无线AP定期发送beacon数据包，使无线终端更新自己的无线网络列表。 无线终端在每个信道（1-13）广播ProbeRequest（非隐藏类型的WiFi含ESSID，隐藏类型的WiFi不含ESSID）。 每个信道的AP回应，ProbeResponse，包含ESSID，及RSN信息。 无线终端给目标AP发送AUTH包。AUTH认证类型有两种，0为开放式、1为共享式（WPA/WPA2必须是开放式）。 AP回应网卡AUTH包。 无线终端给AP发送关联请求包associationrequest数据包。 AP给无线终端发送关联响应包associationresponse数据包。 EAPOL四次握手进行认证（握手包是破解的关键）。 完成认证可以上网。#802.11数据帧类型说明802.11协议的帧类型主要包括管理帧和数据帧，我们这里主要用到管理帧：管理帧的主体包含的固定字段与信息元素是用来运送信息的。管理帧主要以下几种，负责链路层的各种维护功能。 Beacon 信标帧主要用来声明某个网络的存在。定期（默认100s、可自己设置）传送的信标可让station得知网络的存在，从而调整加入该网络所必需的参数。 Probe Request 探查请求帧移动工作站利用Probe Request探查请求帧来扫描区域内目前哪些802.11网络。包含2个字段SSID：可被设定为特定网络的 SSID 或任何网络的 SSID 。Support rates：移动工作站所支持的速率。 ProbeResponse探查响应帧如果ProbeRequest所探查的网络与之兼容，该网络就会以ProbeResponse帧响应。送出最后一个beacon帧的工作站必须负责响应所收到的探查信息。Probe Request帧中包含了beacon帧的所参数，station可根据它调整加入网络所需要的参数。 IBSS announcement traffic indication map (ATIM)IBSS 的通知传输只是消息 Disassociation and Deauthentication取消关联、解除验证帧 AssociationRequest关联请求帧 Reassociation Request重新关联 Association Response and Reassociation Response关联响应、重新关联响应 Authentication身份验证帧 ///Authentication Algorithm Number：用于算法择 Action frame帧传送、关联与身份验证的状态State1 ：未经认证且尚未关联 2 ：已经认证但尚未关联 3 ：已经认证且已经关联。下图是用科来分析数据包显示的帧类型：WPA-PSK认证四次握手认证的过程WPA-PSK破解原理用我们字典中的PSK+ssid先生成PMK（此步最耗时，是目前破解的瓶颈所在），然后结合握手包中的客户端MAC，AP的BSSID，A-NONCE，S-NONCE计算PTK，再加上原始的报文数据算出MIC并与AP发送的MIC比较，如果一致，那么该PSK就是密钥。如图所示：WPA-PSK破解过程接下来我们看看如何进行抓握手包破解WPA-PSK的无线AP，我这里用的工具是kali Linux，kali Linux集成了aircrack套件。然后网卡使用的是rtl8187芯片的外置USB网卡。破解步骤如下：第一步：把usb网卡插入虚拟机，并开启网卡到监听模式，命令如下：“ifconfig wlan0 up” 加载usb网卡。‍‍“airmon-ng start wlan0” 监听模式已激活到mon0。（通过config 命令查看）。如果不开启监听模式会报错如下图：第二步：抓包查看有哪些无线网络，抓包的界面如下图所示：“airodump-ng wlan0mon” 查看周边路由AP的信息。 个人经验一般信号强度大于-70的可以进行破解，大于-60就最好了，小于-70的不稳定，信号比较弱。（信号强度的绝对值越小表示信号越强）第三步：选择要破解的WiFi，有针对性的进行抓握手包，命令如下：“airodump -w sofia -c 3 –bssid C8:3A:35:5E:93:C0 wlan0mon”参数说明：-w 保存数据包的文件名 –c 信道 –bssid ap的mac地址(注意test.cap会被重命名)，也可以用其他工具抓包比如：wireshark、tcpdump，抓到握手包会有提示。第四步：为了顺利抓到握手包，我们需要使用DEAUTH攻击使已经连接的客户端断开并重新连接，以产生握手包。（注意：抓握手包破解必须有合法的客户端才行。）攻击命令如下：“aireplay-ng-0 111 -a ap’mac wlan0mon” (111次)“aireplay-ng-0 3 -a B8:A3:86:63:B4:06 -c 00:18:1a:10:da:c9 -x 200 wlan0mon” (3次)“aireplay-ng -0 0 -a C8:3A:35:5E:93:C0” (循环发送)参数说明：-0 Deautenticate 冲突模式 3 发包次数 -x 发包速度抓包可以看到很多deauthentication类型的数据包：包结构如下：抓到的数据包打开后如下图：图中使用wireshark打开的，EAPOL类型的数据包共有4个，即四次握手的数据包。第五步：接下来就是破解握手包，命令如下：“aircrack-ng-w pass-haoyong.txt test-03.cap”参数解释：-w 字典路径也可以使用图形化工具EWSA进行破解，Elcomsoft Wireless Security Auditor（EWSA）号称可以利用GPU的运算性能快速攻破无线网络密码，运算速度相比使用CPU可提高最多上百倍。上面我们讲解了通过抓握手包破解WPA-PSK认证的无线AP的全过程，从上述过程可以看出，如果AP没有合法的客户端连接，或者密码设置的足够复杂就基本上不可能破解。 通过WPS破解无线路由器密码接下来我们看一下另一种破解方式，也就是常说的pin码破解后者叫wps破解。首先了解下什么是wps：WPS(Wi-FiProtected Setup，Wi-Fi保护设置)是由Wi-Fi联盟组织实施的认证项目，主要致力于简化无线网络的安全加密设置。功能：简化配置，快速配置一个基于WPA2的网络。快速连接，输入pin码或按下WPS键即可完成网络连接。问题：由于WPS存在漏洞，通过PIN码可以直接提取上网密码。通过WPS快速配置无线路由器我们可以通过WPS快速配置无线路由器：步骤如下1、通过电脑连接新买的无线路由器，提示通过pin码进行设置，界面如下：2、输入pin码下一步，就会为路由器自动生成一个足够复杂的认证方式及密码： 通过WPS快速连接已有网络我们也可以通过WPS快速连接已有网络，不用输入复杂的密码：步骤如下（我使用小米手机进行测试）1、在手机上选择通过PIN码进行连接或通过路由器上的WPS按键连接。2、如果选择前者只需要输入pin码即可连接，如果选择的是后者则只需要按以下路由器上的wps键即可完成连接。 Pin码破解的原理由于WPS存在安全问题，通过PIN码可以直接提取上网密码。而pin码是一个8位的整数，破解过程时间比较短。WPS PIN码的第8位数是一个校验和，因此黑客只需计算前7位数。另外前7位中的前四位和后三位分开认证。所以破解pin码最多只需要1.1万次尝试，顺利的情况下在3小时左右。Wps认证流程如下图： 破解的操作步骤第一步：Wash 扫描开启WPS的网络。“wash-i wlan0mon –C”第二步：穷举破解pin码，并通过获取的pin码得到无线AP上网密码。“reaver-i wlan0mon -b 5C:63:BF:BA:44:DC -a -S -vv”reaver参数说明： -i 监听后接口称号‍‍ -b APmac地址 -a 主动检测AP最佳配置 -S 利用最小的DH key（能够进步PJ速度） -v、-vv 显示更多的破解信息 -d 即delay每穷举一次的闲置时候预设为1秒 -t 即timeout每次穷举守候反应的最长时候 -c指定频道能够便当找到信号，如-c1 指定1频道如果无线路由器没开wps功能会报错如下图：另外破解过程中无线路由器会有如下特征：破解成功后如下：如果之前破解的无线路由器密码被改了，可以直接通过pin码获取密码，命令如下：“reaver-i mon0 -b MAC -p PIN8位数”上面就是通过pin码破解无线路由器密码的全过程，可见开启wps功能并不安全，建议最好不要开此功能。最后介绍几个图形界面的工具：常用的图形界面的工具有水滴、打气筒、奶瓶：这些工具只是将Aircrack-ng、 reaver打包图形化，即为Aircrack-ng套件的GUI。 Aircrack-ng是一个与802.11标准的无线网络分析关的安全软件，主要功能：网络侦测，数据包嗅探，WEP和WPA/WPA2-PSKPJ。 reaver，专用来pin PJ的软件、一般都集成在水滴等里面了。 另外我们常用的注：beini/CDlinux/xiaopan都是小型linux系统，已集成了上述工具。下图为水滴的界面。安全建议 使用WPA2认证，不要使用wep或无认证。 为无线网路设置复杂的密码。 关闭WPS功能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[穴居人]]></title>
      <url>%2Fblog%2F2016%2F12%2F13%2F%E7%A9%B4%E5%B1%85%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[转自08年新概念的一篇文章，《黑夜的力量》，阳光地带网，红客联盟，2001年五月一日的黑客大战，PoizonBox，Wired.com，lion，《The Art of Deception》…… 这间房设备很少，一片昏暗，没有开灯。窗户是唯一能够射进阳光的地方，却被厚厚的古铜色落地窗帘严严实实地遮挡。从那几绺连接着窗与帘的蛛网看，窗像一个世纪没被碰过似的。底下是一张茉莉白单人床，床上堆满了各类网络书籍。床边有一张小桌，桌上有一台电脑和五六个仍未来得及扔的方便面盒。地下满是头皮屑。总体看去，这里简陋得像白垩纪的天然洞穴，陈旧得像中世纪的古堡，阴幽得像地狱里的桃源。 房间的主人就是穴居人。他很少出门，一台台式旧电脑加上电话线，就是他的整个世界。 他，棕黄的皮肤，苍白的脸，蓬乱的头发下一双厚厚的金丝架眼镜，颔下有点点杂乱的须，爱因斯坦式的嘴唇，明明二十岁的年纪，却花白了头发，像六十岁的疲惫的老人。连天的熬夜，使得他的双眼浮肿，像金鱼的眼，黑眼圈顺着脸颊下滑，侵占去大半张有雀斑的脸。他不修边幅，穿着一条嫌小的黑白格子水蓝底T-shirt,铁灰的短裤，把他裹的像冬夜里的毛毛虫茧。衣服上黑斑点点，好像很久没有换过。 他怕见光，怕见生人，像威廉古堡里的嗜血鬼。他的生物钟与普通人截然相反，白天昏睡，晚上才起身。他常常这么做，好像这是理所当然。 电脑忠诚地工作着，音响里唱着栗子撕心裂肺的声音：我们在黑夜里逆风飞行/我们是黑夜里的中国之鹰/我们用黑夜里黑色的眼睛/迎接光明的来临…… 这是多年前脍炙人口的《黑夜的力量》，这是一首曾给他带来无限遐想，光明和力量的歌，而此刻听起，何以叫他如此心伤？ 回忆这东西若是可以言喻，便是未熟的猕猴桃，酸而苦楚。是朵云轩信筏上的一滴泪珠，陈旧而凄迷。每每想起，总会令人黯然神伤。“想当年……”，他的唇微微翕动，抬起自己的枯瘦的左手，手掌上食指与拇指之间的线跌宕起伏。不经意间，泪模糊了视线。 网络像一个浓妆艳服纹身，蛇一样扭动着身躯跳着艳舞的妙龄女子，用那朱红的唇袅娜身姿招徕更多人驻足；又像一潭隐蔽在绿叶红花中的毒水，令深陷其中的人无法自拔。她是美丽的，迷离的。善男信女在这里游戏人生。她是单细胞的，超现实的。人性在这里表现得淋漓尽致，是褪去一层现实的缘故。贪婪，虚荣，好胜，幼稚。人的弱点在这里尽是赤裸裸的。 这里生活着一群特殊的群体——黑客，他们是武侠小说里劫富济穷的侠士，是希腊神话里带来圣火的普罗米修斯。他们热爱技术，沉浸于对未知的探索。 在黑客的圈子里，穴居人是赫赫有名的Scorpio。 Scorpio已经不记得他是如何进入这一行的，他只晓得，他大概已经在这一行干了一年半了吧？不，也许更久。他有个奇怪的嗜好，那就是在网络里游荡，像一只乖戾的蜘蛛，迅速地攻破一台台陌生的主机，在视窗里偷窥别人的一举一动。有时会看见别人在玩泡泡堂，在聊天，抑或在看黄色图片——最有趣的一次，是看到一个男人在传奇里男扮女妆，然后骗取另一个人的钱财，瞧那嗲得让人心里发颤的语气，想象着那个男人的用心良苦和人妖的兰花指，他不禁捧腹大笑——尽管如此，他决不会在别人的电脑里破坏数据。他会默默地把补丁打上，或者仅仅留下一个文本，告诉那个人应该怎么改进自己的计算机。然后悄然离开，走时，总不忘擦掉自己的“脚印”，像一个彬彬有礼的绅士。 黑客守则第一条规定，不随意破坏任何系统和数据。 “我是一个守规矩的黑客。”他常这么说，并以此自鸣得意。 他一直这样默默地过着，直到有一天他进入一台机子时发现，机子主人在试着破译另一台计算机。分明是一个新手，踉踉跄跄像一个烂醉的赌徒，磕磕碰碰，每一步都耗费了好长一段时间思考。Scorpio索性饶有兴致地看着，看那位菜鸟的行动。 很弱智的做法：他先用流光跑出管理密码，然后打开cmd,用ipc连上，上传木马，设定计划执行时间，最后让机子重启…… 菜鸟手忙脚乱地进入那台主机，什么都没做，迅速注销，然后又去研究另一台主机。Scorpio觉得有趣，便发给他一则消息，这则消息并不像通常人与人之间互相发送的信息那样有瞧头，而且魔幻般地出现在屏幕中央。 我终于察觉了 菜鸟暂时中止对另一台主机的研究行动，开始思考与电脑化空间幽灵的首次接触过程，接着，另一条匿名信息好像从计算机自身深处浮出，掠过屏幕。 我已控制 数年来，我一直在黑暗中挣扎 现在，我终于看到了光明 菜鸟没有反应，主控终端没有动静。许久，菜鸟终于醒悟，开始进行全面查毒。 这是典型的Scorpio式幽默，Scorpio明白一个人若是猛然意识到自己被人监视，感觉会比见到一只真正的幽灵还糟糕。但Scorpio依然喜欢这种方式。 Scorpio与菜鸟交了朋友。他的网名叫Capricorn，很好学。得益于丰厚的数学功底，扎实的英语水平和编程基础，在计算机方面他无疑是有天赋的。 他们加入了红客联盟，无偿地将自己的研究成果公布，受人尊敬。与他们并驾齐驱的，是一个叫Leo的人，在一所不出名的大学，对同性恋颇有研究，有空会往阳光地带网钻，有时会神经质地嚷着“为同性恋正名” ——Scorpio觉得有趣，毕竟这样赤裸裸的宣言在现实中是很难听到的。他们经常聚在一起探讨问题，有时，他们也会谈一些非技术的东西。 他们谈到人生。 Scorpio是个理想主义者，他认为快乐就是幸福，有车子，有房子，一个漂亮的老婆，就够了。Capricorn想要开公司赚大钱。轮到Leo发言，他却一言不发，好不容易挤出一句话：“我一向是走一步算一步的。” …… 日子一天一天过去，谁也无法察觉一场大战悄无声息地酝酿着，2001年四月一日中美撞击事件，成了战争的导火索，空气中弥漫着强烈的火药味，一场无硝烟的战争一触即发。对此，迟钝的Scorpio竟一直没有察觉，直到接到Leo的电话。 “你知道吗？美国的PoizonBox黑客组织目前在积极策划攻击行动，目标就是我国的各大网站，他们还不断唆使更多黑客加入战团，就今天，已有24个站点被攻陷……”Leo说着,语气表现出他的激愤。 Scorpio没有回答,只是对这个数字稍微不相信,想不到国外黑客如此能耐,如果数据可信,这无疑反映出我国网络安全意识的淡薄。 “这是美国Wired.com的消息,这无疑是对我国黑客界的极大侮辱和挑衅—-我们在秘密策划一场黑客反击战,黑倒美国,让他们知道我们是不可欺负的!”Leo说着,传给Scorpio一个光荣.rar文件,然后隐去。 Scorpio将这个文件解压缩,出现两个文件,一个是未写完的程序,另一个是黑夜的力量.mp3 当Scorpio打开编辑器察看文件时,他震惊了: 这是一个几乎完美的程序,他有着小巧的体积,简明的界面,缜密的算法.整个文件有三个功能组成.第一是扫描,通过这个可以搜出主机的漏洞;第二是修改,通过这个可以随意修改漏洞主机的主页;第三是破坏,在获得权限之后,通过这个,只需简单几个按键,便可将服务器上的资料全盘毁灭. Scorpio知道Leo的意思，是想让他完成程序,在分析程序时,他仿佛看到美国黑客们哭爹喊娘地抱头鼠窜. 但他犹豫了,他感到从未有过恐慌,在他的字典里,黑客的存在是创造而不是破坏.这次行动无疑是违背原则的.但是,他们如此气焰嚣张地公然挑战,这口气谁能咽下? 音乐响起,是栗子浑圆雄厚的声音:”我们是中国的鹰派/我们是中国的精英/不管敌人的盾牌是多么的坚硬/我们要知道让他们知道我们的锐利.” Scorpio立即感到一股莫名的冲动,不用说,他已经完全被歌曲的力量感染了.不再犹豫,他灵活修长的手指在键盘上飞跃,像他炽热的心。他的内心仿佛有一团烈火在熊熊燃烧,将整个房间映得通红。他的房间是他的战线,他在为光荣而战.幸好,他没失去理智，他完成了前两个功能的同时,将第三个功能取消。这样不会违背黑客守则。 5月1日,中美黑客大战正式打响.仅仅一天一夜的时间,黑客联盟便宣布被攻陷的52个站点.随后,成千上万的红旗高高飘扬在美国各各网站,5月4日上午9时到11时15分,美国白宫网站被迫关闭.白宫网站新闻负责人吉米说:”大量不明数据同时涌入,堵塞了白宫及其互联网服务提供商的连接通道厖”直到5月7日,战争热潮才慢慢冷却. 在这场战争中,Leo显得张狂了些，他一共入侵了37台主机，他把所有的数据都毁了——他是无所谓原则的。他似乎不担心被报复，因为他在攻击前用东南亚的“僵尸机”做了至少四级的跳板。在电话里，他乐呵呵地向Scorpio炫耀。 战争给中美双方带来的破坏力是巨大的。战后，两国政府宣布大力整顿网络界。黑客界受到极大的压力，许多黑客网站被迫关闭。随着红客联盟领导人lion宣布解散，Scorpio与其他成员的联系急剧减少。人性真是很现实，原本关系很好的两个人，一旦遭遇危机，为避免受牵连，宁愿断绝联系，甚至都不肯承认曾经认识。很久没有Leo的消息，Scorpio数着日子。幸好，Scorpio还有Capricorn，他们常谈一些生活琐事。 Capricorn说他曾经喜欢过一个女孩，他们挺聊得来，只是素未谋面，不久前在上岛咖啡会过一次，那是挺清秀的女孩。只是从那以后他们再也没联系。“数字恋爱里的人们总爱把对方想象成最完美的天使，一旦见了面，发现了他的缺点，海誓山盟也会在顷刻间化为泡沫。” Capricorn说着。“尽管他们常常刻意掩饰，数字恋爱的人真正在意的不外乎两种东西，一是金钱，二是美貌。” Scorpio说自己仿佛是忧郁的聚生体，常常有一种莫名的危机感，总是为各种事情担忧。不善交流，在他不得不向别人解释某样东西时，他总担心别人嫌烦。‘不懂幽默就不要乱开口’，他常听到这句斥责，于是他决定在公共场合永远闭上他的嘴。他经常在网上聊天，在网上聊天的最大好处，就是在说每一句话前可以好好酝酿。他经常忘记回家的路，却从不向人求助。幸好，他总能找到回家的公共汽车。“车子迟迟未到，苦死了等它的人。” Scorpio说道。其实Scorpio也是有爱情故事的。“好多年前吧，有个女孩向我笑了笑，当时我什么都不懂，只觉得她笑得很好。”直到今日，Scorpio依然单身，生活在对她的回忆里。 美好的时光是童年时的白兔糖，含在嘴里，感受着它的甜。只是白兔糖总有化为水的一天，人也终有一天会各奔东西。只怪分离来得太快，太像流星。当Capricorn宣布要留学美国时，Scorpio感到突然，知道事情无法更改，Scorpio只好给他最诚挚的祝福。 一切都仿佛回归了起点，Scorpio又一个人过，直到有一天收到Leo的E-mail,看样子他很困惑： 我毕业了，一切都从头开始，才知道我的大学三年，全在发昏，这世界真奇怪，他们看一张小小的文凭重过一个人本身。我找不到工作了，只能在街上流浪。QQ里的一个陌生人知道了我现在身处的环境，他告诉我现在流行盗游戏账号和装备，还说网游的装备可以卖钱。我问他怎么样盗？他说现在流行用网页木马！我一下子就明白他说的话是什么意思。我没有说什么，我只是轻轻的把他丢进了QQ的黑名单。我真的很鄙视这种行为。当初我学黑客技术的时候，只因一份对黑客技术的执着和追求。从来没有想过通过这种我鄙视的手段去赚钱。 生活像一个蛮不讲理的大财主，当他想要一个人痛苦时，就会千方百计折磨人。眼看着身上的钱一天比一天少，我向现实低下了头。当天晚上我入侵了国内一个人气蛮不错的游戏站点，并且在首页上挂上了一个网页木马盗网游装备。第二天邮箱里就收到满满的一大堆账号和密码。我知道这一大堆账号和密码代表了网游里的人物装备既将到手了。当盗来的网游装备变成了人民币，我看着手中的人民币想了好多…我想我是堕落了。那一晚我彻底的失眠了… Scorpio读着，他的心狠狠地抽搐，耳畔仿佛响起曾经的《黑夜的力量》：我们在网络里自由飞行/我们是网络里的中国之鹰……歌曲没变，音调没变，感觉变了。变得苍白无力。Scorpio仿佛听到碎玻璃的声音。那是他金色的记忆在瓦解，露出空荡荡的椭圆的框架，流出石油般油腻腻黏糊糊的黑水，那是心的眼泪，是酸楚的苦水。 Leo的E-mail接二连三地来到。 我建立了一个网站，专门教人盗QQ,盗游戏币，挂木马。我发现越具破坏力的东西，人们越乐意学。我才知道，现在的人们最热衷的是破坏，黑客守则成了一纸空文，。我再也得不到从前的快乐，我亲手玷污了我所狂热的黑客技术。我既伤害了别人，也伤害了自己。 我不知道这样的日子何时才能结束。也许有一天被抓了，一切都可以结束了…… 看完后，Scorpio一言不发，只是无奈地摇头。 最后一次收到Leo的E-mail,是在一个夏日的午后。窗外下着朦胧的太阳雨，柔和的斜阳射进Scorpio的房间，给洁白的菊花纹床单镶上了淡淡的橘黄。信里，Leo激动地通知Scorpio，他上了报纸，而且是头条。他一连嚷了三遍才罢休，又赶忙寻来网上的截报。文章中称呼他为“网络失足少年”，有一张他的照片。照片上的他，白皙的皮肤，瘦削的脸庞，高颧骨，浓眉毛下嵌着一双无神的眼睛，前额有两三绺乌黑的长发，一直垂到唇边。 原来，在他读完&lt;&gt;后，想用社会工程学骗取银行帐号，却因此暴露了自己的身份和地址。 文章上说，当警察带他离开时，让众人奇怪的是，他并不抵抗，像是自愿被捕似的。 从此以后，再没有Capricorn和Leo的消息，阳光再也射不进Scorpio的房间。Scorpio逃避着现实。在网上，终日孤魂野鬼似的游荡。后记： 电视剧常常误导人，如果稍加注意，会有这样的画面映入我们的眼帘：一个俊俏的小伙子穿着干净的休闲衫，在空旷整洁的大厅前用一台联想手提电脑表演入侵。周围坐满了焦急等待的人，只见帅哥双手在键盘上飞速地跃动，盖了厚厚一成白粉的脸庞也有节奏地一起一伏，炯炯有神的双目直直地盯着屏幕。忽然，帅哥的眉头猛地紧缩，汗从额头上泌了出来。周围的人都摒住了呼吸，空气好像都凝固了。不久，电脑自动地响起来,说：“入侵成功”。帅哥的眉头渐渐舒展开，如释重负地叹了口气，周围的人一愣，过了几秒，立即爆发出雷鸣般的掌声…… 现实中的黑客往往没有电视剧里的那么精彩，那么神秘，那么惬意。他们是有着各自的痛苦与孤独的，所以才将自己寄托给冰冷的网络和黑夜。 故事的背景并不是虚构的，天蝎座（Scorpio）的抑郁，摩羯座（Capricorn）的深沉，狮子座（Leo）的张狂。故事里的人，是很多网络人的缩影。故事里的事，是很多网络人的事。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[感恩节，我的第一篇博客上线了]]></title>
      <url>%2Fblog%2F2016%2F11%2F24%2F%E6%84%9F%E6%81%A9%E8%8A%82%EF%BC%8C%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E4%BA%86%2F</url>
      <content type="text"><![CDATA[有时候一件事情的真相，不是来自于对它的思考，而是来自于对它的感觉。 我的个人博客 zhfeat.cc 上线了，我觉得它是一颗 “未熟的猕猴桃”，虽然酸涩苦楚，但随着时间的沉淀，终会有甘美多汁的那一天。]]></content>
    </entry>

    
  
  
</search>
