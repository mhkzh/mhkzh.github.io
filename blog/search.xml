<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[spring boot(一) spring boot项目构建]]></title>
      <url>%2Fblog%2F2017%2F04%2F06%2Fspring%20boot(%E4%B8%80)%20spring%20boot%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[什么是spring bootSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是spring boot其实不是什么新的框架，它默认配置了很多框架的使用方式。 使用spring boot有什么好处其实就是简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢？ 1）配置web.xml，加载spring和spring mvc 2）配置数据库连接、配置spring事务 3）配置加载配置文件的读取，开启注解 4）配置日志文件 … 配置完成之后部署tomcat或者使用jetty进行调试。 … 可参见blog中的SSM框架搭建，虽然可以copy，但是具体过程还是比较耗时耗力的，一个配置没配好，可能就要根据控制台输出的异常去花时间调试一下。 现在非常流行微服务，如果我这个项目仅仅只是需要发送一个邮件，如果我的项目仅仅是生产一个积分；我都需要这样折腾一遍！ 但是如果使用spring boot呢？ 很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套web项目或者是构建一个微服务！ spring boot项目搭建 访问 spring boot github 选择构建工具Maven Project、Spring Boot版本1.5.8以及一些工程基本信息，点击“Switch to the full version.”java版本选择1.8，可参考下图所示： 点击Generate Project下载项目压缩包 解压后，使用eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt;选择解压后的文件夹-&gt; Finsh，OK done! 项目结构介绍项目导入后如下图所示，灰色部分是我自己创建的，可以暂且无视。 如上图所示，Spring Boot的基础结构共三个文件: l src/main/java 程序开发以及主程序入口 l src/main/resources 配置文件 l src/test/java 测试程序另外，spingboot建议的目录结果如下： root package结构：com.example. 123456789101112131415com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- controller | +- CustomerController.java | Application.java 建议放到跟目录下面,主要用于做一些框架配置 domain 目录主要用于实体（Entity）与数据访问层（Repository） service 层主要是业务类代码 controller 负责页面访问控制 采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改 最后，启动Application main方法，至此一个java项目搭建好了！ 引入web模块 pom.xml中添加支持web的模块： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; pom.xml文件中默认有两个模块： spring-boot-starter：核心模块，包括自动配置支持、日志和YAML； spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito 编写controller内容 1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping("/hello") public String index() &#123; return "Hello World"; &#125;&#125; @RestController的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！ ，启动Application.java里的main方法，打开浏览器访问http://localhost:8080/hello，就可以看到效果了。 启动项目后控制台输出： 12345678910111213141516171819202122232425262728293031323334353618:42:34.465 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Included patterns for restart : []18:42:34.481 [main] DEBUG org.springframework.boot.devtools.settings.DevToolsSettings - Excluded patterns for restart : [/spring-boot-starter/target/classes/, /spring-boot-autoconfigure/target/classes/, /spring-boot-starter-[\w-]+/, /spring-boot/target/classes/, /spring-boot-actuator/target/classes/, /spring-boot-devtools/target/classes/]18:42:34.481 [main] DEBUG org.springframework.boot.devtools.restart.ChangeableUrls - Matching URLs for reloading : [file:/C:/Users/Administrator/Desktop/springBoot/springBoot/target/classes/] . ____ _ __ _ _ /\\ / ___&apos;_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.2.RELEASE)2017-04-06 18:42:35.335 INFO 11936 --- [ restartedMain] com.zh.Application : Starting Application on zh-PC with PID 11936 (C:\Users\Administrator\Desktop\springBoot\springBoot\target\classes started by Administrator in C:\Users\Administrator\Desktop\springBoot\springBoot)2017-04-06 18:42:35.335 INFO 11936 --- [ restartedMain] com.zh.Application : No active profile set, falling back to default profiles: default2017-04-06 18:42:35.444 INFO 11936 --- [ restartedMain] ationConfigEmbeddedWebApplicationContext : Refreshing org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@6c7fe02f: startup date [Thu Apr 06 18:42:35 CST 2017]; root of context hierarchy2017-04-06 18:42:39.175 INFO 11936 --- [ restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat initialized with port(s): 8080 (http)2017-04-06 18:42:39.191 INFO 11936 --- [ restartedMain] o.apache.catalina.core.StandardService : Starting service Tomcat2017-04-06 18:42:39.191 INFO 11936 --- [ restartedMain] org.apache.catalina.core.StandardEngine : Starting Servlet Engine: Apache Tomcat/8.5.112017-04-06 18:42:39.395 INFO 11936 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext2017-04-06 18:42:39.395 INFO 11936 --- [ost-startStop-1] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 3951 ms2017-04-06 18:42:39.691 INFO 11936 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean : Mapping servlet: &apos;dispatcherServlet&apos; to [/]2017-04-06 18:42:39.691 INFO 11936 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;characterEncodingFilter&apos; to: [/*]2017-04-06 18:42:39.691 INFO 11936 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;hiddenHttpMethodFilter&apos; to: [/*]2017-04-06 18:42:39.691 INFO 11936 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;httpPutFormContentFilter&apos; to: [/*]2017-04-06 18:42:39.691 INFO 11936 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean : Mapping filter: &apos;requestContextFilter&apos; to: [/*]2017-04-06 18:42:40.143 INFO 11936 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@6c7fe02f: startup date [Thu Apr 06 18:42:35 CST 2017]; root of context hierarchy2017-04-06 18:42:40.284 INFO 11936 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/hello]&#125;&quot; onto public java.lang.String com.zh.controller.HelloWorldController.index()2017-04-06 18:42:40.284 INFO 11936 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error]&#125;&quot; onto public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)2017-04-06 18:42:40.284 INFO 11936 --- [ restartedMain] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped &quot;&#123;[/error],produces=[text/html]&#125;&quot; onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)2017-04-06 18:42:40.315 INFO 11936 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-06 18:42:40.315 INFO 11936 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-06 18:42:40.394 INFO 11936 --- [ restartedMain] o.s.w.s.handler.SimpleUrlHandlerMapping : Mapped URL path [/**/favicon.ico] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]2017-04-06 18:42:40.690 INFO 11936 --- [ restartedMain] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292017-04-06 18:42:40.753 INFO 11936 --- [ restartedMain] o.s.j.e.a.AnnotationMBeanExporter : Registering beans for JMX exposure on startup2017-04-06 18:42:40.956 INFO 11936 --- [ restartedMain] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)2017-04-06 18:42:40.971 INFO 11936 --- [ restartedMain] com.zh.Application : Started Application in 6.444 seconds (JVM running for 7.67) 浏览器访问http://localhost:8080/hello接口返回数据： 如何做单元测试打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print()打印出执行结果。有关mockmvc的介绍请参考前面一篇blog，具体思路就是在单元测试中模拟一个http请求，这样我们就可以很方便的对controller层进行测试了。 1234567891011121314151617@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes = MockServletContext.class)@WebAppConfigurationpublic class HelloWorldControlerTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get("/hello").accept(MediaType.APPLICATION_JSON)) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn(); &#125;&#125; 开发环境的调试热启动在正常开发项目中已经很常见了吧，虽然平时开发web项目过程中，改动项目不重启总是报错；但springBoot对调试支持很好，修改之后可以实时生效，需要在pom文件中添加以下的配置：123456789101112131415161718&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。 总结使用spring boot可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用sping boot非常适合构建微服务。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用MockMvc测试SpringMvc Controller]]></title>
      <url>%2Fblog%2F2017%2F04%2F05%2F%E4%BD%BF%E7%94%A8MockMvc%E6%B5%8B%E8%AF%95SpringMvc%20Controller%2F</url>
      <content type="text"><![CDATA[对模块进行集成测试时，希望能够通过输入URL对Controller进行测试，如果通过启动服务器，建立http client进行测试，这样会使得测试变得很麻烦，比如，启动速度慢，测试验证不方便，依赖网络环境等，这样会导致测试无法进行，为了可以对Controller进行测试，可以通过引入MockMVC进行解决。 什么是MockMvcMockMvc实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，这样可以使得测试速度快、不依赖网络环境，而且提供了一套验证的工具，这样可以使得请求的验证统一而且很方便。 使用场景作为WEB开发人员在开发过程中总是需要测试各种请求，常规的方法则是启动WEB服务器进行测试，如果出错，停掉WEB服务器，调整代码，重启WEB服务器进行测试。大量的时间都浪费在WEB服务器的启动上,MockMvc实现了对Http请求的模拟，该方法基于SpringMVC 与 spring Test 框架，可以让我们不用频繁的启动WEB容器去测试，而是以单元测试的方式进行调试，节省了开发时间，提高了开发效率。 使用要求spring 集成测试中对mock的集成很好，让开发员使用起来很方便，但是使用时必须注意以下三个条件： Junit必须在4.9版本以上 spring版本必须在3.2以上 使用的框架必须是springMvc框架 MockMvc功能依旧基于之blog中搭建的SSM框架。 MockMvc运行配置POM依赖这里只贴上主要用到的依赖： 版本信息：4.0.2.RELEASE12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 &lt;!-- spring核心包 --&gt; &lt;!-- 这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring对于object/xml映射的支持，可以让JAVA与XML之间来回切换 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含对Spring对JDBC数据访问进行封装的所有类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring context的扩展支持，用于MVC方面。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 对JUNIT等测试框架的简单封装 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;!-- &lt;scope&gt;test&lt;/scope&gt; --&gt; &lt;/dependency&gt; &lt;!-- 使用MockMvc模拟请求必须要有这个jar，不然会抛异常 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; 用到的注解 RunWith(SpringJUnit4ClassRunner.class): 表示使用Spring Test组件进行单元测试; WebAppConfiguration: 使用这个Annotate会在跑单元测试的时候真实的启一个web服务，然后开始调用Controller的Rest API，待单元测试跑完之后再将web服务停掉; ContextConfiguration: 指定Bean的配置文件信息，可以有多种方式，这个例子使用的是文件路径形式，如果有多个配置文件，可以将括号中的信息配置为一个字符串数组来表示; 代码结构MessageTest.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.javen.testmybatis;import javax.annotation.Resource;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.MediaType;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import org.springframework.test.context.web.WebAppConfiguration;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;import org.springframework.test.web.servlet.result.MockMvcResultHandlers;import org.springframework.test.web.servlet.result.MockMvcResultMatchers;import org.springframework.test.web.servlet.setup.MockMvcBuilders;import org.springframework.web.context.WebApplicationContext;import com.zh.producer.MessageProducer;/** * 功能概要： * * @author zhanghao */@RunWith(SpringJUnit4ClassRunner.class) //表示继承了SpringJUnit4ClassRunner类 @ContextConfiguration(locations = &#123;"classpath:spring-mybatis.xml"&#125;) @WebAppConfiguration public class MessageTest &#123; //MockMvc实例 private MockMvc mvc; @Autowired private WebApplicationContext wac; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.webAppContextSetup(wac).build(); &#125; /** 整个过程： 1、mockMvc.perform执行一个请求； 2、MockMvcRequestBuilders.get("/user/showUser")构造一个请求 3、ResultActions.andExpect添加执行完成后的断言 4、ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情，比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息。 5、ResultActions.andReturn表示执行完成后返回相应的结果。 * @throws Exception **/ @Test public void getHello() throws Exception&#123; //perform 执行一个RequestBuilder请求，会自动执行SpringMVC的流程并映射到相应的控制器执行处理； mvc.perform(MockMvcRequestBuilders.get("/user/showUser").accept(MediaType.APPLICATION_JSON).param("id", "1")) //andExpect：添加ResultMatcher验证规则，验证控制器执行完成后结果是否正确； .andExpect(MockMvcResultMatchers.status().isOk()) //andDo：添加ResultHandler结果处理器，比如调试时打印结果到控制台； .andDo(MockMvcResultHandlers.print()) //andReturn：最后返回相应的MvcResult；然后进行自定义验证/进行下一步的异步处理； .andReturn(); &#125; &#125; MockMvc可以对controller中的一次调用进行模拟，perform就是一次请求，MockMvcRequestBuilders进行url的请求，andExcept方法为对Controller类、调用方法、视图和model的预期设置，andDo进行这次请求的执行，最后andReturn返回。 MockMvc测试测试逻辑:Mock出一个MockHttpServletRequestBuilder对象。用于模拟Http的get请求方式,param()方法可以给http请求携带参数,相当于写了这样一个url： http://localhost:8000/user/showUser?id=1然后调用.andExport(status().isOk())方法看请求的状态响应码是否为200如果不是则抛异常，测试不通过。 执行单元测试后返回结果： 1234567891011121314151617181920212223242526272829303132MockHttpServletRequest: HTTP Method = GET Request URI = /user/showUser Parameters = &#123;id=[1]&#125; Headers = &#123;Accept=[application/json]&#125; Handler: Type = com.zh.controller.UserController Async: Was async started = false Async result = null Resolved Exception: Type = null ModelAndView: View name = null View = null Model = null FlashMap:MockHttpServletResponse: Status = 200 Error message = null Headers = &#123;Content-Type=[application/json], Content-Length=[55]&#125; Content type = application/json Body = &#123;&quot;age&quot;:24,&quot;id&quot;:1,&quot;password&quot;:&quot;345&quot;,&quot;userName&quot;:&quot;Maven1?&quot;&#125; Forwarded URL = null Redirected URL = null Cookies = [] 其中Body就是我们Controller返回的json字符串。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSM集成Dubbo+Zookeeper实现服务化]]></title>
      <url>%2Fblog%2F2017%2F03%2F29%2FSSM%E9%9B%86%E6%88%90Dubbo%2BZookeeper%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%8C%96%2F</url>
      <content type="text"><![CDATA[随着互联网的发展，网站应用或者企业应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 什么是面向服务的架构(SOA)面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。 SOA的框架也正是现在网站的系统架构演化史，也从侧面反映了我国网民数量的增加和对网站性能的提升。 大型网站系统特点 高并发、大流量：PV量巨大 高可用：7*24小时不间断服务 海量数据：文件数目分分钟xxTB 用户分布广泛，网络情况复杂：网络运营商 安全环境恶劣：黑客的攻击 需求快速变更，发布频繁：快速适应市场，满足用户需求 渐进式发展：慢慢地运营出大型网站 例子：小明作为一个屌丝码农，有一天创建了一个网站，最开始只是小明一个人在运营，所有的程序都在一个Server里面跑，数据库访问和逻辑控制也都写在jsp文件里面。应用程序、数据库、文件等所有资源都集中在一台Server上。这就是典型的纯jsp网站。 后来他的好朋友小王来了，他觉得小明的网站做的不错，于是就提出了改造建议，小王可是受过培训的啊，什么MVC人家可是经常背，于是他们的网站就开始拆分MVC三层了。并且把文件服务器和数据库单独部署到一个Server上。这个时候三台Server平天下，应用和数据服务分离。 再到后来，他们的网站越来越大了，普通的架构已经满足不了他们了，怎么办，必须得做集群，必须要有缓存，什么读写分离啊，redis啊和反向代理和CDN加速等等，慢慢的开始应用起来。 分布式服务：既然每一个应用系统都需要执行许多相通的业务操作，比如用户管理、商品管理等，那么可以将这些共用的业务提取出来，独立部署。 好了，其实dubbo简单来说就是用来管理我们的服务的，以前我们都是自己调自己的服务，如果服务挂掉的话，那么整个系统就挂掉了，现在是我们把服务交给dubbo去统一管理,而zookeeper是管理我们的dubbo的。 Dubbo介绍单一应用架构 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。 此时，用于简化增删改查工作量的 数据访问框架(ORM)是关键。 垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。 此时，用于加速前端页面开发的Web框架(MVC) 是关键。 垂直应用架构详细： 技术比较单一，学习成本低，开发上手快，测试、部署、运维也比较简单。 业务组网也比较简单，在小规模应用场景中，通常只需要做热双机( 双机热备就是当一台服务器挂掉后，自动切换到另一台使用) 即可。 在高并发，大流量的场景中，需要做集群。通常的组网方案是前端F5（F5是一家公司，专门做应用交付的厂商，在负载均衡设备中比较知名的），后端做对等集群(物理配置对等的机器)部署。 缺点： 维护成本越来越高。因为代码是全量一起打包和部署，相互影响。 团队协作效率差，功能重复开发。 系统可靠性变差，容易引起“雪崩”效应。 维护和定制困难。 新功能上线周期变长。 将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，以实现服务的共享和重用，RPC框架就应运而生了。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的 分布式服务框架(RPC) 是关键。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的 资源调度和治理中心(SOA) 是关键。 需求 在大规模服务化之前，应用可能只是通过RMI(Java RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。可以用此方法调用的任何对象必须实现该远程接口。)或Hessian(Hessian是一个轻量级的remoting onhttp工具，使用简单的方法提供了RMI的功能。)等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过F5等硬件进行负载均衡。 当服务越来越多时，服务URL配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。此时需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和Failover，降低对F5硬件负载均衡器的依赖，也能减少部分成本。 当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。这时，需要自动画出应用间的依赖关系图，以帮助架构师理清理关系。 接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阀值，记录此时的访问量，再以此访问量乘以机器数反推总容量。 架构 节点角色说明： Provider: 暴露服务的服务提供方 Consumer: 调用远程服务的服务消费方。 Registry: 服务注册与发现的注册中心。 Monitor: 统计服务的调用次数调和调用时间的监控中心。 Container: 服务运行容器。 调用关系说明： 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 (1) 连通性： 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者 注册中心和监控中心全部 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者 (2) 健状性： 监控中心宕掉不影响使用，只是丢失部分采样数据 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务 注册中心对等集群，任意一台宕掉后，将自动切换到另一台 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯 服务提供者无状态，任意一台宕掉后，不影响使用 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 (3) 伸缩性： 注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者 (4) 升级性： 当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力： 总结Dubbo 是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能。Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。 主要核心部件： Remoting: 网络通信框架，实现了 sync-over-async 和 request-response 消息机制. RPC: 一个远程过程调用的抽象，支持负载均衡、容灾和集群功能 Registry: 服务目录框架用于服务的注册和服务事件发布和订阅 Zookeeper安装与配置 Zookeeper属于Hadoop的一个子项目，是分布式服务框架，主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等等。 Zookeeper的安装和配置十分简单, 既可以配置成单机模式, 也可以配置成集群模式. 下面将分别进行介绍. 本文基于Windows 环境进行配置。 安装下载本文采用Zookeeper3.4.6版本，下载地址：http://zookeeper.apache.org/doc/r3.4.6/releasenotes.html 安装Zookeeper下载后，将Zookeeper解压，如下图： 单机配置打开conf目录下zoo.cfg(如果为zoo_sample.cfg，需改名为zoo.cfg)配置文件进行配置，如下图： 12345678910111213141516171819202122232425262728# The number of milliseconds of each ticktickTime=2000# The number of ticks that the initial # synchronization phase can takeinitLimit=10# The number of ticks that can pass between # sending a request and getting an acknowledgementsyncLimit=5# the directory where the snapshot is stored.# do not use /tmp for storage, /tmp here is just # example sakes.dataDir=/Users/apple/zookeeper0/data# the port at which the clients will connectclientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to "0" to disable auto purge feature#autopurge.purgeInterval=1 参数说明: tickTime：基本事件单元，以毫秒为单位，用来控制心跳和超时，默认情况超时的时间为两倍的tickTime dataDir：数据目录.可以是任意目录. dataLogDir：log目录, 同样可以是任意目录. 如果没有设置该参数,将使用和dataDir相同的设置. clientPort：监听client连接的端口号. maxClientCnxns：限制连接到zookeeper的客户端数量，并且限制并发连接数量，它通过ip区分不同的客户端。 minSessionTimeout和maxSessionTimeout：最小会话超时时间和最大的会话超时时间，在默认情况下，最小的超时时间为2倍的tickTime时间，最大的会话超时时间为20倍的会话超时时间，系统启动时会显示相应的信息。默认为-1 initLimit：参数设定了允许所有跟随者与领导者进行连接并同步的时间，如果在设定的时间段内，半数以上的跟随者未能完成同步，领导者便会宣布放弃领导地位，进行另一次的领导选举。如果zk集群环境数量确实很大，同步数据的时间会变长，因此这种情况下可以适当调大该参数。默认为10 syncLimit：参数设定了允许一个跟随者与一个领导者进行同步的时间，如果在设定的时间段内，跟随者未完成同步，它将会被集群丢弃。所有关联到这个跟随者的客户端将连接到另外一个跟随着。 启动Zookeeper在bin目录下，双击zkServer.cmd即可启动Zookeeper。 如果启动闪退，可能是配置文件有问题，可以使用默认配置文件看是否可以启动。 启动成功见下图： 伪集群配置所谓伪集群, 是指在单台机器中启动多个zookeeper进程, 并组成一个集群. 以启动3个zookeeper进程为例. 将zookeeper的目录拷贝2份: |–zookeeper0 |–zookeeper1 |–zookeeper2 更改zookeeper0/conf/zoo.cfg文件为: 123456789tickTime=2000 initLimit=5 syncLimit=2 dataDir=/Users/apple/zookeeper0/data dataLogDir=/Users/apple/zookeeper0/logs clientPort=4180 server.0=127.0.0.1:8880:7770 server.1=127.0.0.1:8881:7771 server.2=127.0.0.1:8882:7772 新增了几个参数, 其含义如下: initLimit: zookeeper集群中的包含多台server, 其中一台为leader, 集群中其余的server为follower. initLimit参数配置初始化连接时, follower和leader之间的最长心跳时间. 此时该参数设置为5, 说明时间限制为5倍tickTime, 即5*2000=10000ms=10s. syncLimit: 该参数配置leader和follower之间发送消息, 请求和应答的最大时间长度. 此时该参数设置为2, 说明时间限制为2倍tickTime, 即4000ms. server.X=A:B:C 其中X是一个数字, 表示这是第几号server. A是该server所在的IP地址. B配置该server和集群中的leader交换消息所使用的端口. C配置选举leader时所使用的端口. 由于配置的是伪集群模式, 所以各个server的B, C参数必须不同. 参照zookeeper0/conf/zoo.cfg, 配置zookeeper1/conf/zoo.cfg, 和zookeeper2/conf/zoo.cfg文件. 只需更改dataDir, dataLogDir, clientPort参数即可. 在之前设置的dataDir中新建myid文件, 写入一个数字, 该数字表示这是第几号server. 该数字必须和zoo.cfg文件中的server.X中的X一一对应./Users/apple/zookeeper0/data/myid文件中写入0, /Users/apple/zookeeper1/data/myid文件中写入1, /Users/apple/zookeeper2/data/myid文件中写入2. 分别进入/Users/apple/zookeeper0/bin, /Users/apple/zookeeper1/bin, /Users/apple/zookeeper2/bin三个目录, 启动server. 集群模式集群模式的配置和伪集群基本一致. 由于集群模式下, 各server部署在不同的机器上, 因此各server的conf/zoo.cfg文件可以完全一样.基于Linux配置。 123456789tickTime=2000 initLimit=5 syncLimit=2 dataDir=/home/zookeeper/data dataLogDir=/home/zookeeper/logs clientPort=4180 server.43=10.1.39.43:2888:3888 server.47=10.1.39.47:2888:3888 server.48=10.1.39.48:2888:3888 部署了3台zookeeper server, 分别部署在10.1.39.43, 10.1.39.47, 10.1.39.48上. 需要注意的是, 各server的dataDir目录下的myid文件中的数字必须不同. 10.1.39.43 server的myid为43, 10.1.39.47 server的myid为47, 10.1.39.48 server的myid为48. 部署完成后即可分别启动。启动后要检查 Zookeeper 是否已经在服务，可以通过 netstat -at|grep 2181 命令查看是否有 clientPort 端口号在监听服务。 总结Zookeeper安装和配置都比较简单，配置完成以后，启动ZK即可使用。 SSM集成Dubbo+Zookeeper实现服务化前面分别对Dubbo和Zookeeper进行介绍、安装、配置说明。 本文基于之前的SSM项目，配置了两个工程，为方便理解，暂且称其为dubbo-service和dubbo-client dubbo-service提供服务，提供数据增删改查服务，无页面及Controller。 dubbo_client提供页面访问，具体的增删改查条用dubbo-service远程服务。 Pom依赖服务端和客户端一致。在SSM基础上加入Dubbo和Zookeeper依赖。 123456789101112131415161718192021222324252627282930&lt;!-- Dubbo 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.5.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- Zookeeper 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.6&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt; 服务端配置服务接口 DubboTestService.java 1234567891011121314package com.zh.service;import com.zh.model.User;/** * Dubbo生产者接口 * @author Administrator * */public interface DubboTestService &#123; public int insert(User record);&#125; 实现 DubboTestServiceImpl.java 1234567891011121314151617181920package com.zh.service.impl;import javax.annotation.Resource;import org.springframework.stereotype.Service;import com.zh.dao.UserMapper;import com.zh.model.User;import com.zh.service.DubboTestService;@Service("dubboTestService") public class DubboTestServiceImpl implements DubboTestService &#123; @Resource private UserMapper userDao; public int insert(User record) &#123; return this.userDao.insert(record); &#125;&#125; 具体如何操作数据库的过程不再累述，请查看之前的blog或者下载源码。 这里我将配置好的dubbo-service服务端(服务提供者)生成war包，先行部署到tomcat下。 Dubbo服务声明1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd" &gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="dubbo_provider" /&gt; &lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" /&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880" /&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface="com.zh.service.DubboTestService" ref="dubboTestService" /&gt;&lt;/beans&gt; Web.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring和mybatis的配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 编码过滤器 Spring中的字符编码过滤器（CharacterEncodingFilter），可以很方便的为我们解决项目中出现的中文乱码问题；--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- Filter负责拦截的URL 全部以/的请求,如果&lt;url-pattern&gt;/*.action &lt;/&gt;,将会以拦截*.action的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- shiro过滤器定义 --&gt; &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;!-- 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 --&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 拦截所有请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器,配合它一起使用的，经常是context-param，用来指定Spring要加载的配置文件，本质上是创建了一个 WebApplicationContext--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- druid start--&gt; &lt;!-- 配置sql监控 start--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;!-- 网页监控路径放在了项目路径下的 druid路径中 --&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置sql监控 end--&gt; &lt;!-- 监控jsp和do请求，exclusions参数其实可以去掉的 start --&gt; &lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/login.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 配置SESSION超时，单位是分钟 --&gt; &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!--定义一个cxf的servlet,访问webservice/*这个地址就会进入CXF的servlet中。--&gt; &lt;servlet&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/webservice/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 监控jsp和do请求，exclusions参数其实可以去掉的 end --&gt; &lt;!-- druid end--&gt; &lt;!-- Spring MVC servlet --&gt; &lt;!-- DispatcherServlet则定义了mvc的相关内容，并配置拦截的url，所有/开头的请求，都会通过SpringMVC这个servlet进行处理。 --&gt; &lt;!-- 如果你的DispatcherServlet拦截"*.do"这样的有后缀的URL，就不存在访问不到静态资源的问题。 --&gt; &lt;!-- 如果你的DispatcherServlet拦截"/"，为了实现REST风格，拦截了所有的请求，那么同时对*.js,*.jpg等静态文件的访问也就被拦截了。--&gt; &lt;!-- 激活Tomcat的defaultServlet来处理静态文件，如下面&lt;servlet-name&gt;default&lt;/servlet-name&gt;所配 --&gt; &lt;!-- Servlet拦截匹配规则要自已定义，把拦截下来的请求，交给对于对应的@RequestMapping方法进行处理,也就是依据某某规则分发到目标Controller(我们写的Action)来处理。 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- default servlet映射，此处可以可以配置成*.do，对应struts的后缀习惯 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/turnToIndex.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/notfound.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;!-- 确保静态资源可以被访问,对客户端请求的静态资源如图片、 JS文件等的请求交由默认的servlet进行处理,不然访问会报404 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.png&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.swf&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.txt&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ico&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 这里主要是这一句，修改为加载全部以Spring开头的配置文件：1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/context-param&gt; Dubbo-admin管理平台的安装需要将Zookeeper注册中心先启动。 因为zookeeper只是一个黑框，我们无法看到是否存在了什么提供者或消费者，这时就要借助Dubbo-Admin管理平台来实时的查看，也可以通过这个平台来管理提者和消费者。 dubbo-admin.war可在网上百度去下载，但是我下载了好几个war包，发布上去服务启动都报错，这个时候大概是我们系统的JDK和编译dubbo-admin.war的JDK版本不同导致的了。网上推荐说可以直接下载了dubbo-master的源代码，然后自己编译了一个war包，这样就不会存在启动报错的问题了。但是由于阿里停止更新了dubbo，我在使用Maven编译的过程中出现了could not find art ifact com.alibaba:dubbo:jar:2.5.4-SNAPSHOT 异常，这个依赖没有下载下来，导致编译失败，Google了一圈，网上遇到这个问题的童鞋都是更换了maven的公共仓库进行下载，我换了N个都不行，都是最后到这里都卡住。最后花了两积分在CSDN上下载了个jdk1.8能用的dubbo-admin-2.5.4-SNAPSHOT.war，总算是可以在tomcat中启动成功了。 这里提分享给大家我从CSDN上下载的适用于JDK1.8的war包：dubbo-admin-2.5.4-SNAPSHOT.war 自行下载源码编译war包的方式请参考：传送门 这里下载Dubbo-admin2.5.4.war，我将war改名为Root.war复制到Tomcat/webapp目录下，启动Tomcat进行编译，当然你也可以不改名直接放到webapp下。 编译后关闭tomcat，检查项目中的配置文件： D:\apache-tomcat-8.0.9\webapps\ROOT\WEB-INF\dubbo.properties 是否是如下内容： 123dubbo.registry.address=zookeeper://127.0.0.1:2181 dubbo.admin.root.password=root dubbo.admin.guest.password=root 如果是，就不用改，这里的127.0.0.1对应的是自己的电脑IP，因为这里zookeeper也在自己电脑上，所以要这么写才行。一般情况下都是不需要改的，因为初始都是本地的IP地址。但还是看看比较安全。 接下来我们再启动tomcat就可以正常访问了，这里注意，一定要将Zookeeper注册中心先启动。 http://localhost:8803/ 用户名：root 密码：root 启动service端 因为我之前已经将配置好的dubbo-service服务端(服务提供者)部署到tomcat下面了，所以打开Dubbo-admin页面，我们看到已经有了1个应用、1个服务、1个提供者。 具体服务 点击服务治理–服务，查看具体服务 客户端配置dubbo-client项目 接口声明 同样需要将服务接口在客户端声明(将provider的接口生成jar包引入，或者直接拷贝到dubbo-client项目（包名必须一样）)。 DubboTestService.java 1234567891011121314package com.zh.service;import com.zh.model.User;/** * Dubbo消费者接口 * @author Administrator * */public interface DubboTestService &#123; public int insert(User record);&#125; dubbo服务声明spring-dubbo.xml 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd" &gt; &lt;!-- 消费方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="dubbo_consumer" /&gt; &lt;!-- 使用zookeeper注册中心订阅服务地址 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" /&gt; &lt;!-- 用dubbo协议在20880端口调用服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880" /&gt; &lt;!-- 声明需要调用的服务接口 --&gt; &lt;dubbo:reference interface="com.zh.service.DubboTestService" id="dubboTestService" check="false"/&gt;&lt;/beans&gt; 实体类声明说明：服务端和客户端中需要交互的实体类必须实现Serializable接口(序列化) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.zh.model;import java.io.Serializable;@SuppressWarnings("serial")public class User implements Serializable&#123; private Integer id; private String userName; private String password; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName == null ? null : userName.trim(); &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password == null ? null : password.trim(); &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 启动客户端小知识：Service通常用于标注一个业务处理类@Service(“demoService”)表示这个bean的名字是“demoService” 这里写上面那条小知识的原因是，我之前没有在controller中使用@Resource注解将dubboTestService这个实现类的bean装配注入，结果导致消费者没有向zookeeper注册中心订阅自己所需的服务，dubbo admin页面中自然不会新增消费者。所以我的理解是，项目启动时，将dubboTestService这个实现类注入的时候，dubbo会根据配置文件中id=”dubboTestService”这个属性找到配置文件中需要向zookeeper注册中心订阅的接口，然后再通过这个接口名称向zookeeper注册中心订阅该服务。 这里我直接通过jetty启动dubbo-client项目(消费者) 启动后我们刷新dubbo-admin页面，新增了1个应用，1个消费者。就是我们的dubbo-client项目。 消费者管理页面： 测试效果UserController.java12345678910111213141516171819202122@Controller @RequestMapping("/user") // /user/**public class UserController &#123; @Resource //这里其实是由dubbo远程调用得到的对象 private DubboTestService dubboTestService; //测试dubbo调用 @RequestMapping(value = "/insert",method = &#123; RequestMethod.GET &#125;) @ResponseBody public void insert()&#123; User user = new User(); user.setAge(12); user.setPassword("123456"); user.setUserName("测试dubbo"); dubboTestService.insert(user); &#125;&#125; 我们在浏览器中输入url进行测试：http://localhost:8000/user/insert 查看数据库,新增了一条记录，测试成功： 总结： Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。 主要核心部件： Remoting: 网络通信框架，实现了 sync-over-async 和 request-response 消息机制. RPC: 一个远程过程调用的抽象，支持负载均衡、容灾和集群功能 Registry: 服务目录框架用于服务的注册和服务事件发布和订阅 补充dubbo-monitor 监控中心的配置部署过程简单介绍下monitor： Simple Monitor挂掉不会影响到Consumer和Provider之间的调用，所以用于生产环境不会有风险。 配置好了之后可以结合admin管理后台使用，可以清晰的看到服务的访问记录、成功次数、失败次数等.. Simple Monitor采用磁盘存储统计信息，请注意安装机器的磁盘限制，如果要集群，建议用mount共享磁盘。 百度了一下，发现有人在这个简单dubbo监控中心的基础上，二次开发了一个比较完善的版本，走的是数据库而不是写文件，比较优雅，以后实际在生产环节使用可以参考。传送门 这里我就介绍一下简易控制中心monitor的配置和部署 dubbo-monitor是一个web工程，是基于内嵌的jetty。dubbo-monitor是使用Java编写的项目，所以需要安装jdk。 首先下载dubbo-monitor-simple-2.5.3，下载地址: dubbo-monitor-simple-2.5.3 下载下来后，我们发现是一个tar格式的在linux上进行压缩的压缩文件。我本机使用的是windows，所以直接对其进行解压。 解压后再dubbo-monitor-simple-2.5.3根目录下，我们会看到lib、conf、bin三个文件夹。这里我们打开conf文件夹下的dubbo.properties配置文件进行配置。 dubbo.properties1234567891011121314151617181920212223242526272829### Copyright 1999-2011 Alibaba Group.# # Licensed under the Apache License, Version 2.0 (the "License");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at# # http://www.apache.org/licenses/LICENSE-2.0# # Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an "AS IS" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.##dubbo.container=log4j,spring,registry,jettydubbo.application.name=simple-monitordubbo.application.owner=#dubbo.registry.address=multicast://224.5.6.7:1234dubbo.registry.address=zookeeper://127.0.0.1:2181 #dubbo.registry.address=redis://127.0.0.1:6379#dubbo.registry.address=dubbo://127.0.0.1:9090dubbo.protocol.port=7070dubbo.jetty.port=9090dubbo.jetty.directory=D:/dubboMonitor/monitordubbo.charts.directory=D:/dubboMonitor/chartsdubbo.statistics.directory=D:/dubboMonitor/monitor/statisticsdubbo.log4j.file=logs/dubbo-monitor-simple.logdubbo.log4j.level=WARN 这里对比较重要的几条配置进行说明： dubbo.registry.address=zookeeper://127.0.0.1:2181 将ip 端口号 修改为 zookeeper服务器的ip地址端口号，如果你的zookeeper是集群，则注册地址修改为zookeeper://127.0.0.1:2181?backup=127.0.0.1:2182,127.0.0.1:2183 dubbo.protocol.port=7070 协议端口，端口号只要是没有被占用就行 dubbo.jetty.port=9090 jetty提供web服务的端口号，即通过 浏览器访问 监控中心的端口号其他的配置默认就行，当然也可以自己配置。 dubbo.jetty.directory=D:/dubboMonitor/monitor 在配置dubbo.jetty.directory=/aa/bb/monitor 时候 monitor这个目录不存在，默认是不会自动给创建这个目录的，他下面的charts和统计的会自动创建，所以这里我自己在D盘创建了dubboMonitor这个目录，并在下面创建了monitor目录。 dubbo.charts.directory=D:/dubboMonitor/charts charts目录不需要自己创建，如果创建会出现监控图表无法显示的问题。该目录会自动生成，根据dubbo调用次数、平均调用时间所生成的图片会保存在这个目录下面 dubbo.statistics.directory=D:/dubboMonitor/monitor/statistics 该目录下面存放的是根据dubbo调用次数、调用时间所统计相关的数据，以文件的形式进行保存。 配置完成后，不要忘了在我们的消费者(dubbo-client)以及生产者(dubbo-service)项目中的spring-dubbo.xml配置文件中配置monitor监控。 spring-dubbo.xml 1234&lt;!-- 监控中心配置 --&gt; &lt;!-- 监控中心协议，如果为protocol="registry"，表示从注册中心发现监控中心地址，否则直连监控中心 --&gt;&lt;!-- 直连监控中心服务器地址，如：address="192.168.3.71:7070"--&gt;&lt;dubbo:monitor protocol="registry"/&gt; 我们启动zookeeper注册中心、dubbo-admin管理平台、生产者(dubbo-service)、消费者(dubbo-client)、最后启动dubbo-monitor。 dubbo-monitor启动方式：windows下运行dubbo-monitor-simple-2.5.3\bin目录下的start.bat，linux运行start.sh文件。弹出命令框后不要关闭，输出以下信息代表启动成功。 浏览器访问地址 http://192.168.17.129:9090/ 显示页面(为方便理解我用google浏览器翻译了一下) 我在浏览器中调用了两次插入操作的方法url：http://localhost:8000/user/insert 我们可以查看调用情况统计，如下图： 也可以查看调用统计信息图表，如下图： 以上就是dubbo-monitor监控中心的配置和部署，这样，使用dubbo两个必备的工具，dubbo的管理控制台以及简易控制中心monitor我们都有了，是不是很兴奋。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[构建前端Mock Server--RAP部署及使用]]></title>
      <url>%2Fblog%2F2017%2F03%2F24%2F%E6%9E%84%E5%BB%BA%E5%89%8D%E7%AB%AFMock%20Server--RAP%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[RAP是阿里的一套完整的可视化接口管理工具，可以定义接口结构，动态生成模拟数据，校验真实接口正确性。不仅如此，RAP围绕接口定义，提供了一系列包括团队管理、项目管理、文档版本管理、mock插件等服务。RAP可以完全可视化地定义项目相关信息，定义接口的请求响应等等，学习成本较低。RAP还为后端开发人员提供了校验接口的功能，为前端开发人员提供了mock数据的工具等。 RAP使用场景mock：模拟的，虚假的 mock server：模拟服务，模拟请求，模拟虚假数据 为了前后端更好的分工，接口文档是必须的，前后端都根据接口文档写代码，然后对接接口就行了。 但是，后端跟不上前端节奏，接口跟不上来怎么办？即便接口跟上来了，大后端数据跟不上又怎么办？ 第一种想到的方法就是模拟返回数据，根据接口文档定义好的返回数据格式，新建一个json文件夹，里面放一堆*.json文件，像这样： 然后请求json数据，像这样： 所以为了前端有数据，就会有很多很多的请求json文件。当后端接口上来后，又要一个一个挨着去把json请求改为真实接口名，这就要求代码需要写的比较规范，不然接口的对接真的很难受，而且在修改某些复杂逻辑的地方的时候还必须的小心翼翼，不然就只有等测试发来bug单了。 造json文件模拟请求对于小的项目确实还是挺方便的，但是项目大了呢，上百个接口甚至更多呢？ 一堆一堆的json看着都烦，还不说前后端对接了。 那么要怎么才能解决前后分离，节约时间，提高开发效率，减少前端对后端的依赖呢？ 那就是为前端提供一个可以在本地用的web容器，这个就是 mock server。 mock server 能解决哪些问题呢？ 接口文档的编写 根据接口拦截请求，返回接口需要返回的结果数据 方便线上线下的切换 我这里要用做mockserver的就是rap了，rap结合了团队管理，项目管理，文档编写、Mock.js、可视化、接口过渡、文档历史版本（赞）、mock插件（线上线下切换就只需要注释一句代码就OK），支持本地部署。 RAP部署那么怎么将rap部署到本地呢？官网有部署手册：传送门 我这里是部署到windows环境下的。 部署方式有两种： 使用编译好的war包部署（适合仅想部署RAP服务，不需开发定制功能的同学） 使用源码自行编译、开发后部署（需配置J2EE开发环境， 适合想要研究RAP源代码，开发定制功能的同学） 我们不需要自行开发就采用war包部署。 需要环境：jdk，tomcat，MySQL，Redis 第一步：在官网 传送门 将最新的war包下下来，然后改名为ROOT.war，放到tomcat下面的webapps里面 第二步：启动tomcat，该war包自动部署到文件夹ROOT 第三步：修改数据库配置文件，打开ROOT中的WEB-INF/classes/config.properties 123456jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc\:mysql\://localhost\:3306/rap_db?useUnicode\=true&amp;characterEncoding\=utf8&amp;zeroDateTimeBehavior\=convertToNull&amp;noAccessToProcedureBodies\=truejdbc.username=rootjdbc.password=rootredis.host=localhostredis.port=6379 jdbc.username=您的数据库用户名 jdbc.password=您的数据库密码 redis的端口号默认 配置完数据库连接后，我们要在mysql中运行官方提供的sql脚本，以便RAP系统使用。 rap_db.sql 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562CREATE DATABASE IF NOT EXISTS rap_db DEFAULT CHARSET utf8 COLLATE utf8_general_ci;USE rap_db;/************************************************** * * * account module * * * **************************************************//** * user table */CREATE TABLE tb_user( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, account VARCHAR(32) NOT NULL COMMENT '账户名 account name', password VARCHAR(128) NOT NULL COMMENT '密码 password', name VARCHAR(256) NOT NULL COMMENT '名字/昵称 name/nickname', email VARCHAR(256) NOT NULL COMMENT 'email', create_date TIMESTAMP NOT NULL COMMENT '创建日期 create date' DEFAULT now(), is_locked_out INT(1) NOT NULL COMMENT '用户是否锁定 is the user locked out' DEFAULT 0, is_hint_enabled INT(1) NOT NULL COMMENT '是否开启新手引导 is user hint enabled' DEFAULT 1, last_login_date DATETIME NOT NULL COMMENT '最近登录 last login date', incorrect_login_attempt INT(10) NOT NULL COMMENT '错误登录次数，登录成功后会重置为0 count of incorrect login attempts, will be set to 0 after any succesful login' DEFAULT 0, realname VARCHAR(128) NOT NULL COMMENT '真实姓名' DEFAULT '', emp_id VARCHAR(45) NULL COMMENT '工号，可选', mock_num INT(10) NOT NULL COMMENT 'mock次数，用于记录该用户所创建的接口被调用的mock次数。 mock num, used for record mock API invokation count' DEFAULT 0) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * role table * roles instruction: * user - every registered shuold have this role * rd - research and development engineering * qa - quality engineering * pm - project manager * op - operation manager * admin - administrator * god - super admin */CREATE TABLE tb_role( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(16) NOT NULL COMMENT '角色名称 role name') ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * user role table */CREATE TABLE tb_role_and_user( user_id INT(10) NOT NULL, role_id INT(10) NOT NULL, PRIMARY KEY (user_id, role_id), FOREIGN KEY (user_id) REFERENCES tb_user (id), FOREIGN KEY (role_id) REFERENCES tb_role (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/************************************************** * * * project module * * * **************************************************//** * parameter table */CREATE TABLE tb_parameter( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(256) NULL COMMENT '参数含义 parameter name', identifier VARCHAR(256) NULL COMMENT '变量名/参数标识符 parameter identifier', data_type VARCHAR(32) NULL COMMENT '数据类型 data type', remark TEXT NULL COMMENT '备注/mock数据等 remark/mock data', expression VARCHAR(128) NULL COMMENT '备用字段：表达式 backup column:expression', mock_data TEXT NULL COMMENT '备用字段:mock数据 backup column:mock data') ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * project table * workspace_mode 1-vss(default) 2-svn * stage 1-design 2-developing 3-debug */CREATE TABLE tb_project( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, `version` VARCHAR(128) NOT NULL COMMENT '版本号 version no.' DEFAULT '0.0.0.1', name VARCHAR(128) NOT NULL COMMENT '项目名称 project name', create_date TIMESTAMP NOT NULL COMMENT '创建日期 create date' DEFAULT now(), user_id INT(10) NOT NULL COMMENT '创建人ID, project author id', introduction TEXT NULL COMMENT '项目描述 project introduction', workspace_mode INT(10) NOT NULL COMMENT '工作区提交模式(类VSS or SVN)，暂时弃用了。 Workspace submit mode, deprecated.' DEFAULT 1, stage INT(10) NOT NULL COMMENT '项目阶段，暂时废弃;project stage, temply deprecated. 1-design 2-developing 3-debug' DEFAULT 1, project_data LONGTEXT NULL COMMENT '项目JSON数据，存放当前最新的版本。 project JSON data, saved the newest version of the project', group_id INT(10) NULL COMMENT '分组ID group id', related_ids VARCHAR(128) NOT NULL COMMENT '路由ID，用于指定与哪些项目共享mock数据; router id, used for specify sharing data with which projects.' DEFAULT '', update_time DATETIME NOT NULL COMMENT '更新时间 update time', mock_num INT NOT NULL COMMENT 'mock次数 mock num' DEFAULT 0, access_type TINYINT NOT NULL COMMENT '权限控制, 10普通, 0私有' DEFAULT 10, FOREIGN KEY (user_id) REFERENCES tb_user (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * user list and user table * used for creating multiple to multiple mapping * access_level: * 1 - read * 2 - read&amp;write * 3 - read&amp;write&amp;manage */CREATE TABLE tb_project_and_user( project_id INT(10) NOT NULL, user_id INT(10) NOT NULL, access_level INT NOT NULL DEFAULT 1, PRIMARY KEY (project_id, user_id), FOREIGN KEY (project_id) REFERENCES tb_project (id), FOREIGN KEY (user_id) REFERENCES tb_user (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * module table */CREATE TABLE tb_module( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, project_id INT(10) NOT NULL, name VARCHAR(256) NOT NULL, introduction VARCHAR(128) NULL, FOREIGN KEY (project_id) REFERENCES tb_project (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * page table */CREATE TABLE tb_page( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(56) NOT NULL, module_id INT(10) NOT NULL, introduction TEXT NULL, template VARCHAR(128) NULL, FOREIGN KEY (module_id) REFERENCES tb_module (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * action table * request_type: * 1 - get * 2 - post * 3 - ajax get * 4 - ajax post */CREATE TABLE tb_action( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(256) NOT NULL, description TEXT NULL, /* request block */ request_type INT NOT NULL COMMENT '请求类型get/post/put/delete等等 request type' DEFAULT 1, /** request_type = 99, mount type **/ request_url TEXT NULL, disable_cache TINYINT NOT NULL COMMENT '禁用Mock缓存 disable mock cache' DEFAULT 0, /* response block */ response_template TEXT NULL COMMENT '响应模板地址, 暂时弃用。 response template address, temply deprecated.') ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * action and page table * used for creating multiple to multiple mapping */CREATE TABLE tb_action_and_page( action_id INT(10) NOT NULL, page_id INT(10) NOT NULL, FOREIGN KEY (action_id) REFERENCES tb_action (id), FOREIGN KEY (page_id) REFERENCES tb_page (id), PRIMARY KEY (action_id, page_id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * parameter and parameter mapping * complex_parameter has so many parameters(List&lt;Map&gt; or Map) */CREATE TABLE tb_complex_parameter_list_mapping( complex_parameter_id INT(10) NOT NULL, parameter_id INT(10) NOT NULL, PRIMARY KEY (complex_parameter_id, parameter_id), FOREIGN KEY (complex_parameter_id) REFERENCES tb_parameter (id), FOREIGN KEY (parameter_id) REFERENCES tb_parameter (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * parameter and action's request mapping */CREATE TABLE tb_request_parameter_list_mapping( action_id INT(10) NOT NULL, parameter_id INT(10) NOT NULL, PRIMARY KEY (action_id, parameter_id), FOREIGN KEY (action_id) REFERENCES tb_action (id), FOREIGN KEY (parameter_id) REFERENCES tb_parameter (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * parameter and action's response mapping */CREATE TABLE tb_response_parameter_list_mapping( action_id INT(10) NOT NULL, parameter_id INT(10) NOT NULL, PRIMARY KEY (action_id, parameter_id), FOREIGN KEY (action_id) REFERENCES tb_action (id), FOREIGN KEY (parameter_id) REFERENCES tb_parameter (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/************************************************** * * * workspace module * * * **************************************************//** * workspace, deprecated 工作区，暂时未使用 */CREATE TABLE tb_workspace( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, project_id INT(10) NOT NULL, user_id INT NOT NULL, create_date TIMESTAMP NOT NULL DEFAULT now(), update_date DATETIME NOT NULL, project_data LONGTEXT NOT NULL, project_data_original LONGTEXT NOT NULL, FOREIGN KEY (project_id) REFERENCES tb_project (id), FOREIGN KEY (user_id) REFERENCES tb_user (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * workspace save, deprecated 工作区保存草稿，暂时未使用 */CREATE TABLE tb_workspace_save( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, workspace_id INT(10) NOT NULL, update_date DATETIME NOT NULL, project_data LONGTEXT NOT NULL, FOREIGN KEY (workspace_id) REFERENCES tb_workspace (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * check in table * every API document submit saved here, used for version control. * 每一次提交记录在这里，用于版本管理和回滚控制 * workspaceMode 1-VSS 2-SVN */CREATE TABLE tb_check_in( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, create_date TIMESTAMP NOT NULL DEFAULT now(), tag VARCHAR(128) NULL COMMENT 'tag标签 暂时未使用 deprecated', user_id INT(10) NOT NULL COMMENT '提交人 submit user id', project_id INT(10) NOT NULL COMMENT '提交的项目ID submit project id', description TEXT NULL COMMENT '提交描述 submit description', version VARCHAR(128) NOT NULL COMMENT '版本号 version no.', project_data LONGTEXT NOT NULL COMMENT '项目JSON数据 project json data', workspace_mode INT(10) NOT NULL COMMENT '工作区模式(弃用) workspace mode(deprecated)', log TEXT NULL COMMENT '更新日志，用于存储与最近一个版本的对比差异。暂时未使用。update log, used for calculate versions differences. Deprecated.', FOREIGN KEY (user_id) REFERENCES tb_user (id), FOREIGN KEY (project_id) REFERENCES tb_project (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * user settings table * 用户配置表 */CREATE TABLE tb_user_settings( user_id INT(10) NOT NULL, `key` VARCHAR(128) NOT NULL COMMENT '配置KEY config key', `value` VARCHAR(128) NOT NULL COMMENT '配置VALUE config value', PRIMARY KEY (user_id, `key`), FOREIGN KEY (user_id) REFERENCES tb_user (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * user notification table * 用户通知表 */CREATE TABLE tb_notification( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, user_id INT(10) NOT NULL COMMENT '接受通知的用户id; user id to be notified.', target_user_id INT(10) NOT NULL COMMENT '上下文用户id; context user id', type_id SMALLINT NOT NULL COMMENT '1-文档修改,2-被加入新项目', param1 VARCHAR(128) NULL COMMENT '1,2-项目id', param2 VARCHAR(128) NULL COMMENT ' 1,2-项目名称', param3 TEXT NULL COMMENT '备用预留 reserved', create_time TIMESTAMP NOT NULL COMMENT '创建时间 create time' DEFAULT now(), is_read SMALLINT NOT NULL COMMENT '是否已读 is notification read' DEFAULT 0, FOREIGN KEY (user_id) REFERENCES tb_user (id), FOREIGN KEY (target_user_id) REFERENCES tb_user (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * corporation table * 公司表 */CREATE TABLE tb_corporation( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(256) NOT NULL, logo_url VARCHAR(256) NULL, user_id INT(10) NULL, access_type TINYINT NOT NULL COMMENT '权限控制, 10普通, 20公开' DEFAULT 10, `desc` TEXT NOT NULL COMMENT '备注', FOREIGN KEY (user_id) REFERENCES tb_user (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * product line table * 生产线表 */CREATE TABLE tb_production_line( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(256) NOT NULL, project_num INT(10) NOT NULL DEFAULT 0, corporation_id INT(10) NOT NULL, user_id INT(10) NOT NULL, FOREIGN KEY (user_id) REFERENCES tb_user (id), FOREIGN KEY (corporation_id) REFERENCES tb_corporation (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * project group table * 项目分组表 */CREATE TABLE tb_group( id INT(10) AUTO_INCREMENT NOT NULL PRIMARY KEY, name VARCHAR(256) NOT NULL, production_line_id INT(10) NOT NULL, user_id INT(10) NOT NULL, FOREIGN KEY (user_id) REFERENCES tb_user (id), FOREIGN KEY (production_line_id) REFERENCES tb_production_line (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;/** * 规则表，存储通过Open API设置的Mock规则 * Stored mock rules set by Open API */CREATE TABLE tb_rule ( action_id INT(10) NOT NULL PRIMARY KEY, rules TEXT NOT NULL, -- JSON规则 update_time DATETIME NOT NULL DEFAULT NOW(), -- 最近更新时间 FOREIGN KEY (action_id) REFERENCES tb_action (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;CREATE TABLE tb_corporation_and_user( user_id INT(10) NOT NULL, corporation_id INT(10) NOT NULL, role_id INT(10) NOT NULL, PRIMARY KEY (user_id, corporation_id), FOREIGN KEY (user_id) REFERENCES tb_user (id), FOREIGN KEY (corporation_id) REFERENCES tb_corporation (id), FOREIGN KEY (role_id) REFERENCES tb_role (id)) ENGINE = InnoDB DEFAULT CHARSET = utf8;-- required base dataINSERT INTO tb_role (name) VALUES ('god');INSERT INTO tb_role (name) VALUES ('admin');INSERT INTO tb_role (name) VALUES ('user');-- removed unused qa/pm/rd rolesINSERT INTO tb_user (account, password, email, create_date, last_login_date, name) VALUES ('admin', 'RESERVED', 'admin@example.com', NOW(), NOW(), 'admin');INSERT INTO tb_role_and_user (user_id, role_id) VALUES (1, 1);-- INSERT INTO tb_corporation (name, logo_url, user_id) VALUES ('MyTeam', 'empty', 1);-- 新版RAP可以自建团队，不需要插入默认团队了。-- RAP v0.11.5+ users can create teams by their own, so there's no need to set default team. 注意，因最新的mysql的sql_mode设置的比较严格，需要手动配置下SQL_MODE来禁止full_group检查，可以改MySQL配置文件，或者运行如下SQL语句来修改SQL_MODE： 1SET @@global.sql_mode = 'STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION'; 安装redis请参见：http://blog.csdn.net/erlian1992/article/details/54382443 在redis根目录下启动redis： 启动redis命令：1redis-server.exe redis.windows.conf 测试使用开启tomcat和redis，浏览器输入：localhost:8803(我tomcat设置了端口号，默认为8080) 进入RAP的WEB页面说明部署成功了。 首先我们注册一个普通账户，并登陆： 在tb_role_and_user中添加一条记录将我们的账户进行提权，user_id是管理员的id，role_id是1(超级管理员)或2(管理员)。 提权之后我们注册的用户就有超级管理员的权限了。 RAP接口管理的使用方式十分简单，大家自己操作几遍就会了，这里给小白说几个常用的功能点，避免遇到太多坑： 1、 参数录入问题 在进行RAP接口文档编写时，有些接口参数比较多，里大家可以不要浪费时间一个一个去添加参数，直接把我们服务端返回给前端的json导入，会自动生成参数及对应的数据，我们只需要输入每个字段的含义就可以了。 导入以下json：1&#123;"age":24,"id":1,"password":"345","userName":"Maven1库"&#125; 效果如下： 2、 Http请求问题 这个应该是大家比较关心的问题，既然RAP这么强大，如何根据URL请求RAP中编写好的接口，让前端调用该接口和调用服务端一样返回数据呢？ 点击这里进入该接口的控制台： 在控制台中点击请求，这里返回了我们之前导入的JSON数据： 点击请求时，右下角出现了一个请求url，该url就是以页面右上角的请求根路径拼上我们编写接口文档时设置的请求Url获得的，前端可通过该路径进行开发测试，切换到线上版本注释掉该路径更换为线上版本的路径就可以了，是不是很方便？ 1http://localhost:8803/mockjs/2/user/showUser? RAP的使用方式就写到这里，我目前主要进行服务端开发，编写好接口后直接在RAP中进行同步，前端不需要等我把最新的项目部署到服务器，直接根据RAP接口进行开发，提升了工作效率，减少了沟通时间。 Linux 下的部署与windws下没有太大区别，无非是启动redis、将RAP的war包修改成ROOT放到Tomcat的webapp下（RAP官方指出该项目必须放在ROOT下），启动tomcat进行编译，修改RAP的数据库配置文件，再次进行发布就可以了，如果公司有需要可以换换logo，就可以拿出来用了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx使用小结]]></title>
      <url>%2Fblog%2F2017%2F03%2F21%2Fnginx%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[相信很多人都听过nginx，这个小巧的东西慢慢地在吞食apache和IIS的份额。那究竟它有什么作用呢？可能很多人未必了解。 说到反向代理，可能很多人都听说，但具体什么是反向代理，很多人估计就不清楚了。摘一段百度百科上的描述： 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 这里讲得很直白。反向代理方式实际上就是一台负责转发的代理服务器，貌似充当了真正服务器的功能，但实际上并不是，代理服务器只是充当了转发的作用，并且从真正的服务器那里取得返回的数据。这样说，其实nginx完成的就是这样的工作。我们让nginx监听一个端口，譬如80端口，但实际上我们转发给在8080端口的tomcat，由它来处理真正的请求，当请求完成后，tomcat返回，但数据此时没直接返回，而是直接给nginx，由nginx进行返回，这里，我们会以为是nginx进行了处理，但实际上进行处理的是tomcat。说到上面的方式，也许很多人又会想起来，这样可以把静态文件交由nginx来进行处理。对，很多用到nginx的地方都是作为静态伺服器，这样可以方便缓存那些静态文件，比如CSS，JS，html，htm等文件。 闲话就不多说了，我们直接来看看nginx怎么使用。 nginx下载部署要用到的软件当然要下载啦。到nginx官网下一个。http://nginx.org/en/download.html 可以到这里去下。我现在用的版本是nginx-1.8.1，但基本上以后的版本都兼容，而且我们用到的并不涉及到太底层的，应该不会有什么变化。 这里，由于我的是windows，当然下windows版啦。下完后首先要启动吧。进入到nginx根目录，直接启动nginx.exe就OK了。 这里也许你会看到一个窗口一闪而过，根据我们使用tomcat的经验，如果一闪而过，证明有错误了，是吧？但实际上不是。 此时我们打开任务管理器，可以看到两个nginx.exe进程在那里好好的。这说明我们已经启动了，这两个进程一个是nginx的master进程,为主进程,用于控制nginx各个进程之间的协调工作关系 另一个是nginx的worker进程,用于处理用户的请求。 现在，我们已经启动了nginx，这时就可以启动tomcat，想着直接访问http://localhost就可以直接访问tomcat了。 先不急，我们来看看启动后的nginx是怎样的。直接访问http://localhost可以看到： 我们可以看到nginx启动成功，现在访问是直接进到nginx的目录里面了。 nginx配置那么这些实际上是在哪里配置的。这就涉及到nginx的一个重要配置文件nginx.conf了。 我们可以看到nginx文件夹内有一个conf文件夹，其中有好几个文件，其他先不管，我们打开nginx.conf，可以看到一段： 这段代码在server里面，相当于一个代理服务器，当然可以配置多个。下面我们仔细来分析一下： listen：表示当前的代理服务器监听的端口，默认的是监听80端口。注意，如果我们配置了多个server，这个listen要配置不一样，不然就不能确定转到哪里去了。server_name：表示监听到之后需要转到哪里去，这时我们直接转到本地，这时是直接到nginx文件夹内。 location：表示匹配的路径，这时配置了/表示所有请求都被匹配到这里root：里面配置了root这时表示当匹配这个请求的路径时，将会在这个文件夹内寻找相应的文件，这里对我们之后的静态文件伺服很有用。 index：当没有指定主页时，默认会选择这个指定的文件，它可以有多个，并按顺序来加载，如果第一个不存在，则找第二个，依此类推。 下面的error_page是代表错误的页面，这里我们暂时不用，先不管它。那我们知道了具体的配置了，怎么让它访问localhost时转到tomcat时。实际上就修改两个地方：12345server_name localhost:8080; location / &#123; proxy_pass http://localhost:8080;&#125; 我们就修改了上面两个地方，我的tomcat在8080端口，可以根据自己的需要修改。这里有一个新元素proxy_pass，它表示代理路径，相当于转发，而不像之前说的root必须指定一个文件夹。(这里注意，增加配置时需要加;号的地方一定要加上，不然会报错) 此时我们修改了文件，是不是就意思着必须先关了nginx再重新启动了，其实不必，nginx可以重新加载文件的。 我们直接运行：1nginx -s reload 如果不想直接加载，而只是想看看自己的配置文件有没有问题，可以直接输入：1nginx -t 这可以检查配置文件中是否有错。 下面我们所有的修改都假设我们修改完成后运行了nginx -s reload进行重新加载配置文件，请注意。 一切没问题了，然后我们再重新打开http://localhost，我们看到下面的页面： 这时，我们发现它并不是刚才的welcome页面了，而是tomcat的管理页面了，不管我们点击什么链接都是没问题的，相当于直接访问http://localhost:8080一样。 使用nginx做静态伺服上面我们直接试了一个小例子，让nginx进行转发，即所谓的反向代理。但实际上我们的需求不会是这样的，我们需要分文件类型来进行过滤，比如jsp直接给tomcat处理，因为nginx并不是servlet容器，没办法处理JSP，而html,js,css这些不需要处理的，直接给nginx进行缓存。 下面我们来进行一下配置，让JSP页面直接给tomcat，而html,png等一些图片和JS等直接给nginx进行缓存。 这时最主要用的还是location这个元素，并且涉及到一部分正则，但不难： 1234567location ~ \.jsp$ &#123; proxy_pass http://localhost:8080; &#125; location ~ \.(html|js|css|png|gif)$ &#123; root D:\apache-tomcat-8.0.9\webapps\ROOT; &#125; 我们先要去掉之前配的location /，避免全部请求被拦截了。 执行nginx的reload进行重新加载配置文件：1nginx -s reload 然后我们再来看看http://localhost 当我们不指定jsp页面的时候，它会出现找不到，因为，此时并没有相应的location匹配，所以就会有404错误，这时就跳到了nginx自定义的error页面去了。 而当我们用http://localhost/index.jsp去访问时，我们看到了熟悉的页面： 而且图片那些都显示正常，因为图片是png的，所以直接在tomcat/webapps/ROOT目录下直接查找，当然，如果我们点击Manager Application HOW-TO这个链接，我们发现： 它还是找不到，为什么呢？因为这是个html页面，但它并不在ROOT目录下，而是在docs目录下，但当我们匹配html时，我们却到ROOT目录下去找，所以还是找不到这个页面。 一般情况下，如果我们需要用nginx来进行静态文件伺服，一般都会把所有静态文件，html,htm,js,css等都放在同一个文件夹下，这样就不会有tomcat这样的情况了，因为tomcat下的是属于不同的项目，这个我们就没办法了。 nginx 负载均衡有些人会说，这些都只会找一台服务器，但如果我们想在一台服务器挂了的时候，自动去找另外一台，这怎么办？这实际上nginx都考虑到了。 这时，我们之前用的proxy_pass就有大用途了。 我们把之前的第一个例子，即全部都代理的修改一下： 最后修改如下： 12345678910upstream local_tomcat &#123; server localhost:8080; &#125; server&#123; location / &#123; proxy_pass http://local_tomcat; &#125; #......其他省略 &#125; 我们在server外添加了一个upstream，而直接在proxy_pass里面直接用http://+upstream的名称来使用。 我们还是直接来http://localhost，还是和第一个一样的效果，所有链接都没问题，说明我们配置正确。 upstream中的server元素必须要注意，不能加http://，但proxy_pass中必须加。 我们刚才说可以在一个服务器挂了的情况下连到另外一个，那怎么弄呢？ 其实很简单，在upstream中的local_tomcat中配置多一个server。比如我现在再启动RabbitMq的Web管理界面，端口在15672，所以我们配置如下： 1234upstream local_tomcat &#123; server localhost:8080; server localhost:15672; &#125; 执行nginx的reload进行重新加载配置文件：1nginx -s r 此时，我们关闭tomcat，而只开端口为15672的项目。我们来运行http://localhost看看效果： 我们看到它请求到了我端口为15672的RabbitMq的Web管理页面，我们的在一个服务器挂的情况下自动使用另外一个的功能实现了。 但有时我们就不想它挂的时候访问另外一个，而只是希望一个服务器访问的机会比另外一个大，这个可以在server最后加上一个weight=数字来指定，数字越大，表明请求到的机会越大。 1234upstream local_tomcat &#123; server localhost:8080 weight=1; server localhost:15672 weight=5; &#125; 执行nginx的reload进行重新加载配置文件：1nginx -s r 这时我们给了RabbitMq Web管理界面一个更高的权重值，让它更有机会访问到，实际上当我们刷新http://localhost访问的时候发现RabbitMq Web管理界面访问机率大很多，tomcat几乎没机会访问，一般情况下，如果我们必须这样用，不要相关太大，以免一个服务器负载太大。 当然,server还有一些其他的元素，比如down表示暂时不用到该服务器等等。这些可以参考nginx的wiki。也许写了一大堆，有人会有问题，那nginx怎么关闭呢？这倒是个问题，其实直接运行nginx -s stop就可以关闭了。 基本上nginx的用法是这样，深入的以后我们如果用到再学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RabbitMQ与Spring结合讲解(使用amqp消息协议)]]></title>
      <url>%2Fblog%2F2017%2F03%2F16%2FRabbitMQ%E4%B8%8ESpring%E7%BB%93%E5%90%88%E8%AE%B2%E8%A7%A3(%E4%BD%BF%E7%94%A8amqp%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE)%2F</url>
      <content type="text"><![CDATA[RabbitMQ是一个消息代理。它的核心原理非常简单：接收和发送消息。你可以把它想像成一个邮局：你把信件放入邮箱，邮递员就会把信件投递到你的收件人处。在这个比喻中，RabbitMQ是一个邮箱、邮局、邮递员。RabbitMQ和邮局的主要区别是，它处理的不是纸，而是接收、存储和发送二进制的数据——消息。一般提到RabbitMQ和消息。RabbitMQ中文文档： 传送门 rabbitMQ简介rabbitMQ的应用场景你是否遇到过两个（多个）系统间需要通过定时任务来同步某些数据？你是否在为异构系统的不同进程间相互调用、通讯的问题而苦恼、挣扎？如果是，那么恭喜你，消息服务让你可以很轻松地解决这些问题。消息服务擅长于解决多系统、异构系统间的数据交换（消息通知/通讯）问题，你也可以把它用于系统间服务的相互调用（RPC）。 rabbitMQ的优点 基于erlang语言开发具有高可用高并发的优点，适合集群服务器。 健壮、稳定、易用、跨平台、支持多种语言、文档齐全。 有消息确认机制和持久化机制，可靠性高。 开源 其他MQ的优势： Apache ActiveMQ曝光率最高，但是可能会丢消息。 ZeroMQ延迟很低、支持灵活拓扑，但是不支持消息持久化和崩溃恢复。 几个相关概念说明AMQP 即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 RabbitMQ 是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 producer&amp;Consumer producer指的是消息生产者，consumer消息的消费者。 Queue 消息队列，提供了FIFO的处理机制，具有缓存消息的能力。rabbitmq中，队列消息可以设置为持久化，临时或者自动删除。 设置为持久化的队列，queue中的消息会在server本地硬盘存储一份，防止系统crash，数据丢失 设置为临时队列，queue中的数据在系统重启之后就会丢失 设置为自动删除的队列，当不存在用户连接到server，队列中的数据会被自动删除Exchange Exchange类似于数据通信网络中的交换机，提供消息路由策略。rabbitmq中，producer不是通过信道直接将消息发送给queue，而是先发送给Exchange。一个Exchange可以和多个Queue进行绑定，producer在传递消息的时候，会传递一个ROUTING_KEY，Exchange会根据这个ROUTING_KEY按照特定的路由算法，将消息路由给指定的queue。和Queue一样，Exchange也可设置为持久化，临时或者自动删除。 Exchange有4种类型：direct(默认)，fanout，topic，和headers，不同类型的Exchange转发消息的策略有所区别： Direct 直接交换器，工作方式类似于单播，Exchange会将消息发送完全匹配ROUTING_KEY的Queue fanout 广播是式交换器，不管消息的ROUTING_KEY设置为什么，Exchange都会将消息转发给所有绑定的Queue。 topic 主题交换器，工作方式类似于组播，Exchange会将消息转发和ROUTING_KEY匹配模式相同的所有队列，比如，ROUTING_KEY为user.stock的Message会转发给绑定匹配模式为 .stock,user.stock， . 和#.user.stock.#的队列。（ 表是匹配一个任意词组，#表示匹配0个或多个词组） headers 消息体的header匹配（ignore） Binding 所谓绑定就是将一个特定的 Exchange 和一个特定的 Queue 绑定起来。Exchange 和Queue的绑定可以是多对多的关系。 virtual host 在rabbitmq server上可以创建多个虚拟的message broker，又叫做virtual hosts (vhosts)。每一个vhost本质上是一个mini-rabbitmq server，分别管理各自的exchange，和bindings。vhost相当于物理的server，可以为不同app提供边界隔离，使得应用安全的运行在不同的vhost实例上，相互之间不会干扰。producer和consumer连接rabbit server需要指定一个vhost。 消息队列的使用过程 客户端连接到消息队列服务器，打开一个channel。 客户端声明一个exchange，并设置相关属性。 客户端声明一个queue，并设置相关属性。 客户端使用routing key，在exchange和queue之间建立好绑定关系。 客户端投递消息到exchange。 exchange接收到消息后，就根据消息的key和已经设置的binding，进行消息路由，将消息投递到一个或多个队列里 环境配置与安装Erlang环境安装windows下搭建教程：http://blog.csdn.net/u014308482/article/details/53994401 Linux下搭建教程：http://blog.csdn.net/evankaka/article/details/50495437 我只在本机windows环境下使用安装版搭建测试，具体如果大家在安装环境时遇到问题多百度一下，过程还是很简单的。 Rbbitmq与Spring结合使用整合依旧是基于之前教程中所搭建的SSM框架，以下是新增的项目结构： 在pom.xml中添加依赖123456&lt;!--rabbitmq依赖,amqp队列服务 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 这里要注意，如果使用高版本的spring-rabbit，比如1.7.0，会抛一个org.springframework.util.backoff.BackOff的空指针异常，这里google了一个老外的回答，貌似这个类只在4.1.X的版本上才会有，所以要更改spring核心类的版本到4.1.x以上才可以使用。 MessageProducer 消息生产者12345678910111213141516171819202122package com.zh.producer;import javax.annotation.Resource;import org.springframework.amqp.core.AmqpTemplate;import org.springframework.stereotype.Service;/** * 功能概要：消息产生,提交到队列中去 * */@Servicepublic class MessageProducer &#123; @Resource private AmqpTemplate amqpTemplate; public void sendMessage(Object message)&#123; System.out.println("我是生产者，我发送了消息"+message); amqpTemplate.convertAndSend("queueTestKey",message); &#125;&#125; MessageConsumer 消息消费者1234567891011121314151617181920package com.zh.consumer;import org.springframework.amqp.core.Message;import org.springframework.amqp.core.MessageListener;import org.springframework.stereotype.Service;/** * 功能概要：消费接收 * */@Servicepublic class MessageConsumer implements MessageListener &#123; public void onMessage(Message message) &#123; System.out.println("我是消费者，我接收到了消息："+message); &#125;&#125; rabbitMq.xml配置信息123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:rabbit="http://www.springframework.org/schema/rabbit" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit-1.0.xsd"&gt; &lt;!--配置connection-factory，指定连接rabbit server参数 --&gt; &lt;rabbit:connection-factory id="connectionFactoryRabbit" username="guest" password="guest" host="localhost" port="5672" /&gt; &lt;!--定义rabbit template用于数据的接收和发送 --&gt; &lt;rabbit:template id="amqpTemplate" connection-factory="connectionFactoryRabbit" exchange="exchangeTest" /&gt; &lt;!--通过指定下面的admin信息，当前producer中的exchange和queue会在rabbitmq服务器上自动生成 --&gt; &lt;rabbit:admin connection-factory="connectionFactoryRabbit" /&gt; &lt;!--定义queue --&gt; &lt;rabbit:queue name="queueTest" durable="true" auto-delete="false" exclusive="false" /&gt; &lt;!-- 定义direct exchange，绑定queueTest --&gt; &lt;rabbit:direct-exchange name="exchangeTest" durable="true" auto-delete="false"&gt; &lt;rabbit:bindings&gt; &lt;rabbit:binding queue="queueTest" key="queueTestKey"&gt;&lt;/rabbit:binding&gt; &lt;/rabbit:bindings&gt; &lt;/rabbit:direct-exchange&gt; &lt;!-- 消息接收者 --&gt; &lt;bean id="messageReceiver" class="com.zh.consumer.MessageConsumer"&gt;&lt;/bean&gt; &lt;!-- queue litener 观察 监听模式 当有消息到达时会通知监听在对应的队列上的监听对象--&gt; &lt;rabbit:listener-container connection-factory="connectionFactoryRabbit"&gt; &lt;rabbit:listener queues="queueTest" ref="messageReceiver"/&gt; &lt;/rabbit:listener-container&gt; &lt;/beans&gt; 这里我之前将connection-factory的id配置成了connectionFactory，结果报了一个无法注入的异常，排查了很久，发现是我注册redies的服务中心时，用的id也是connectionFactory，两个id相同，导致出现冲突，修改了rabbit的connection-factory的id为connectionFactoryRabbit，问题解决。 spring集成rabbitMq在spring的配置文件(spring-mybatis.xm)中引入rabbitmq配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd"&gt; &lt;!-- cxf整合Spring start--&gt; &lt;import resource="classpath:META-INF/cxf/cxf.xml"/&gt; &lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml"/&gt; &lt;!-- 自动扫描webService --&gt; &lt;context:component-scan base-package="com.zh.cxf" /&gt; &lt;!-- 定义webservice的发布接口 --&gt; &lt;jaxws:endpoint implementor="#helloWorld" address="/HelloWorld"&gt; &lt;/jaxws:endpoint&gt; &lt;!--cxf整合Spring end --&gt; &lt;!-- 自动扫描 --&gt; &lt;!-- 扫描指定package下所有带有如@controller,@services,@resource,@ods并把所注释的注册为Spring Beans --&gt; &lt;context:component-scan base-package="com.zh" /&gt; &lt;!-- 引入properties配置文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:config/jdbc.properties&lt;/value&gt; &lt;value&gt;classpath:config/redis.properties&lt;/value&gt; &lt;!--要是有多个配置文件，只需在这里继续添加即可 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- dbcp dataSource 配置 &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- druid dataSource 配置 --&gt; &lt;!-- 数据源1 --&gt; &lt;bean id="ssmdataSource1" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;url1&#125;" /&gt; &lt;property name="username" value="$&#123;username1&#125;" /&gt; &lt;property name="password" value="$&#123;password1&#125;" /&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;" /&gt; &lt;property name="filters" value="$&#123;filters&#125;" /&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;" /&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;" /&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;" /&gt; &lt;!-- 用来检测连接是否有效的sql，要求是一个查询语句。 --&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;" /&gt; &lt;!-- 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。 --&gt; &lt;property name="testWhileIdle" value="$&#123;testWhileIdle&#125;" /&gt; &lt;!-- 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 --&gt; &lt;property name="testOnBorrow" value="$&#123;testOnBorrow&#125;" /&gt; &lt;!-- 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 --&gt; &lt;property name="testOnReturn" value="$&#123;testOnReturn&#125;" /&gt; &lt;!-- 要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100 --&gt; &lt;property name="maxOpenPreparedStatements" value="$&#123;maxOpenPreparedStatements&#125;" /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;" /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;" /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name="logAbandoned" value="$&#123;logAbandoned&#125;" /&gt; &lt;/bean&gt; &lt;!-- 数据源2 --&gt; &lt;bean id="ssmdataSource2" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;url2&#125;" /&gt; &lt;property name="username" value="$&#123;username2&#125;" /&gt; &lt;property name="password" value="$&#123;password2&#125;" /&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;" /&gt; &lt;property name="filters" value="$&#123;filters&#125;" /&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;" /&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;" /&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;" /&gt; &lt;!-- 用来检测连接是否有效的sql，要求是一个查询语句。 --&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;" /&gt; &lt;!-- 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。 --&gt; &lt;property name="testWhileIdle" value="$&#123;testWhileIdle&#125;" /&gt; &lt;!-- 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 --&gt; &lt;property name="testOnBorrow" value="$&#123;testOnBorrow&#125;" /&gt; &lt;!-- 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 --&gt; &lt;property name="testOnReturn" value="$&#123;testOnReturn&#125;" /&gt; &lt;!-- 要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100 --&gt; &lt;property name="maxOpenPreparedStatements" value="$&#123;maxOpenPreparedStatements&#125;" /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;" /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;" /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name="logAbandoned" value="$&#123;logAbandoned&#125;" /&gt; &lt;/bean&gt; &lt;!-- Spring的依赖注入方式将两个数据源设置进targetDataSources。 --&gt; &lt;bean id="dataSource" class="com.zh.util.DynamicDataSource"&gt; &lt;property name="targetDataSources"&gt; &lt;map key-type="java.lang.String"&gt; &lt;entry key="sss1" value-ref="ssmdataSource1"/&gt; &lt;entry key="sss2" value-ref="ssmdataSource2"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--默认数据源--&gt; &lt;property name="defaultTargetDataSource" ref="ssmdataSource1"/&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:com/zh/mapping/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zh.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理) 配置spring的PlatformTransactionManager，名字为默认值 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 事物切面配置 --&gt; &lt;tx:advice id="advice" transaction-manager="transactionManager" &gt; &lt;tx:attributes&gt; &lt;tx:method name="update*" propagation="REQUIRED" read-only="false" rollback-for="java.lang.Exception"/&gt; &lt;tx:method name="insert" propagation="REQUIRED" read-only="false" rollback-for="java.lang.Exception"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 事务拦截器，拦截com.zh.service下所有方法 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="testService" expression="execution (* com.zh.service.*.*(..))"/&gt; &lt;aop:advisor advice-ref="advice" pointcut-ref="testService"/&gt; &lt;/aop:config&gt; &lt;!-- Redis和缓存配置开始 --&gt; &lt;!-- jedis 配置 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig" &gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt; &lt;property name="maxWaitMillis" value="$&#123;redis.maxWait&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;" /&gt; &lt;/bean &gt; &lt;!-- redis服务器中心 --&gt; &lt;bean id="connectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;property name="poolConfig" ref="poolConfig" /&gt; &lt;property name="port" value="$&#123;redis.port&#125;" /&gt; &lt;property name="hostName" value="$&#123;redis.host&#125;" /&gt; &lt;!-- &lt;property name="password" value="$&#123;redis.password&#125;" /&gt; --&gt; &lt;property name="timeout" value="$&#123;redis.timeout&#125;" &gt;&lt;/property&gt; &lt;/bean &gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" &gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="keySerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="valueSerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;/bean &gt; &lt;!-- cache配置插入、更新数据时从redis中清除缓存 --&gt; &lt;bean id="putCache" class="com.zh.redis.cache.PutCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- cache配置从redis获取缓存数据 --&gt; &lt;bean id="getCache" class="com.zh.redis.cache.GetCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置结束 --&gt; &lt;!-- Shiro 开始 --&gt; &lt;!-- 配置自定义Realm --&gt; &lt;bean id="myRealm" class="com.zh.shiro.MyRealm"/&gt; &lt;!-- 安全管理器 --&gt; &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="myRealm"/&gt; &lt;/bean&gt; &lt;!-- Shiro过滤器 核心--&gt; &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;!-- Shiro的核心安全接口,这个属性是必须的 --&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;!-- 身份认证失败，则跳转到登录页面的配置 --&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;!-- 权限认证失败，则跳转到指定页面 --&gt; &lt;property name="unauthorizedUrl" value="/nopower.jsp"/&gt; &lt;!-- Shiro连接约束配置,即过滤链的定义 --&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--anon 表示匿名访问，不需要认证以及授权--&gt; /shiroUser/loginAdmin=anon &lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt; /shiroUser/admin*=authc /shiroUser/student=roles[teacher] /shiroUser/teacher=perms["user:create"] &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt; &lt;bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/&gt; &lt;!-- 开启Shiro注解 --&gt; &lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor"/&gt; &lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;/bean&gt; &lt;!-- Shiro 结束 --&gt; &lt;!-- 引入rabbitmq配置 --&gt; &lt;import resource="classpath*:config/rabbitmq.xml" /&gt; &lt;/beans&gt; 主要是以下这两句配置: 12345&lt;!-- 自动扫描 --&gt; &lt;!-- 扫描指定package下所有带有如@controller,@services,@resource,@ods并把所注释的注册为Spring Beans --&gt;&lt;context:component-scan base-package="com.zh" /&gt; &lt;!-- 引入rabbitmq配置 --&gt;&lt;import resource="classpath*:config/rabbitmq.xml" /&gt; 测试我在这使用Maven编译一下mavenDemo这个项目，将编译好的war包发布到tomcat下，使用tomcat进行启动。同时在eclipse使用jetty启动mavenDemo，确保其都在启动状态。在其中一个项目中发送消息到rabbitMq服务器。由rabbitMq将消息分发到我的两个项目。 两个项目同时启动后: WEB控制台监听到名称为queueTest的队列： 点击连接模块也可以发现有两个连接在线： 点击queueTest队列进入详情页面，发现监听到两个消费者，分别对应我的mavenDemo项目和rabbit_c2项目 在我eclipse的mavenDemo项目中执行单元测试： 测试类 MessageTest.java： 1234567891011121314151617181920212223242526272829303132333435363738package com.javen.testmybatis;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.zh.producer.MessageProducer;/** * 功能概要： * * @author zhanghao */@RunWith(SpringJUnit4ClassRunner.class) //表示继承了SpringJUnit4ClassRunner类 @ContextConfiguration(locations = &#123;"classpath:spring-mybatis.xml"&#125;) public class MessageTest &#123; @Resource private MessageProducer messageProducer; @Test public void should_send_a_amq_message() throws Exception &#123; int a = Integer.MAX_VALUE; while (a &gt; 0) &#123; messageProducer.sendMessage("Hello World:" + a--); try &#123; //暂停一下，好让消息消费者去取消息打印出来 Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 执行JUnit单元测试控制台输出：1234567我是生产者，我发送了消息Hello World:2147483647我是生产者，我发送了消息Hello World:2147483646我是生产者，我发送了消息Hello World:2147483645我是生产者，我发送了消息Hello World:2147483644我是生产者，我发送了消息Hello World:2147483643我是生产者，我发送了消息Hello World:2147483642.... MavenDemo控制台输出：123456I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483647&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=1, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483644&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=2, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483641&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=3, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483638&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=4, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483635&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=5, messageCount=0])...... 这时我们再来看下另外一个的用tomcat直接发布的项目，控制台输出:1234567I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483626&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=8, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483623&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=9, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483620&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=10, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483617&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=11, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483614&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=12, messageCount=0])I&apos;m eclipse MavenDemo consumer：(Body:&apos;Hello World:2147483611&apos;MessageProperties [headers=&#123;&#125;, timestamp=null, messageId=null, userId=null, appId=null, clusterId=null, type=null, correlationId=null, replyTo=null, contentType=text/plain, contentEncoding=UTF-8, contentLength=0, deliveryMode=PERSISTENT, expiration=null, priority=0, redelivered=false, receivedExchange=exchangeTest, receivedRoutingKey=queueTestKey, deliveryTag=13, messageCount=0])..... 测试通过，以上就是使用RabbitMQ与Spring整合并测试通过的全部流程。 项目地址：https://github.com/mhkzh/SSM 个人博客地址：http://zhfeat.cc GitHub地址：https://github.com/mhkzh/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[spring事务配置声明式事务管理和基于注解的使用]]></title>
      <url>%2Fblog%2F2017%2F03%2F08%2Fspring%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%92%8C%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。 Spring编程式事务管理和声明式事务管理spring支持编程式事务管理和声明式事务管理两种方式。 编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。 声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。 显然声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要加上注解就可以获得完全的事务支持。和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。 声明式事务管理也有两种常用的方式，一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用，更清爽。 spring事务特性spring所有的事务管理策略类都继承自org.springframework.transaction.PlatformTransactionManager接口 其中TransactionDefinition接口定义以下特性： 事务隔离级别隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATIONREADCOMMITTED。 TransactionDefinition.ISOLATIONREADUNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。 TransactionDefinition.ISOLATIONREADCOMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 TransactionDefinition.ISOLATIONREPEATABLEREAD：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。 TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 事务传播行为所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量： TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。 TransactionDefinition.PROPAGATIONREQUIRESNEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 TransactionDefinition.PROPAGATIONNOTSUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。 TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 TransactionDefinition.PROPAGATIONNESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATIONREQUIRED。 事务超时所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。 默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是none，没有超时限制。 事务只读属性只读事务用于客户代码只读但不修改数据的情形，只读事务用于特定情景下的优化，比如使用Hibernate的时候。 默认为读写事务。 “只读事务”并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。但是你非要在“只读事务”里面修改数据，也并非不可以，只不过对于数据一致性的保护不像“读写事务”那样保险而已。因此，“只读事务”仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可。 spring事务回滚规则指示spring事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常。spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务。 默认配置下，spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。可以明确的配置在抛出那些异常时回滚事务，包括checked异常。也可以明确定义那些异常抛出时不回滚事务。还可以编程性的通过setRollbackOnly()方法来指示一个事务必须回滚，在调用完setRollbackOnly()后你所能执行的唯一操作就是回滚。 基于注解的声明式事务管理配置@Transactional以下配置基于本博客SSM框架整合系列所搭建的框架 spring-mybatis.xml123456789101112131415161718 &lt;!-- (事务管理) 配置spring的PlatformTransactionManager，名字为默认值 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- 事物切面配置 --&gt; &lt;tx:advice id="advice" transaction-manager="transactionManager" &gt; &lt;tx:attributes&gt; &lt;tx:method name="update*" propagation="REQUIRED" read-only="false" rollback-for="java.lang.Exception"/&gt; &lt;tx:method name="insert" propagation="REQUIRED" read-only="false" rollback-for="java.lang.Exception"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 事务拦截器，拦截com.zh.service下所有方法 --&gt;&lt;aop:config&gt; &lt;aop:pointcut id="testService" expression="execution (* com.zh.service.*.*(..))"/&gt; &lt;aop:advisor advice-ref="advice" pointcut-ref="testService"/&gt; &lt;/aop:config&gt; 添加tx名字空间12345678910111213141516171819202122&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd "&gt; MyBatis自动参与到spring事务管理中，无需额外配置，只要org.mybatis.spring.SqlSessionFactoryBean引用的数据源与DataSourceTransactionManager引用的数据源一致即可，否则事务管理会不起作用。 @Transactional注解@Transactional属性 属性 类型 描述 value String 可选的限定描述符，指定使用的事务管理器 propagation enum: Propagation 可选的事务传播行为设置 isolation enum: Isolation 可选的事务隔离级别设置 readOnly boolean 读写或只读事务，默认读写 timeout int (in seconds granularity) 事务超时时间设置 rollbackFor Class对象数组，必须继承自Throwable 导致事务回滚的异常类数组 rollbackForClassName 类名数组，必须继承自Throwable 导致事务回滚的异常类名字数组 noRollbackFor Class对象数组，必须继承自Throwable 不会导致事务回滚的异常类数组 noRollbackForClassName 类名数组，必须继承自Throwable 不会导致事务回滚的异常类名字数组 用法@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。 虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。 默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。 例子（不以本项目举例，我的源码中有单元测试，可以自己自己体验一下）： 123456789@Autowired private MyBatisDao dao; @Transactional @Override public void insert(Test test) &#123; dao.insert(test); throw new RuntimeException("test");//抛出unchecked异常，触发事物，回滚 &#125; noRollbackFor 1234567@Transactional(noRollbackFor=RuntimeException.class) @Override public void insert(Test test) &#123; dao.insert(test); //抛出unchecked异常，触发事物，noRollbackFor=RuntimeException.class,不回滚 throw new RuntimeException("test"); &#125; 类，当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性 12345678910111213@Transactional public class MyBatisServiceImpl implements MyBatisService &#123; @Autowired private MyBatisDao dao; @Override public void insert(Test test) &#123; dao.insert(test); //抛出unchecked异常，触发事物，回滚 throw new RuntimeException("test"); &#125; propagation=Propagation.NOT_SUPPORTED123456@Transactional(propagation=Propagation.NOT_SUPPORTED) @Override public void insert(Test test) &#123; //事物传播行为是PROPAGATION_NOT_SUPPORTED，以非事务方式运行，不会存入数据库 dao.insert(test); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单切换数据源]]></title>
      <url>%2Fblog%2F2017%2F03%2F08%2F%E7%AE%80%E5%8D%95%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
      <content type="text"><![CDATA[在现在开发的过程中应该大多数朋友都有遇到过切换数据源的需求。比如现在常用的数据库读写分离，或者就是有两个数据库的情况，这些都需要用到切换数据源。 手动切换数据源源码剖析使用Spring的AbstractRoutingDataSource类来进行拓展多数据源。 该类就相当于一个dataSource的路由，用于根据key值来进行切换对应的dataSource。 下面简单来看下AbstractRoutingDataSource类的几段关键源码： 123456789101112131415161718192021222324252627282930313233343536@Overridepublic Connection getConnection() throws SQLException &#123; return determineTargetDataSource().getConnection();&#125;@Overridepublic Connection getConnection(String username, String password) throws SQLException &#123; return determineTargetDataSource().getConnection(username, password);&#125;/** * Retrieve the current target DataSource. Determines the * &#123;@link #determineCurrentLookupKey() current lookup key&#125;, performs * a lookup in the &#123;@link #setTargetDataSources targetDataSources&#125; map, * falls back to the specified * &#123;@link #setDefaultTargetDataSource default target DataSource&#125; if necessary. * @see #determineCurrentLookupKey() */protected DataSource determineTargetDataSource() &#123; Assert.notNull(this.resolvedDataSources, "DataSource router not initialized"); Object lookupKey = determineCurrentLookupKey(); DataSource dataSource = this.resolvedDataSources.get(lookupKey); if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) &#123; dataSource = this.resolvedDefaultDataSource; &#125; if (dataSource == null) &#123; throw new IllegalStateException("Cannot determine target DataSource for lookup key [" + lookupKey + "]"); &#125; return dataSource;&#125;/** * Determine the current lookup key. This will typically be * implemented to check a thread-bound transaction context. * &lt;p&gt;Allows for arbitrary keys. The returned key needs * to match the stored lookup key type, as resolved by the * &#123;@link #resolveSpecifiedLookupKey&#125; method. */protected abstract Object determineCurrentLookupKey(); 可以看到其中获取链接的方法getConnection()调用的determineTargetDataSource则是关键方法。该方法用于返回我们使用的数据源。 其中呢又是determineCurrentLookupKey()方法来返回当前数据源的key值。之后通过该key值在resolvedDataSources这个map中找到对应的value(该value就是数据源)。 resolvedDataSources这个map则是在： 123456789101112131415@Overridepublic void afterPropertiesSet() &#123; if (this.targetDataSources == null) &#123; throw new IllegalArgumentException("Property 'targetDataSources' is required"); &#125; this.resolvedDataSources = new HashMap&lt;Object, DataSource&gt;(this.targetDataSources.size()); for (Map.Entry&lt;Object, Object&gt; entry : this.targetDataSources.entrySet()) &#123; Object lookupKey = resolveSpecifiedLookupKey(entry.getKey()); DataSource dataSource = resolveSpecifiedDataSource(entry.getValue()); this.resolvedDataSources.put(lookupKey, dataSource); &#125; if (this.defaultTargetDataSource != null) &#123; this.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource); &#125;&#125; 这个方法通过targetDataSources这个map来进行赋值的。targetDataSources则是我们在配置文件中进行赋值的，下面会讲到。 再来看看determineCurrentLookupKey()方法，从protected来修饰就可以看出是需要我们来进行重写的。 DynamicDataSource 和 DataSourceHolder于是我新增了DynamicDataSource类，代码如下： 12345678910111213141516package com.zh.util;import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;public class DynamicDataSource extends AbstractRoutingDataSource&#123; /** 使用Spring的AbstractRoutingDataSource类来进行拓展多数据源。 该类就相当于一个dataSource的路由，用于根据key值来进行切换对应的dataSource。 **/ @Override protected Object determineCurrentLookupKey() &#123; return DataSourceHolder.getDataSources(); &#125;&#125; 代码很简单，继承了AbstractRoutingDataSource类并重写了其中的determineCurrentLookupKey()方法。 这里直接用DataSourceHolder返回了一个数据源。 DataSourceHolder代码如下： 123456789101112131415161718package com.zh.util;/** * 数据源 * @author zh * */public class DataSourceHolder &#123; //这里我使用了ThreadLocal来保存了数据源，提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程。 private static final ThreadLocal&lt;String&gt; dataSources = new ThreadLocal&lt;String&gt;(); public static void setDataSources(String dataSource) &#123; dataSources.set(dataSource); &#125; public static String getDataSources() &#123; return dataSources.get(); &#125;&#125; 这里我使用了ThreadLocal来保存了数据源，关于ThreadLocal的知识点可以查看以下这篇文章解密ThreadLocal 之后在Spring的配置文件中配置我们的数据源，就是上文讲到的为targetDataSources赋值：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 &lt;!-- 数据源1 --&gt; &lt;bean id="ssmdataSource1" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;url1&#125;" /&gt; &lt;property name="username" value="$&#123;username1&#125;" /&gt; &lt;property name="password" value="$&#123;password1&#125;" /&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;" /&gt; &lt;property name="filters" value="$&#123;filters&#125;" /&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;" /&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;" /&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;" /&gt; &lt;!-- 用来检测连接是否有效的sql，要求是一个查询语句。 --&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;" /&gt; &lt;!-- 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。 --&gt; &lt;property name="testWhileIdle" value="$&#123;testWhileIdle&#125;" /&gt; &lt;!-- 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 --&gt; &lt;property name="testOnBorrow" value="$&#123;testOnBorrow&#125;" /&gt; &lt;!-- 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 --&gt; &lt;property name="testOnReturn" value="$&#123;testOnReturn&#125;" /&gt; &lt;!-- 要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100 --&gt; &lt;property name="maxOpenPreparedStatements" value="$&#123;maxOpenPreparedStatements&#125;" /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;" /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;" /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name="logAbandoned" value="$&#123;logAbandoned&#125;" /&gt; &lt;/bean&gt; &lt;!-- 数据源2 --&gt; &lt;bean id="ssmdataSource2" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;url2&#125;" /&gt; &lt;property name="username" value="$&#123;username2&#125;" /&gt; &lt;property name="password" value="$&#123;password2&#125;" /&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;" /&gt; &lt;property name="filters" value="$&#123;filters&#125;" /&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;" /&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;" /&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;" /&gt; &lt;!-- 用来检测连接是否有效的sql，要求是一个查询语句。 --&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;" /&gt; &lt;!-- 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。 --&gt; &lt;property name="testWhileIdle" value="$&#123;testWhileIdle&#125;" /&gt; &lt;!-- 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 --&gt; &lt;property name="testOnBorrow" value="$&#123;testOnBorrow&#125;" /&gt; &lt;!-- 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 --&gt; &lt;property name="testOnReturn" value="$&#123;testOnReturn&#125;" /&gt; &lt;!-- 要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100 --&gt; &lt;property name="maxOpenPreparedStatements" value="$&#123;maxOpenPreparedStatements&#125;" /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;" /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;" /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name="logAbandoned" value="$&#123;logAbandoned&#125;" /&gt; &lt;/bean&gt; 这里分别配置了两个数据源：ssmdataSource1和ssmdataSource2。之后再通过Spring的依赖注入方式将两个数据源设置进targetDataSources。1234567891011&lt;!-- Spring的依赖注入方式将两个数据源设置进targetDataSources。 --&gt;&lt;bean id="dataSource" class="com.zh.util.DynamicDataSource"&gt; &lt;property name="targetDataSources"&gt; &lt;map key-type="java.lang.String"&gt; &lt;entry key="sss1" value-ref="ssmdataSource1"/&gt; &lt;entry key="sss2" value-ref="ssmdataSource2"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--默认数据源--&gt; &lt;property name="defaultTargetDataSource" ref="ssmdataSource1"/&gt; &lt;/bean&gt; 接下来就是在每次调用数据库之前我们都要先通过DataSourceHolder来设置当前的数据源。看下demo： 123456 @Testpublic void selectByPrimaryKey() throws Exception &#123; DataSourceHolder.setDataSources(Constants.DATASOURCE_ONE); User user = userService.getUserByIdTest(1); System.out.println(user.getUserName());&#125; 这样在查询数据库之前，用setDataSources根据key设置了数据源，那么就会以该数据源操作数据库，如果不设置，就会以我们设置的默认数据源来操作数据库。 动态切换数据源使用动态获取数据源的思路是，使用AOP切面，在进入我们的方法前根据我们的包名对我们要查询的数据源进行判断,从而达到动态切换数据源的目的。 Spring中的事务是通过aop来实现的，当我们自己写aop拦截的时候，会遇到跟spring的事务aop执行的先后顺序问题，比如说动态切换数据源的问题，如果事务在前，数据源切换在后，会导致数据源切换失效，所以就用到了Order（排序）这个关键字。 在这个地方遇到了几个异常，导致aop切面无法正常拦截，目前手动切换数据源的方式暂且够用，后续会补上具体的开发步骤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSONP跨域传输]]></title>
      <url>%2Fblog%2F2017%2F03%2F07%2FJSONP%E8%B7%A8%E5%9F%9F%E4%BC%A0%E8%BE%93%2F</url>
      <content type="text"><![CDATA[什么是跨域问题？只要协议、域名、端口有任何一个不同，都被当作是不同的域 只要是在不同域中是无法进行通信的。 基于以上的的出发点，我们又有跨域共享资源的需求(譬如现在流行的前后端分离之后分别部署的情况)，本博客中采用的办法是JSONP。 JSONP其实网上关于JSONP的讲解有很多，但却千篇一律，而且云里雾里，对于很多刚接触的人来讲理解起来有些困难，小可不才，试着用自己的方式来阐释一下这个问题，看看是否有帮助。 一个众所周知的问题，Ajax直接请求普通文件存在跨域无权限访问的问题，甭管你是静态页面、动态网页、web服务、WCF，只要是跨域请求，一律不准； 不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如script、img、iframe等html标记）； 于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理； 恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据； 这样子解决方案就呼之欲出了，web客户端通过与调用脚本(script)一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。 客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。 为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 web端(这里我直接在本地创建了一个html): 1234567891011121314151617181920212223242526272829&lt;html lang="zh"&gt;&lt;head&gt; &lt;script src="https://code.jquery.com/jquery-3.1.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(document).ready(function()&#123; $.ajax(&#123; type: "get", async: false, url: "http://localhost:8000/user/jsonpInfo?callback=getUser&amp;userId=1", dataType: "jsonp", jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(//一般默认为:callback) jsonpCallback:"getUser",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据 success: function(json)&#123; /** * 获得服务器返回的信息。 * 可以做具体的业务处理。 */ alert('用户信息：ID： ' + json.id + ' ，姓名： ' + json.userName + '。'); &#125;, error: function()&#123; alert('fail'); &#125; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body oncontextmenu="return false"&gt;&lt;/body&gt;&lt;/html&gt; jquery在处理jsonp类型的ajax时（还是忍不住吐槽，虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用。 服务端代码： 12345678//跨域问题@RequestMapping(value = "/jsonpInfo",method = &#123; RequestMethod.GET &#125;)@ResponseBodypublic Object jsonpInfo(String callback,Integer userId) throws IOException &#123; User user = userService.getUserByIdTest(userId); JSONPObject jsonpObject = new JSONPObject(callback,user) ; return jsonpObject ;&#125; 后端采用了jackson中的JSONPObject这个类的一个构造方法，只需要将callback字段和需要转成JSON字符串的对象放进去即可。需要主要的是需要使用@ResponseBody注解才能成功返回。 直接打开html进行测试 如上如所示，成功调用服务端返回了数据 使用谷歌进行调试，查看返回的json数据： 可以看到我们所传递的callback参数带着查询的数据又原封不动的返回给我们了，这样的话即使我们不使用JQuery给我封装好的函数，我们自定义一个和callback名称一样的函数一样是可以解析其中的数据的，只是Jquery帮我们做了而已。 总结 ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装； 但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加script标签来调用服务器提供的js脚本。 所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变这一点！ 同样JSONP也是有缺点的，比如：只支持GET方式的HTTP请求。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebServie集成]]></title>
      <url>%2Fblog%2F2017%2F03%2F07%2FWebServie%E9%9B%86%E6%88%90%2F</url>
      <content type="text"><![CDATA[WebService到底是什么？ 一言以蔽之：WebService是一种跨编程语言和跨操作系统平台的远程调用技术。 所谓跨编程语言和跨操作平台，就是说服务端程序采用java编写，客户端程序则可以采用其他编程语言编写，反之亦然！跨操作系统平台则是指服务端程序和客户端程序可以在不同的操作系统上运行。 所谓远程调用，就是一台计算机a上的一个程序可以调用到另外一台计算机b上的一个对象的方法，譬如，银联提供给商场的pos刷卡系统，商场的POS机转账调用的转账方法的代码其实是跑在银行服务器上。再比如，amazon，天气预报系统，淘宝网，校内网，百度等把自己的系统服务以webservice服务的形式暴露出来，让第三方网站和程序可以调用这些服务功能，这样扩展了自己系统的市场占有率，往大的概念上吹，就是所谓的SOA应用。 其实可以从多个角度来理解WebService，从表面上看，WebService就是一个应用程序向外界暴露出一个能通过Web进行调用的API，也就是说能用编程的方法通过Web来调用这个应用程序。我们把调用这个WebService的应用程序叫做客户端，而把提供这个WebService的应用程序叫做服务端。从深层次看，WebService是建立可互操作的分布式应用程序的新平台，是一个平台，是一套标准。它定义了应用程序如何在Web上实现互操作性，你可以用任何你喜欢的语言，在任何你喜欢的平台上写Web service ，只要我们可以通过Web service标准对这些服务进行查询和访问。 WebService平台技术 XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术。 XML+XSD： WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务对象的返回结果是什么）。XML是WebService平台中表示数据的格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关的。无关性是比技术优越性更重要的：软件厂商是不会选择一个由竞争对手所发明的技术的。 XML解决了数据表示的问题，但它没有定义一套标准的数据类型，更没有说怎么去扩展这套数据类型。例如，整形数到底代表什么？16位，32位，64位？这些细节对实现互操作性很重要。XML Schema(XSD)就是专门解决这个问题的一套标准。它定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。WebService平台就是用XSD来作为其数据类型系统的。当你用某种语言(如VB.NET或C#)来构造一个Web service时，为了符合WebService标准，所有你使用的数据类型都必须被转换为XSD类型。你用的工具可能已经自动帮你完成了这个转换，但你很可能会根据你的需要修改一下转换过程。 SOAP： WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议。SOAP提供了标准的RPC方法来调用Web Service。 SOAP协议 = HTTP协议 + XML数据格式 SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。打个比喻：HTTP就是普通公路，XML就是中间的绿色隔离带和两边的防护栏，SOAP就是普通公路经过加隔离带和防护栏改造过的高速公路。 WSDL： 好比我们去商店买东西，首先要知道商店里有什么东西可买，然后再来购买，商家的做法就是张贴广告海报。 WebService也一样，WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。 WSDL(Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。它是WebService客户端和服务器端都能理解的标准格式。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。一些最新的开发工具既能根据你的Web service生成WSDL文档，又能导入WSDL文档，生成调用相应WebService的代理类代码。 WSDL文件保存在Web服务器上，通过一个url地址就可以访问到它。客户端要调用一个WebService服务之前，要知道该服务的WSDL文件的地址。WebService服务提供商可以通过两种方式来暴露它的WSDL文件地址：1.注册到UDDI服务器，以便被人查找；2.直接告诉给客户端调用者。 WebService开发WebService开发可以分为服务器端开发和客户端开发两个方面： 服务端开发：把公司内部系统的业务方法发布成WebService服务，供远程合作单位和个人调用。(借助一些WebService框 架可以很轻松地把自己的业务对象发布成WebService服务，Java方面的典型WebService框架包括：axis，xfire，cxf等，java ee服务器通常也支持发布WebService服务，例如JBoss。) 客户端开发：调用别人发布的WebService服务，大多数人从事的开发都属于这个方面，例如，调用天气预报WebService服务。（使用厂商的WSDL2Java之类的工具生成静态调用的代理类代码；使用厂商提供的客户端编程API类；使用SUN公司早期标准的jax-rpc开发包；使用SUN公司最新标准的jax-ws开发包。当然SUN已被ORACLE收购) WebService的工作调用原理：对客户端而言，我们给这各类WebService客户端API传递wsdl文件的url地址，这些API就会创建出底层的代理类，我调用这些代理，就可以访问到webservice服务。代理类把客户端的方法调用变成soap格式的请求数据再通过HTTP协议发出去，并把接收到的soap数据变成返回值返回。对服务端而言，各类WebService框架的本质就是一个大大的Servlet，当远程调用客户端给它通过http协议发送过来soap格式的请求数据时，它分析这个数据，就知道要调用哪个java类的哪个方法，于是去查找或创建这个对象，并调用其方法，再把方法返回的结果包装成soap格式的数据，通过http响应消息回给客户端。 WebService框架1、Axis2是Apache下的一个重量级WebService框架，准确说它是一个Web Services / SOAP / WSDL 的引擎，是WebService框架的集大成者，它能不但能制作和发布WebService，而且可以生成Java和其他语言版WebService客户端和服务端代码。这是它的优势所在。但是，这也不可避免的导致了Axis2的复杂性，使用过的开发者都知道，它所依赖的包数量和大小都是很惊人的，打包部署发布都比较麻烦，不能很好的与现有应用整合为一体。但是如果你要开发Java之外别的语言客户端，Axis2提供的丰富工具将是你不二的选择。 2、XFire是一个高性能的WebService框架，在Java6之前，它的知名度甚至超过了Apache的Axis2，XFire的优点是开发方便，与现有的Web整合很好，可以融为一体，并且开发也很方便。但是对Java之外的语言，没有提供相关的代码工具。XFire后来被Apache收购了，原因是它太优秀了，收购后，随着Java6 JWS的兴起，开源的WebService引擎已经不再被看好，渐渐的都败落了。 3、CXF是Apache旗下一个重磅的SOA简易框架，它实现了ESB（企业服务总线）。CXF来自于XFire项目，经过改造后形成的，就像目前的Struts2来自WebWork一样。可以看出XFire的命运会和WebWork的命运一样，最终会淡出人们的视线。CXF不但是一个优秀的Web Services / SOAP / WSDL 引擎，也是一个不错的ESB总线，为SOA的实施提供了一种选择方案，当然他不是最好的，它仅仅实现了SOA架构的一部分。 Http接口和WebService接口的区别什么是web service？ soap请求是HTTP POST的一个专用版本，遵循一种特殊的xml消息格式Content-type设置为: text/xml任何数据都可以xml化。 为什么要学习web service？ 大多数对外接口会实现web service方法而不是http方法，如果你不会，那就没有办法对接。 web service相对http (post/get)有好处吗？ 1.接口中实现的方法和要求参数一目了然 2.不用担心大小写问题 3.不用担心中文urlencode问题 4.代码中不用多次声明认证(账号,密码)参数 5.传递参数可以为数组，对象等… web service相对http（post/get）快吗？ 由于要进行xml解析，速度可能会有所降低。 web service 可以被http（post/get）替代吗？ 完全可以，而且现在的开放平台都是用的HTTP（post/get）实现的。 如何通俗的解释什么是CxfCXF的目的是为了开发web service，web service是SOAP的具体实现，web service的一个主要作用是解决不同语言通信的问题。举个例子，现在iteye不是希望和csdn整合吗(iteye用的ruby语言，csdn用的asp.net)，你看iteye上的通告，以后可以用csdn帐号登录了。那么这个登录系统肯定是在iteye下的，但是帐号密码一定要发送给csdn验证，ruby怎么把帐号密码发给asp.net？不同语言怎么识别？这里就用到web service了，因为web service是一个统一标准，asp.net可以定义一个登录验证的web service接口，提供一个checkLogin方法，参数是传入帐号密码，具体实现是asp.net内部的事，如果验证成功则返回true即可：public bool checkLogin(string loginCode,string password); 因为web service本身规则比较多，为了减少我们程序员的负担，往往会有一些框架来实现web service，比如java的CXF，.net也会有自己的框架，最后web service编写成功后通过部署到服务器，ruby就可以通过web service的形式调用asp.net代码了，这样就实现了不同语言的通信。 Spring整合CXF在Java中实现webservice有多种方法，java本身在jdk1.7之后也对webservice有了默认的实现，但是在我们实际开发中一般还是会使用框架来，比如这里所提到的CXF就有着广泛的应用。以下配置依然依赖于之前那篇SSM框架整合的博客所搭建的框架。 pom.xml配置添加Mava依赖(这里我统一使用了3.0.0版本。使用高版本如3.1.6版本会出现异常，初步判定是因为jar包引起了冲突，目前还没有排查出具体的原因)： 1234567891011121314151617 &lt;!--cxf CXF是apache旗下的开源框架，由Celtix + XFire这两门经典的框架合成，是一套非常流行的web service框架。 start--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-core&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt;&lt;/dependency&gt; &lt;!--cxf end--&gt; web.xml配置接着我们需要配置一个CXF的servlet： 123456789&lt;!--定义一个cxf的servlet--&gt;&lt;servlet&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/webservice/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 之后只要我们访问webservice/*这个地址就会进入CXF的servlet中。 整合Spring配置接下来是最重要的一部，用Spring整合CXF： 在这之前我有新建一个CXF的包，如下图： 这里有两个主要类 HelloWorld接口。 实现HelloWorld接口的HelloWorldImpl类。 代码如下：HelloWorld.java 12345678package com.zh.cxf;import javax.jws.WebService;@WebServicepublic interface HelloWorld &#123; public String say(String str);&#125; 其中就只定义了一个简单的say()方法。 HelloWorldImpl.java 1234567891011package com.crossoverJie.cxf.impl;import com.crossoverJie.cxf.HelloWorld;import org.springframework.stereotype.Component;import javax.jws.WebService;@Component("helloWorld")@WebServicepublic class HelloWorldImpl implements HelloWorld &#123; public String say(String str) &#123; return "Hello"+str; &#125;&#125; 这里就是对say()方法的简单实现。 接下来就是整合Spring了，由于需要使用到CXF的标签，所以我们需要添加额外的命名路径如下： 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:jaxws="http://cxf.apache.org/jaxws" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd "&gt; &lt;!-- cxf整合Spring start--&gt; &lt;import resource="classpath:META-INF/cxf/cxf.xml"/&gt; &lt;import resource="classpath:META-INF/cxf/cxf-servlet.xml"/&gt; &lt;!-- 自动扫描webService --&gt; &lt;context:component-scan base-package="com.zh.cxf" /&gt; &lt;!-- 定义webservice的发布接口 --&gt; &lt;jaxws:endpoint implementor="#helloWorld" address="/HelloWorld"&gt; &lt;/jaxws:endpoint&gt; &lt;!--cxf整合Spring end --&gt; 更加具体的配置可以查看官方给出的文档:传送门 #helloWorld指的是我们在HelloWorldImpl类中所自定义的名字，/HelloWorld则是我们需要访问的地址。之后我们运行项目输入该地址：http://127.0.0.1:8000/webservice/HelloWorld?wsdl如果出现如下界面： 则说明我们的webservice发布成功了。 客户端调用webservice接口客户端调用cxf webservice接口时可以分为静态调用和动态调用。 他们的区别：静态调用需要依赖service类，因为客户端调用cxf webservice接口的过程中需要服务器端提供service，很不方便，如果同一个项目中则没有区别。动态调用完全不依赖service类，服务器端只要提供接口名和路径就可以方便的调用。 静态调用代码：1234567891011121314151617181920212223242526272829package com.zh.cxf;import org.apache.cxf.interceptor.LoggingInInterceptor;import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;public class WebServiceUtil &#123; public static void main(String[] args) &#123; /**静态调用**/ // 创建WebService客户端代理工厂 JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean(); // 判断是否抛出异常 factory.getOutInterceptors().add(new LoggingInInterceptor()); // 注册webservice接口 factory.setServiceClass(HelloWorld.class); // 配置webservice地址 factory.setAddress("http://127.0.0.1:8000/webservice/HelloWorld?wsdl"); // 获得接口对象 HelloWorld service = (HelloWorld) factory.create(); // 调用接口方法 String result = service.say("111"); System.out.println("调用结果:" + result); // 关闭接口连接 System.exit(0); &#125; &#125; 启动项目服务，执行后控制台输出结果：1234log4j:WARN No appenders could be found for logger (org.apache.cxf.common.logging.LogUtils).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.调用结果:Hello111 动态调用代码： 1234567891011121314151617181920212223242526272829303132package com.zh.cxf;import javax.xml.namespace.QName;import org.apache.cxf.jaxws.endpoint.dynamic.JaxWsDynamicClientFactory;public class WebServiceUtil &#123; /**区别：静态调用需要依赖service类，因为客户端调用cxf webservice接口的过程中需要服务器端提供service，很不方便，如果同一个项目中则没有区别。 动态调用完全不依赖service类，服务器端只要提供接口名和路径就可以方便的调用。**/ public static void main(String[] args) &#123; /**动态调用**/ JaxWsDynamicClientFactory dcf = JaxWsDynamicClientFactory.newInstance(); org.apache.cxf.endpoint.Client client = dcf .createClient("http://127.0.0.1:8000/webservice/HelloWorld?wsdl"); // url为调用webService的wsdl地址 QName name = new QName("http://cxf.zh.com/", "say"); // namespace是命名空间，methodName是方法名 String xmlStr = "aaaaaaaa"; // paramvalue为参数值 Object[] objects; try &#123; objects = client.invoke(name, xmlStr); System.out.println(objects[0].toString()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 启动项目服务，执行后控制台输出结果： 1234log4j:WARN No appenders could be found for logger (org.apache.cxf.common.logging.LogUtils).log4j:WARN Please initialize the log4j system properly.log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.Helloaaaaaaaa 总结以上是我总结的比较简单的一篇webService入门博客，从概念、原理、应用场景到实际的配置、调用、测试。是对自己所学知识的一次梳理，同时也希望对大家以后的面试、工作能有一些帮助。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shiro安全框架集成]]></title>
      <url>%2Fblog%2F2017%2F03%2F03%2FShiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90%2F</url>
      <content type="text"><![CDATA[做企业级开发必须要了解权限和安全相关的开发知识，之前的一个项目我采用的是建立用户表、角色表、权限表、用户角色表、角色权限表五张经典表。之后使用自定义注解+拦截器的方式，在拦截器中对每一个请求进行拦截，再到SESSION或者数据库中进行查询，判断当前用户是否有该权限，这样的设计能满足大多数中小型系统的需求。本文介绍的Shiro既能满足之前的所有需求，安全性高，不跟任何的框架或者容器捆绑，可以独立运行。对比SpringSecurity安全框架使用相对简单，易于理解。而且现在越来越的多企业都在使用Shiro，值得在项目中引用尝试。 本篇博客的框架搭建请参考我之前的文章《SSM框架整合Maven+Spring+SpringMVC+MyBatis》 在项目中添加依赖pom.xml 12345678910111213141516171819&lt;!-- Apache Shiro --&gt;&lt;!-- shiro 核心包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- shiro Web相关包 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring 整合shiro需要的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt;&lt;/dependency&gt; 配置shiro过滤器web.xml 该filter最好放在字符编码filter下面: 123456789101112131415 &lt;!-- shiro过滤器定义 --&gt;&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;init-param&gt; &lt;!-- 该值缺省为false,表示生命周期由SpringApplicationContext管理,设置为true则表示由ServletContainer管理 --&gt; &lt;param-name&gt;targetFilterLifecycle&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;!-- 拦截所有请求 --&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 这样会过滤所有的请求。 创建自定义MyRealm类逻辑与表结构首先在使用Shiro的时候我们要考虑在什么样的环境下使用： 登录的验证 对指定角色的验证 对URL的验证 在本篇博客中，我们需要这三个方法： findUserByUserName(String username)根据username查询用户，之后Shiro会根据查询出来的User的密码来和提交上来的密码进行比对。 findRoles(String username)根据username查询该用户的所有角色，用于角色验证。 findPermissions(String username)根据username查询他所拥有的权限信息，用于权限判断。 由于本篇博客着重讲解shiro的配置和使用，在实际开发工作中，最好建立五张表，用户表、角色表、权限表、用户角色中间表、角色权限中间表，拓展性更强。 通过中间表来配置用户与角色的对应关系，角色与权限的对应关系，更灵活。 大概流程为：验证通过后，通过用户名从用户表中查询用户ID，根据用户ID从用户角色中间表中查询该用户所对应的所有角色ID，通过所有角色ID从角色权限中间表中查询各个角色都含有哪些权限，并进行权限的去重操作。 我的ShiroUserMapper.xml代码(Mybatis自动构建请参考我之前的文章SSM整合，可以节省掉很大一部分写重复代码的时间)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.zh.dao.ShiroUserMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.zh.model.ShiroUser" &gt; &lt;id column="id" property="id" jdbcType="INTEGER" /&gt; &lt;result column="userName" property="username" jdbcType="VARCHAR" /&gt; &lt;result column="roleId" property="roleid" jdbcType="INTEGER" /&gt; &lt;result column="password" property="password" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, userName, roleId, password &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from t_user where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from t_user where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.zh.model.ShiroUser" &gt; insert into t_user (id, userName, roleId, password) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;roleid,jdbcType=INTEGER&#125;, #&#123;password,jdbcType=VARCHAR&#125;) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.zh.model.ShiroUser" &gt; insert into t_user &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; id, &lt;/if&gt; &lt;if test="username != null" &gt; userName, &lt;/if&gt; &lt;if test="roleid != null" &gt; roleId, &lt;/if&gt; &lt;if test="password != null" &gt; password, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="username != null" &gt; #&#123;username,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="roleid != null" &gt; #&#123;roleid,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.zh.model.ShiroUser" &gt; update t_user &lt;set &gt; &lt;if test="username != null" &gt; userName = #&#123;username,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="roleid != null" &gt; roleId = #&#123;roleid,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.zh.model.ShiroUser" &gt; update t_user set userName = #&#123;username,jdbcType=VARCHAR&#125;, roleId = #&#123;roleid,jdbcType=INTEGER&#125;, password = #&#123;password,jdbcType=VARCHAR&#125; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;select id="findUserByUsername" parameterType="String" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List"/&gt; from t_user where userName=#&#123;userName&#125; &lt;/select&gt; &lt;select id="findRoles" parameterType="String" resultType="String"&gt; select r.roleName from t_user u,t_role r where u.roleId=r.id and u.userName=#&#123;userName&#125; &lt;/select&gt; &lt;select id="findPermissions" parameterType="String" resultType="String"&gt; select p.permissionName from t_user u,t_role r,t_permission p where u.roleId=r.id and p.roleId=r.id and u.userName=#&#123;userName&#125; &lt;/select&gt; &lt;/mapper&gt; 以上提到的三个方法，分别对应xml文件中最下面的三个方法。 所需的表结构(包含后面要用的测试数据)： MyRealm类创建自定义的MyRealm类，这个还是比较重要的。继承至Shiro的AuthorizingRealm类，用于处理自己的验证逻辑，下面贴一下我的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.zh.shiro;import org.apache.shiro.authc.AuthenticationException;import org.apache.shiro.authc.AuthenticationInfo;import org.apache.shiro.authc.AuthenticationToken;import org.apache.shiro.authc.SimpleAuthenticationInfo;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;import com.zh.model.ShiroUser;import com.zh.service.ShiroUserService;import javax.annotation.Resource;import java.util.Set;/** * Shiro自定义域 */public class MyRealm extends AuthorizingRealm &#123; @Resource private ShiroUserService t_userService; /** * 用于的权限的认证。 * @param principalCollection * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; String username = principalCollection.getPrimaryPrincipal().toString() ; SimpleAuthorizationInfo info = new SimpleAuthorizationInfo() ; //根据用户名获取角色名称 Set&lt;String&gt; roleName = t_userService.findRoles(username) ; //获取角色所对应的权限名称 Set&lt;String&gt; permissions = t_userService.findPermissions(username) ; info.setRoles(roleName); info.setStringPermissions(permissions); return info; &#125; /** * 首先执行这个登录验证 * @param token * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException &#123; //获取用户账号 String username = token.getPrincipal().toString(); ShiroUser user = t_userService.findUserByUsername(username); if (user != null)&#123; //这里将查询出的用户名密码与用户输入的进行匹配，并存放到 authenticationInfo用于后面的权限判断。第三个参数随便放一个就行了。 AuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(user.getUsername(),user.getPassword(), "a") ; return authenticationInfo ; &#125;else&#123; return null ; &#125; &#125;&#125; 继承AuthorizingRealm类之后就需要覆写它的两个方法： doGetAuthorizationInfo (登录验证) 和 doGetAuthenticationInfo (用户权限的认证) doGetAuthenticationInfo是用于登录验证的，在请求controller层进行登录的时候需要将数据封装到Shiro的一个token中，执行shiro的login()方法，之后只要我们将MyRealm这个类配置到Spring中，登录的时候Shiro就会自动的调用doGetAuthenticationInfo()方法进行登录验证。 ShiroUserController.java代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.zh.controller;import com.zh.model.ShiroUser;import com.zh.service.ShiroUserService;import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.subject.Subject;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;/** * 后台Controller */@Controller@RequestMapping("/shiroUser")public class ShiroUserController &#123; @Resource private ShiroUserService t_userService ; @RequestMapping("/loginAdmin") public String login(ShiroUser user, Model model)&#123; Subject subject = SecurityUtils.getSubject() ; UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(),user.getPassword()) ; try &#123; subject.login(token); return "admin" ; &#125;catch (Exception e)&#123; //这里将异常打印关闭是因为如果登录失败的话会自动抛异常// e.printStackTrace(); model.addAttribute("error","用户名或密码错误") ; return "../../login" ; &#125; &#125; @RequestMapping("/admin") public String admin()&#123; return "admin"; &#125; @RequestMapping("/student") public String student()&#123; return "admin" ; &#125; @RequestMapping("/teacher") public String teacher()&#123; return "admin" ; &#125;&#125; 在请求的Controller层中，主要就是shiro的login()方法。 登录验证的时候不是直接查询数据库返回是否有用户了，而是调用subject的login()方法，调用login()方法时Shiro会自动调用我们自定义的MyRealm类中的doGetAuthenticationInfo()方法进行验证。 验证逻辑是先根据用户名从数据库中查询用户，如果查询到的话再将查询到的用户名和密码放到SimpleAuthenticationInfo对象中，Shiro会自动根据用户输入的密码和查询到的密码进行匹配，如果匹配不上就会抛出异常，匹配上之后就会执行doGetAuthorizationInfo()进行相应的权限验证。 doGetAuthorizationInfo()方法的处理逻辑也比较简单，根据用户名获取到他所拥有的角色以及权限，然后赋值到SimpleAuthorizationInfo对象中即可，Shiro就会按照我们配置的XX角色对应XX权限来进行判断，这个配置在下面的整合中会讲到。 整合Spring我是在之前的Spring SpringMVC Mybatis框架的基础上进行整合的。 spring-mybatis.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package="com.zh" /&gt; &lt;!-- 引入properties配置文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:config/jdbc.properties&lt;/value&gt; &lt;value&gt;classpath:config/redis.properties&lt;/value&gt; &lt;!--要是有多个配置文件，只需在这里继续添加即可 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- dbcp dataSource 配置 &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; --&gt; &lt;!-- druid dataSource 配置 --&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;" /&gt; &lt;property name="filters" value="$&#123;filters&#125;" /&gt; &lt;!-- 最大并发连接数 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;" /&gt; &lt;!-- 初始化连接数量 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;" /&gt; &lt;!-- 配置获取连接等待超时的时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;" /&gt; &lt;!-- 最小空闲连接数 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;" /&gt; &lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="$&#123;timeBetweenEvictionRunsMillis&#125;" /&gt; &lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;minEvictableIdleTimeMillis&#125;" /&gt; &lt;!-- 用来检测连接是否有效的sql，要求是一个查询语句。 --&gt; &lt;property name="validationQuery" value="$&#123;validationQuery&#125;" /&gt; &lt;!-- 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。 --&gt; &lt;property name="testWhileIdle" value="$&#123;testWhileIdle&#125;" /&gt; &lt;!-- 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 --&gt; &lt;property name="testOnBorrow" value="$&#123;testOnBorrow&#125;" /&gt; &lt;!-- 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 --&gt; &lt;property name="testOnReturn" value="$&#123;testOnReturn&#125;" /&gt; &lt;!-- 要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100 --&gt; &lt;property name="maxOpenPreparedStatements" value="$&#123;maxOpenPreparedStatements&#125;" /&gt; &lt;!-- 打开removeAbandoned功能 --&gt; &lt;property name="removeAbandoned" value="$&#123;removeAbandoned&#125;" /&gt; &lt;!-- 1800秒，也就是30分钟 --&gt; &lt;property name="removeAbandonedTimeout" value="$&#123;removeAbandonedTimeout&#125;" /&gt; &lt;!-- 关闭abanded连接时输出错误日志 --&gt; &lt;property name="logAbandoned" value="$&#123;logAbandoned&#125;" /&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:com/zh/mapping/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zh.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置开始 --&gt; &lt;!-- jedis 配置 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig" &gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt; &lt;property name="maxWaitMillis" value="$&#123;redis.maxWait&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;" /&gt; &lt;/bean &gt; &lt;!-- redis服务器中心 --&gt; &lt;bean id="connectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;property name="poolConfig" ref="poolConfig" /&gt; &lt;property name="port" value="$&#123;redis.port&#125;" /&gt; &lt;property name="hostName" value="$&#123;redis.host&#125;" /&gt; &lt;!-- &lt;property name="password" value="$&#123;redis.password&#125;" /&gt; --&gt; &lt;property name="timeout" value="$&#123;redis.timeout&#125;" &gt;&lt;/property&gt; &lt;/bean &gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" &gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="keySerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="valueSerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;/bean &gt; &lt;!-- cache配置插入、更新数据时从redis中清除缓存 --&gt; &lt;bean id="putCache" class="com.zh.redis.cache.PutCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- cache配置从redis获取缓存数据 --&gt; &lt;bean id="getCache" class="com.zh.redis.cache.GetCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置结束 --&gt; &lt;!-- Shiro 开始 --&gt; &lt;!-- 配置自定义Realm --&gt; &lt;bean id="myRealm" class="com.zh.shiro.MyRealm"/&gt; &lt;!-- 安全管理器 --&gt; &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;property name="realm" ref="myRealm"/&gt; &lt;/bean&gt; &lt;!-- Shiro过滤器 核心--&gt; &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;!-- Shiro的核心安全接口,这个属性是必须的 --&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;!-- 身份认证失败，则跳转到登录页面的配置 --&gt; &lt;property name="loginUrl" value="/login.jsp"/&gt; &lt;!-- 权限认证失败，则跳转到指定页面 --&gt; &lt;property name="unauthorizedUrl" value="/nopower.jsp"/&gt; &lt;!-- Shiro连接约束配置,即过滤链的定义 --&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--anon 表示匿名访问，不需要认证以及授权--&gt; /shiroUser/loginAdmin=anon &lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt; /shiroUser/admin*=authc /shiroUser/student=roles[teacher] /shiroUser/teacher=perms["user:create"] &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt; &lt;bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/&gt; &lt;!-- 开启Shiro注解 --&gt; &lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator" depends-on="lifecycleBeanPostProcessor"/&gt; &lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager"/&gt; &lt;/bean&gt; &lt;!-- Shiro 结束 --&gt;&lt;/beans&gt; 在这里配置了上文中自定义的myRealm,这样Shiro就可以按照我们自定义的逻辑来进行权限验证了。 着重讲解一下：12345678910&lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--anon 表示匿名访问，不需要认证以及授权--&gt; /shiroUser/loginAdmin=anon &lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt; /shiroUser/admin*=authc /shiroUser/student=roles[teacher] /shiroUser/teacher=perms["user:create"] &lt;/value&gt;&lt;/property&gt; /shiroUser/loginAdmin=anon的意思的意思是，发起/shiroUser/loginAdmin这个请求是不需要进行身份认证的，这个请求在这次项目中是一个登录请求，一般对于这样的请求都是不需要身份认证的。 /shiroUser/admin*=authc表示 /admin,/admin1,/admin2这样的请求都是需要进行身份认证的，不然是不能访问的。 /shiroUser/student=roles[teacher]表示访问/student请求的用户必须是teacher角色，不然是不能进行访问的。 /shiroUser/teacher=perms[“user:create”]表示访问/teacher请求是需要当前用户具有user:create权限才能进行访问的。 这里注意下，如果你的controller层配置了全局的@RequestMapping(“/xxxx”)，在上面进行权限配置的时候一定以这个格式进行配置(格式:/xxxx/loginAdmin=anon)，不然会拦截失效。 更多相关权限过滤的资料可以访问shiro的官方介绍：传送门 使用Shiro标签库Shiro还有着强大标签库，可以在前端帮我获取信息和做判断。我贴一下我这里登录完成之后显示的界面：1234567891011121314151617&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;%@ taglib prefix="shiro" uri="http://shiro.apache.org/tags" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;后台&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;shiro:hasRole name="admin"&gt; 这是admin角色登录：&lt;shiro:principal&gt;&lt;/shiro:principal&gt;&lt;/shiro:hasRole&gt;&lt;shiro:hasPermission name="user:create"&gt; 有user:create权限信息&lt;/shiro:hasPermission&gt;&lt;br&gt;登录成功&lt;/body&gt;&lt;/html&gt; 要想使用Shiro标签，只需要引入一下标签即可： &lt;%@ taglib prefix=”shiro” uri=”http://shiro.apache.org/tags“ %&gt; 具有admin角色才会显示标签内的信息。 获取用户信息。默认调用Subject.getPrincipal()获取，即Primary Principal。 用户拥有user:create这个权限才回显示标签内的信息。 更多的标签可以查看官网：传送门 （图片待续。。。） 首先来验证一下登录： 先输入一个错误的账号和密码： 接下来输入一个正确的： 可以看到我登录的用户是zhfeat他是有admin的角色，并且拥有user:*(ps:系统数据详见上面的数据库截图)的权限，所以在这里： 123456&lt;shiro:hasRole name="admin"&gt; 这是admin角色登录：&lt;shiro:principal&gt;&lt;/shiro:principal&gt;&lt;/shiro:hasRole&gt;&lt;shiro:hasPermission name="user:create"&gt; 有user:create权限信息&lt;/shiro:hasPermission&gt; 是能显示出标签内的信息，并把用户信息也显示出来了。 接着我们来访问一下/student这个请求，因为在Spring的配置文件中： 12345678910&lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--anon 表示匿名访问，不需要认证以及授权--&gt; /shiroUser/loginAdmin=anon &lt;!--authc表示需要认证 没有进行身份认证是不能进行访问的--&gt; /shiroUser/admin*=authc /shiroUser/student=roles[teacher] /shiroUser/teacher=perms["user:create"] &lt;/value&gt;&lt;/property&gt; 只有teacher角色才能访问/student这个请求的： 果然，Shiro做了安全控制是不能进行访问的。 然后我们换aaa用户登录，他正好是teacher角色，看能不能访问/student。 果然是能访问的。 因为我在控制器里访问/student返回的是同一个界面所以看到的还是这个界面。 1234@RequestMapping("/teacher")public String teacher()&#123; return "admin" ;&#125; 并且没有显示之前Shiro标签内的内容。 其他的我就不测了，大家可以自己在数据库里加一些数据，或者是改下拦截的权限多试试，这样对Shiro的理解就会更加深刻。 MD5加密Shiro还封装了一个非常不错的功能，那就是MD5加密，代码如下：12345678910111213141516package com.crossoverJie.shiro;import org.apache.shiro.crypto.hash.Md5Hash;/** * Created with IDEA * 基于Shiro的MD5加密 * Created by $&#123;jie.chen&#125; on 2016/7/13. */public class MD5Util &#123; public static String md5(String str,String salt)&#123; return new Md5Hash(str,salt).toString() ; &#125; public static void main(String[] args) &#123; String md5 = md5("abc123","crossoverjie") ; System.out.println(md5); &#125;&#125; 只需要调用Md5Hash(str,salt)方法即可，这里多了一个参数，第一个参数不用多解释，是需要加密的字符串。第二个参数salt中文翻译叫盐，加密的时候我们传一个字符串进去，只要这个salt不被泄露出去，那原则上加密之后是无法被解密的，在存用户密码的时候可以使用，感觉还是非常屌的。 总结以上就是Shiro实际使用的案例，文章讲的比较初略，还需要后面自己拓展，但是关于Shiro的核心东西都在里面了，大家可以自己配一下试试，才更能体会其中的逻辑。 项目地址：https://github.com/mhkzh/SSM 个人博客地址：http://zhfeat.cc GitHub地址：https://github.com/mhkzh/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[应用Druid监控SQL语句的执行情况]]></title>
      <url>%2Fblog%2F2017%2F03%2F01%2F%E5%BA%94%E7%94%A8Druid%E7%9B%91%E6%8E%A7SQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E6%83%85%E5%86%B5%2F</url>
      <content type="text"><![CDATA[Druid是目前最好的数据库连接池，在功能、性能、扩展性方面，都超过其他数据库连接池，包括DBCP、C3P0、BoneCP、Proxool、JBoss DataSource Druid是什么？ Druid是一个JDBC组件，它包括三个部分： 基于Filter－Chain模式的插件体系。 DruidDataSource 高效可管理的数据库连接池。 SQLParser(一个经典的词法分析器,可解析各种复杂的SQL语句) 官方文档地址：https://github.com/alibaba/druid/wiki/常见问题 Druid可以做什么？ 替换DBCP和C3P0。Druid提供了一个高效、功能强大、可扩展性好的数据库连接池。 可以监控数据库访问性能，Druid内置提供了一个功能强大的StatFilter插件，能够详细统计SQL的执行性能，这对于线上分析数据库访问性能有帮助。 数据库密码加密。直接把数据库密码写在配置文件中，这是不好的行为，容易导致安全问题。DruidDruiver和DruidDataSource都支持PasswordCallback。 SQL执行日志，Druid提供了不同的LogFilter，能够支持Common-Logging、Log4j和JdkLog，你可以按需要选择相应的LogFilter，监控你应用的数据库访问情况。 扩展JDBC，如果你要对JDBC层有编程的需求，可以通过Druid提供的Filter机制，很方便编写JDBC层的扩展插件。 Druid在项目中配置使用pom.xml中添加Druid依赖123456&lt;!-- druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.28&lt;/version&gt; &lt;/dependency&gt; jdbc.properties属性文件中配置Druid所需参数123456789101112131415161718192021222324252627282930313233343536#druid连接池配置url:jdbc:mysql://localhost:3306/maven?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8 driverClassName:com.mysql.jdbc.Driverusername:rootpassword:rootfilters:stat#最大并发连接数maxActive:20#初始化连接数量initialSize:1#配置获取连接等待超时的时间maxWait:60000#最小空闲连接数minIdle:10#最大空闲连接数maxIdle:15#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒timeBetweenEvictionRunsMillis:60000#配置一个连接在池中最小生存的时间，单位是毫秒minEvictableIdleTimeMillis:300000#用来检测连接是否有效的sql，要求是一个查询语句。 如果validationQuery为null，testOnBorrow、testOnReturn、 testWhileIdle都不会其作用。validationQuery:SELECT 'x'#建议配置为true，不影响性能，并且保证安全性。 申请连接的时候检测，如果空闲时间大于 timeBetweenEvictionRunsMillis， 执行validationQuery检测连接是否有效。testWhileIdle:true#申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。testOnBorrow:false#归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能testOnReturn:false#要启用PSCache，必须配置大于0，当大于0时poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题， 可以把这个数值配置大一些，比如说100maxOpenPreparedStatements:20#打开removeAbandoned功能removeAbandoned:true#1800秒，也就是30分钟removeAbandonedTimeout:1800#关闭abanded连接时输出错误日志logAbandoned:true web.xml中配置123456789101112131415161718192021222324252627 &lt;!-- druid start--&gt; &lt;!-- 配置sql监控 start--&gt; &lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;!-- 网页监控路径放在了项目路径下的 druid路径中 --&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置sql监控 end--&gt; &lt;!-- 监控jsp和do请求，exclusions参数其实可以去掉的 start --&gt;&lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 监控jsp和do请求，exclusions参数其实可以去掉的 end --&gt; &lt;!-- druid end--&gt; 查看Druid监控页面，测试效果启动项目，在浏览器输入：http://localhost:8000/druid/sql.html 下图为Druid监控主界面： 点击sql监控，调用接口，测试是否监控到了sql的各项信息 下图为DruidSQL监控功能界面： 结果：测试通过，以上为项目引入Druid连接池并启动Druid监控页面的流程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用自定义注解+AOP实现redis缓存]]></title>
      <url>%2Fblog%2F2017%2F03%2F01%2F%E5%88%A9%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%2BAOP%E5%AE%9E%E7%8E%B0redis%E7%BC%93%E5%AD%98%2F</url>
      <content type="text"><![CDATA[数据查询时每次都需要从数据库查询数据，特别是通过复杂sql查询大量数据时，数据库压力很大，查询速度很慢，因此设置缓存层，查询数据时先从redis中查询，如果查询不到，则到数据库中查询然后将数据库中查询的数据放到redis中一份，下次查询时就能直接从redis中查到，不需要查询数据库了。进行增删改操作时，先从redis中查询，如果查询出数据，则在redis中将该数据清除。 redis作为缓存的优势 内存级别缓存，查询速度毋庸置疑。 高性能的K-V存储系统，支持String，Hash，List，Set，Sorted Set等数据类型，能够应用在很多场景中。 redis3.0版本以上支持集群部署。 redis支持数据的持久化，AOF，RDB方式。 redis安装部署请参见：http://blog.csdn.net/erlian1992/article/details/54382443 实现过程 搭建ssm的框架(请参考前一篇博文) 引入redis、jedis、SpringAOP依赖包 编写redis缓存方法、jedis操作Redis以及序列化所用到的工具类。 目录结构 maven依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;!-- modelVersion 这个元素指定了POM的版本，Maven2或者Maven3都只能是4.0.0 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- groupId 是项目组的ID，一般是com.公司组织名.项目名 --&gt; &lt;groupId&gt;com.zh.mavenDemo&lt;/groupId&gt; &lt;!-- artifactId 是该项目在项目组中的ID --&gt; &lt;artifactId&gt;mavenDemo&lt;/artifactId&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- ersion 是项目的版本号，用于维护项目的升级和发布 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 一般没有实际的用处，只是用于标识该项目 --&gt; &lt;name&gt;mavenDemo Maven Webapp&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用--&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 在spring的依赖中，我们需要引用一系列版本的spring，如版本4.0.2.RELEASE，每次都写不利于维护， 所以使用properties标签来统一维护版本号，这样有利于维护，不用大量修改，引用格式 &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; --&gt; &lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;!-- slf4j入口就是众多接口的集合，它不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。 --&gt; &lt;!-- 通俗的讲，slf4j是个数据线，一端嵌入程序，另一端链接日志系统，从而实现将程序中的信息导入到日志系统并记录。 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;!-- log4j是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终日志的输出。 --&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;/properties&gt; &lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;!-- &lt;scope&gt;test&lt;/scope&gt; --&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;!-- spring核心包 --&gt; &lt;!-- 这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring对于object/xml映射的支持，可以让JAVA与XML之间来回切换 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含对Spring对JDBC数据访问进行封装的所有类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含在应用中使用Spring的AOP特性(Spring的面向切面编程)时所需的类。使用基于AOP的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop注解 start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aop注解 end --&gt; &lt;!-- redies start --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.6.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- redies end --&gt; &lt;!-- Spring context的扩展支持，用于MVC方面。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 对JUNIT等测试框架的简单封装 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.36&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp(数据库连接池)的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 记录日志的，封装好的一个包，通过配置文件配置，在程序中直接调用，记录需要记录的日志，一般日志保存在文件中， --&gt; &lt;!-- SLF4J作用：如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无语忍受加载和维护一个新的日志框架的痛苦。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j-log4j12是链接slf4j-api和log4j中间的适配器。它实现了slf4j-apiz中StaticLoggerBinder接口 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON java对象和json相互转化,JSON串解析--&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传组件包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--构建项目需要的信息--&gt; &lt;build&gt; &lt;finalName&gt;mavenDemo&lt;/finalName&gt; &lt;!--使用的插件列表 。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。--&gt; &lt;plugin&gt; &lt;!-- Jetty 是一个开源的servlet容器，它为基于Java的web容器，例如JSP和servlet提供运行环境。Jetty是使用Java语言编写的，它的API以一组JAR包的形式发布。开发人员可以将Jetty容器实例化成一个对象，可以迅速为一些独立运行（stand-alone）的Java应用提供网络和web连接。 --&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.2.8.v20150217&lt;/version&gt; &lt;configuration&gt; &lt;httpConnector&gt; &lt;port&gt;8000&lt;/port&gt; &lt;/httpConnector&gt; &lt;stopKey&gt;shutdown&lt;/stopKey&gt; &lt;stopPort&gt;9966&lt;/stopPort&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; redis相关配置由于我spring配置文件和mybatis写在了一块，所以在spring-mybatis.xml里添加redis相关配置：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package="com.zh.*" /&gt; &lt;!-- 引入properties配置文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:config/jdbc.properties&lt;/value&gt; &lt;value&gt;classpath:config/redis.properties&lt;/value&gt; &lt;!--要是有多个配置文件，只需在这里继续添加即可 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:com/zh/mapping/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zh.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置开始 --&gt; &lt;!-- jedis 配置 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig" &gt; &lt;property name="maxIdle" value="$&#123;redis.maxIdle&#125;" /&gt; &lt;property name="maxWaitMillis" value="$&#123;redis.maxWait&#125;" /&gt; &lt;property name="testOnBorrow" value="$&#123;redis.testOnBorrow&#125;" /&gt; &lt;/bean &gt; &lt;!-- redis服务器中心 --&gt; &lt;bean id="connectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;property name="poolConfig" ref="poolConfig" /&gt; &lt;property name="port" value="$&#123;redis.port&#125;" /&gt; &lt;property name="hostName" value="$&#123;redis.host&#125;" /&gt; &lt;!-- &lt;property name="password" value="$&#123;redis.password&#125;" /&gt; --&gt; &lt;property name="timeout" value="$&#123;redis.timeout&#125;" &gt;&lt;/property&gt; &lt;/bean &gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" &gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="keySerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;property name="valueSerializer" &gt; &lt;bean class="org.springframework.data.redis.serializer.StringRedisSerializer" /&gt; &lt;/property&gt; &lt;/bean &gt; &lt;!-- cache配置插入、更新数据时从redis中清除缓存 --&gt; &lt;bean id="putCache" class="com.zh.redis.cache.PutCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- cache配置从redis获取缓存数据 --&gt; &lt;bean id="getCache" class="com.zh.redis.cache.GetCacheAOP" &gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;/bean&gt; &lt;!-- Redis和缓存配置结束 --&gt;&lt;/beans&gt; redis.properties相关配置：1234567891011121314151617#redis中心 #绑定的主机地址 redis.host=127.0.0.1#指定Redis监听端口，默认端口为6379 redis.port=6379 #授权密码（本例子没有使用） redis.password=#最大空闲数：空闲链接数大于maxIdle时，将进行回收 redis.maxIdle=100 #最大连接数：能够同时建立的“最大链接个数” redis.maxActive=300 #最大等待时间：单位msredis.maxWait=1000 #使用连接时，检测连接是否成功 redis.testOnBorrow=true#当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 redis.timeout=10000 spring-mvc.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package="com.zh.controller" /&gt; &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源处理 css js imgs --&gt; &lt;mvc:resources location="/resources/**" mapping="/resources"/&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id="mappingJacksonHttpMessageConverter" class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;ref bean="mappingJacksonHttpMessageConverter" /&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 默认编码 --&gt; &lt;property name="defaultEncoding" value="utf-8" /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name="maxUploadSize" value="10485760000" /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name="maxInMemorySize" value="40960" /&gt; &lt;!-- 启用是为了推迟文件解析，以便捕获文件大小异常 --&gt; &lt;property name="resolveLazily" value="true"/&gt; &lt;/bean&gt; &lt;!-- 配置ViewResolver 。可用多个ViewResolver 。使用order属性排序。 InternalResourceViewResolver 放在最后--&gt; &lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;property name="order" value="1"&gt;&lt;/property&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;!-- 告诉视图解析器，返回的类型为json格式 --&gt; &lt;entry key="json" value="application/json" /&gt; &lt;entry key="xml" value="application/xml" /&gt; &lt;entry key="htm" value="text/htm" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="defaultViews"&gt; &lt;list&gt; &lt;!-- ModelAndView里的数据变成JSON --&gt; &lt;bean class="org.springframework.web.servlet.view.json.MappingJacksonJsonView" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="ignoreAcceptHeader" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;!-- 激活自动代理功能，开启注解 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; &lt;!-- 解决使用@ResponseBody 的中文乱码。 --&gt; &lt;bean class="com.zh.common.UTF8StringBeanPostProcessor"&gt;&lt;/bean&gt; &lt;/beans&gt; 开启注解这个一定要写到springmvc.xml里，否则注解会不起作用。 创建自定义注解、切面PutCache.java12345678910/** * 自定义注解,在插入、更新或者删除的时候更新对应的版本 * @author zh */ @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.METHOD&#125;) public @interface PutCache &#123; String name() default ""; String value() default ""; &#125; 被PutCache.java类中自定义的注解所标记的方法将实现下面的切面：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/**@Component * 注解用来将这个切面类实例化为bean， * 这样的操作也可以在Spring的配置文件中通过&lt;bean id="" class=""/&gt;来实现， * 效果一致。但是注解实现和配置实现两者不能共存， * 因为共存后Spring容器会同时管理两个同样的切面bean， * 导致的结果将是所有的通知都会执行两次， * 因为会有两个一样的切面被切入到业务代码中。**///@Component //实例化为bean，并交由Spring容器管理@Aspect //声明这是一个切面public class PutCacheAOP &#123; @Autowired //声明这个变量将由Spring容器注入 private RedisTemplate&lt;Serializable, Object&gt; redisTemplate; private RedisCache redisCache = new RedisCache(); //定义切入点 @Pointcut("@annotation(com.zh.redis.cache.PutCache)") public void putCache()&#123; System.out.println("我是一个切入点"); &#125; /** * 环绕通知,在所有标注@putCache的地方切入 * @param joinPoint */ @Around("putCache()") public Object beforeExec(ProceedingJoinPoint joinPoint)&#123; //前置：到redis中查询缓存 System.out.println("调用从redis中查询的方法..."); //redis中key格式：id String redisKey = getCacheKey(joinPoint); Object object = null; //获取从redis中查询到的对象 Object objectFromRedis = redisCache.getDataFromRedis(redisKey); //如果查询到了 if(null != objectFromRedis)&#123; System.out.println("从redis中查到数据,从redis中清空缓存"); //清空缓存 redisCache.delDataToRedis(redisKey); try &#123; object = joinPoint.proceed();//启动目标方法执行 System.out.println("操作数据库..."); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; &#125;else&#123; System.out.println("从redis中未查到数据..."); //没有查到，那么直接操作数据库 try &#123; object = joinPoint.proceed(); //启动目标方法执行 &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; System.out.println("操作数据库..."); &#125; return object; &#125; /** * 根据类名、方法名和参数值获取唯一的缓存键 * @return 格式为 "包名.类名.方法名.参数类型.参数值"，类似 "your.package.SomeService.getById(int).123" */ @SuppressWarnings("unused") private String getCacheKey(ProceedingJoinPoint joinPoint) &#123; MethodSignature ms=(MethodSignature) joinPoint.getSignature(); Method method=ms.getMethod(); String ActionName = method.getAnnotation(PutCache.class).name(); String fieldList = method.getAnnotation(PutCache.class).value(); //System.out.println("签名是"+ms.toString()); for (String field:fieldList.split(",")) ActionName +="."+field; //先获取目标方法参数，确保redis-Key的唯一性，由于我在更新或者插入时需要根据相同的key清除缓存，这里暂不做处理。 //String id = null; //Object[] args = joinPoint.getArgs(); //if (args != null &amp;&amp; args.length &gt; 0) &#123; // id = String.valueOf(args[0]); //&#125; //ActionName += "="+id; //String redisKey = ms+"."+ActionName; return ActionName; &#125; public void setRedisTemplate( RedisTemplate&lt;Serializable, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125;&#125; GetCache.java12345678910/** * 自定义注解,对于查询使用缓存的方法加入该注解 * @author Chenth */ @Retention(RetentionPolicy.RUNTIME) @Target(&#123;ElementType.METHOD&#125;) public @interface GetCache &#123; String name() default ""; String value() default ""; &#125; 被GetCache.java类中自定义的注解所标记的方法将实现下面的切面：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * GetCache对应的切面 * @author zh * *//**@Component * 注解用来将这个切面类实例化为bean， * 这样的操作也可以在Spring的配置文件中通过&lt;bean id="" class=""/&gt;来实现， * 效果一致。但是注解实现和配置实现两者不能共存， * 因为共存后Spring容器会同时管理两个同样的切面bean， * 导致的结果将是所有的通知都会执行两次， * 因为会有两个一样的切面被切入到业务代码中。**///@Component //实例化为bean，并交由Spring容器管理@Aspect //声明这是一个切面public class GetCacheAOP &#123; @Autowired //声明这个变量将由Spring容器注入 private RedisTemplate&lt;Serializable, Object&gt; redisTemplate; private RedisCache redisCache = new RedisCache(); //定义切入点 @Pointcut("@annotation(com.zh.redis.cache.GetCache)") public void getCache()&#123; System.out.println("我是一个切入点"); &#125; /** * 环绕通知,在所有标注@getCache的地方切入 * @param joinPoint */ @Around("getCache()") public Object beforeExec(ProceedingJoinPoint joinPoint)&#123; //前置：到redis中查询缓存 System.out.println("调用从redis中查询的方法..."); //redis中key格式：id String redisKey = getCacheKey(joinPoint); //获取从redis中查询到的对象 Object objectFromRedis = redisCache.getDataFromRedis(redisKey); //如果查询到了 if(null != objectFromRedis)&#123; System.out.println("从redis中查询到了数据...不需要查询数据库"); return objectFromRedis; &#125; System.out.println("没有从redis中查到数据..."); //没有查到，那么查询数据库 Object object = null; try &#123; object = joinPoint.proceed(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; System.out.println("从数据库中查询的数据..."); //后置：将数据库中查询的数据放到redis中 System.out.println("调用把数据库查询的数据存储到redis中的方法..."); redisCache.setDataToRedis(redisKey, object);; System.out.println("redis中的数据..."+object.toString()); //将查询到的数据返回 return object; &#125; /** * 根据类名、方法名和参数值获取唯一的缓存键 * @return 格式为 "包名.类名.方法名.参数类型.参数值"，类似 "your.package.SomeService.getById(int).123" */ @SuppressWarnings("unused") private String getCacheKey(ProceedingJoinPoint joinPoint) &#123; MethodSignature ms=(MethodSignature) joinPoint.getSignature(); Method method=ms.getMethod(); String ActionName = method.getAnnotation(GetCache.class).name(); String fieldList = method.getAnnotation(GetCache.class).value(); //System.out.println("签名是"+ms.toString()); for (String field:fieldList.split(",")) ActionName +="."+field; //先获取目标方法参数 //String id = null; //Object[] args = joinPoint.getArgs(); //if (args != null &amp;&amp; args.length &gt; 0) &#123; // id = String.valueOf(args[0]); //&#125; //ActionName += "="+id; //String redisKey = ms+"."+ActionName; return ActionName; &#125; public void setRedisTemplate( RedisTemplate&lt;Serializable, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125;&#125; @Pointcut(“@annotation(com.zh.redis.cache.GetCache)”) 这个切入点的作用是在所有标注@getCache的地方切入 @Around(“getCache()”)这里用的是后置通知，即查询之前先查询redis，如果有数据就返回数据，没有就使用AOP的“启动目标方法函数”执行数据库查询数据，之后再缓存到redis中。 编写mapper层,service层,controller层 在上篇文章中已经进行详细介绍，这里不再讲解。 缓存要用到的工具类 RedisCache 12345678910111213141516171819202122232425262728293031323334353637383940public class RedisCache &#123; @Autowired private JedisPool jedisPool = new JedisPool(); //从redis缓存中查询，反序列化 public Object getDataFromRedis(String redisKey)&#123; //查询 Jedis jedis = jedisPool.getResource(); byte[] result = jedis.get(redisKey.getBytes()); //如果查询没有为空 if(null == result)&#123; return null; &#125; //查询到了，反序列化 return SerializeUtil.unSerialize(result); &#125; //将数据库中查询到的数据放入redis public void setDataToRedis(String redisKey, Object obj)&#123; //序列化 byte[] bytes = SerializeUtil.serialize(obj); //存入redis Jedis jedis = jedisPool.getResource(); String success = jedis.set(redisKey.getBytes(), bytes); if("OK".equals(success))&#123; System.out.println("数据成功保存到redis..."); &#125; &#125; //根据redisKey清除缓存 public void delDataToRedis(String redisKey)&#123; Jedis jedis = jedisPool.getResource(); jedis.del(redisKey); System.out.println("缓存数据已清空..."); &#125; 缓存要用到的序列化和反序列化工具123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * * @Description: 序列化反序列化工具 */public class SerializeUtil &#123; /** * * 序列化 */ public static byte[] serialize(Object obj)&#123; ObjectOutputStream oos = null; ByteArrayOutputStream baos = null; try &#123; //序列化 baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(obj); byte[] byteArray = baos.toByteArray(); return byteArray; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * * 反序列化 * @param bytes * @return */ public static Object unSerialize(byte[] bytes)&#123; ByteArrayInputStream bais = null; try &#123; //反序列化为对象 bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 测试redis是否生效在测试过程中遇到了springMvc返回json数据中文乱码问题，使用spring的BeanPostProcessor接口实现。123456789101112131415161718/** * 解决spring MVC3 中@ResponseBody的中文乱码问题 */ public class UTF8StringBeanPostProcessor implements BeanPostProcessor &#123; public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (bean instanceof StringHttpMessageConverter) &#123; MediaType mediaType = new MediaType("text", "plain", Charset.forName("UTF-8")); List&lt;MediaType&gt; types = new ArrayList&lt;MediaType&gt;(); types.add(mediaType); ((StringHttpMessageConverter) bean).setSupportedMediaTypes(types); &#125; return bean; &#125; public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; return bean; &#125; &#125; 再在springMvc的xml中注册： 12 &lt;!-- 解决使用@ResponseBody 的中文乱码。 --&gt; &lt;bean class="com.zh.common.UTF8StringBeanPostProcessor"&gt;&lt;/bean&gt; 为UserController.java 中的增加方法添加自定义注解@PutCache： 12345678910111213141516171819 // /user/test?id=1@PutCache(name="newsList",value="com.zh.UserController.showUser(String).123") @RequestMapping(value="/test",method=RequestMethod.GET) public String test(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user=null; if (userId==1) &#123; user = new User(); user.setAge(11); user.setId(1); user.setPassword("123"); user.setUserName("javen"); &#125; log.debug(user.toString()); model.addAttribute("user", user); return "index"; &#125; 为UserController.java 中的查询方法添加自定义注解@GetCache： 123456789101112131415 // /user/showUser?id=1// 从请求里面获取参数@GetCache(name="newsList",value="com.zh.UserController.showUser(String).123") @RequestMapping(value="/showUser",method=RequestMethod.GET) @ResponseBodypublic String toIndex(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.debug(user.toString()); String json = JSON.toJSONString(user); return json; //model.addAttribute("user", user); //return "showUser"; &#125; 启动redis服务并启动项目，执行查询方法，控制台输出日志如下所示： http://localhost:8000/user/showUser?id=1 1234567调用从redis中查询的方法...没有从redis中查到数据...userId:1从数据库中查询的数据...调用把数据库查询的数据存储到redis中的方法...数据成功保存到redis...redis中的数据...&#123;&quot;age&quot;:24,&quot;id&quot;:1,&quot;password&quot;:&quot;345&quot;,&quot;userName&quot;:&quot;测试&quot;&#125; 再次执行查询方法，控制台输出日志如下所示： http://localhost:8000/user/showUser?id=1 12调用从redis中查询的方法...从redis中查询到了数据...不需要查询数据库 执行增加方法，控制台输出日志如下所示： http://localhost:8000/user/test?id=1 12345调用从redis中查询的方法...从redis中查到数据,从redis中清空缓存缓存数据已清空...userId:1操作数据库... 再次执行查询方法，控制台输出日志如下所示： http://localhost:8000/user/showUser?id=1 1234567调用从redis中查询的方法...没有从redis中查到数据...userId:1从数据库中查询的数据...调用把数据库查询的数据存储到redis中的方法...数据成功保存到redis...redis中的数据...&#123;&quot;age&quot;:24,&quot;id&quot;:1,&quot;password&quot;:&quot;345&quot;,&quot;userName&quot;:&quot;测试&quot;&#125; 测试通过，由此完成了SSM + redies的整合，降低了应用的数据库请求次数和时间消耗，提高了查询效率。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSM框架整合（Maven+Spring+SpringMVC+MyBatis）]]></title>
      <url>%2Fblog%2F2017%2F02%2F24%2FSSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%EF%BC%88Maven%2BSpring%2BSpringMVC%2BMyBatis%EF%BC%89%2F</url>
      <content type="text"><![CDATA[以下是参考网上的资料自己实践操作的详细步骤。作为日后开发学习的参考。文中JAVA类及配置文件中加入了许多自己的理解和注释，后续会在此框架基础上引入更多的功能，使其更加完善。 基本概念SpringSpring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。 简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。 SpringMVC Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring MVC分离了控制器、模型对象、分派器以及处理程序对象的角色，这种分离让它们更容易进行定制。 MyBatis MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。MyBatis是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。 开发环境搭建以及创建Maven Web项目参看博文：http://www.cnblogs.com/zyw-205520/p/4767633.html SSM整合下面主要介绍SSM三大框架的整合，至于环境的搭建以及项目的创建，参看上面的博文。项目依赖包主要由spring核心包、mybatis核心包、dbcp数据库连接池、log4j、slf4j等日志记录相关依赖包、json处理包、junit单元测试包、javaEE核心包、jstl标签所需包、fileupload上传组件包、Jetty容器插件组成，整合分为了2个配置文件，分别是spring-mybatis.xml，包含spring和mybatis的配置文件，还有个是spring-mvc的配置文件，配置文件可以根据实际情况进行调整，此外有2个资源文件：jdbc.propertis和log4j.properties。完整目录结构如下（最后附上源码下载地址）： 使用框架的版本：Spring 4.0.2 RELEASESpring MVC 4.0.2 RELEASEMyBatis 3.2.6 Maven引入需要的JAR包在pom.xml中引入jar包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;!-- modelVersion 这个元素指定了POM的版本，Maven2或者Maven3都只能是4.0.0 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- groupId 是项目组的ID，一般是com.公司组织名.项目名 --&gt; &lt;groupId&gt;com.zh.mavenDemo&lt;/groupId&gt; &lt;!-- artifactId 是该项目在项目组中的ID --&gt; &lt;artifactId&gt;mavenDemo&lt;/artifactId&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型--&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;!-- ersion 是项目的版本号，用于维护项目的升级和发布 --&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- 一般没有实际的用处，只是用于标识该项目 --&gt; &lt;name&gt;mavenDemo Maven Webapp&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用--&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 在spring的依赖中，我们需要引用一系列版本的spring，如版本4.0.2.RELEASE，每次都写不利于维护， 所以使用properties标签来统一维护版本号，这样有利于维护，不用大量修改，引用格式 &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; --&gt; &lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.2.6&lt;/mybatis.version&gt; &lt;!-- log4j日志文件管理包版本 --&gt; &lt;!-- slf4j入口就是众多接口的集合，它不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。 --&gt; &lt;!-- 通俗的讲，slf4j是个数据线，一端嵌入程序，另一端链接日志系统，从而实现将程序中的信息导入到日志系统并记录。 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;!-- log4j是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终日志的输出。 --&gt; &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt; &lt;/properties&gt; &lt;!-- 该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;!-- 表示开发的时候引入，发布的时候不会加载此包 --&gt; &lt;!-- &lt;scope&gt;test&lt;/scope&gt; --&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;!-- spring核心包 --&gt; &lt;!-- 这个jar文件包含Spring框架基本的核心工具类，Spring其它组件要都要使用到这个包里的类，是其它组件的基本核心，当然你也可以在自己的应用系统中使用这些工具类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Web应用开发时，用到Spring框架时所需的核心类，包括自动载入WebApplicationContext特性的类、Struts与JSF集成类、文件上传的支持类、Filter类和大量工具辅助类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring对于object/xml映射的支持，可以让JAVA与XML之间来回切换 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 为JDBC、Hibernate、JDO、JPA等提供的一致的声明式和编程式事务管理。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含对Spring对JDBC数据访问进行封装的所有类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含Spring MVC框架相关的所有类。包含国际化、标签、Theme、视图展现的FreeMarker、JasperReports、Tiles、Velocity、XSLT相关类。当然，如果你的应用使用了独立的MVC框架，则无需这个JAR文件里的任何类。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 这个jar文件包含在应用中使用Spring的AOP特性(Spring的面向切面编程)时所需的类。使用基于AOP的Spring特性，如声明型事务管理（Declarative Transaction Management），也要在应用里包含这个jar包。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring context的扩展支持，用于MVC方面。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 对JUNIT等测试框架的简单封装 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.36&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入dbcp(数据库连接池)的jar包，用来在applicationContext.xml中配置数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 记录日志的，封装好的一个包，通过配置文件配置，在程序中直接调用，记录需要记录的日志，一般日志保存在文件中， --&gt; &lt;!-- SLF4J作用：如果一个项目已经使用了log4j，而你加载了一个类库，比方说 Apache Active MQ——它依赖于于另外一个日志类库logback，那么你就需要把它也加载进去。但如果Apache Active MQ使用了SLF4J，你可以继续使用你的日志类库而无语忍受加载和维护一个新的日志框架的痛苦。 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j-log4j12是链接slf4j-api和log4j中间的适配器。它实现了slf4j-apiz中StaticLoggerBinder接口 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!-- 映入JSON java对象和json相互转化,JSON串解析--&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 上传组件包 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--构建项目需要的信息--&gt; &lt;build&gt; &lt;finalName&gt;mavenDemo&lt;/finalName&gt; &lt;!--使用的插件列表 。--&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。--&gt; &lt;plugin&gt; &lt;!-- Jetty 是一个开源的servlet容器，它为基于Java的web容器，例如JSP和servlet提供运行环境。Jetty是使用Java语言编写的，它的API以一组JAR包的形式发布。开发人员可以将Jetty容器实例化成一个对象，可以迅速为一些独立运行（stand-alone）的Java应用提供网络和web连接。 --&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.2.8.v20150217&lt;/version&gt; &lt;configuration&gt; &lt;httpConnector&gt; &lt;port&gt;8000&lt;/port&gt; &lt;/httpConnector&gt; &lt;stopKey&gt;shutdown&lt;/stopKey&gt; &lt;stopPort&gt;9966&lt;/stopPort&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 整合SpringMVC配置spring-mvc.xml配置里面的注释也很详细，主要是自动扫描控制器，视图模式，注解的启动这三个。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package="com.zh.controller" /&gt; &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 静态资源处理 css js imgs --&gt; &lt;mvc:resources location="/resources/**" mapping="/resources"/&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id="mappingJacksonHttpMessageConverter" class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解POJO的映射 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt; &lt;property name="messageConverters"&gt; &lt;list&gt; &lt;ref bean="mappingJacksonHttpMessageConverter" /&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置文件上传，如果没有使用文件上传可以不用配置，当然如果不配，那么配置文件中也不必引入上传组件包 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 默认编码 --&gt; &lt;property name="defaultEncoding" value="utf-8" /&gt; &lt;!-- 文件大小最大值 --&gt; &lt;property name="maxUploadSize" value="10485760000" /&gt; &lt;!-- 内存中的最大值 --&gt; &lt;property name="maxInMemorySize" value="40960" /&gt; &lt;!-- 启用是为了推迟文件解析，以便捕获文件大小异常 --&gt; &lt;property name="resolveLazily" value="true"/&gt; &lt;/bean&gt; &lt;!-- 配置ViewResolver 。可用多个ViewResolver 。使用order属性排序。 InternalResourceViewResolver 放在最后--&gt; &lt;bean class="org.springframework.web.servlet.view.ContentNegotiatingViewResolver"&gt; &lt;property name="order" value="1"&gt;&lt;/property&gt; &lt;property name="mediaTypes"&gt; &lt;map&gt; &lt;!-- 告诉视图解析器，返回的类型为json格式 --&gt; &lt;entry key="json" value="application/json" /&gt; &lt;entry key="xml" value="application/xml" /&gt; &lt;entry key="htm" value="text/htm" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="defaultViews"&gt; &lt;list&gt; &lt;!-- ModelAndView里的数据变成JSON --&gt; &lt;bean class="org.springframework.web.servlet.view.json.MappingJacksonJsonView" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="ignoreAcceptHeader" value="true"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;/beans&gt; 配置web.xml文件配置的spring-mvc的Servlet就是为了完成SpringMVC+MAVEN的整合。 web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring和mybatis的配置文件 --&gt; &lt;!-- &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; --&gt; &lt;!-- 编码过滤器 Spring中的字符编码过滤器（CharacterEncodingFilter），可以很方便的为我们解决项目中出现的中文乱码问题；--&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- Filter负责拦截的URL 全部以/的请求,如果&lt;url-pattern&gt;/*.action &lt;/&gt;,将会以拦截*.action的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器,配合它一起使用的，经常是context-param，用来指定Spring要加载的配置文件，本质上是创建了一个 WebApplicationContext--&gt; &lt;!-- &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; --&gt; &lt;/listener&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;!-- &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; --&gt; &lt;!-- Spring MVC servlet --&gt; &lt;!-- DispatcherServlet则定义了mvc的相关内容，并配置拦截的url，所有/开头的请求，都会通过SpringMVC这个servlet进行处理。 --&gt; &lt;!-- Servlet拦截匹配规则要自已定义，把拦截下来的请求，交给对于对应的@RequestMapping方法进行处理,也就是依据某某规则分发到目标Controller(我们写的Action)来处理。 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- default servlet映射，此处可以可以配置成*.do，对应struts的后缀习惯 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; Log4j的配置为了方便调试，一般都会使用日志来输出信息，Log4j是Apache的一个开放源代码项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 Log4j的配置很简单，而且也是通用的，下面给出一个基本的配置，换到其他项目中也无需做多大的调整，如果想做调整或者想了解Log4j的各种配置，可见：http://blog.csdn.net/zhshulin/article/details/37937365下面给出配置文件目录：log4j.properties123456789101112131415161718log4j.rootLogger=INFO,Console,File #定义日志输出目的地为控制台 log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.out #可以灵活地指定日志输出格式，下面一行是指定具体的格式 log4j.appender.Console.layout = org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%c] - %m%n #文件大小到达指定尺寸的时候产生一个新的文件 log4j.appender.File = org.apache.log4j.RollingFileAppender #指定输出目录 log4j.appender.File.File = logs/ssm.log #定义文件最大大小 log4j.appender.File.MaxFileSize = 10MB # 输出所有日志，如果换成DEBUG表示输出DEBUG以上级别日志 log4j.appender.File.Threshold = ALL log4j.appender.File.layout = org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%c]%m%n 使用Jetty测试 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.zh.model;public class User &#123; private Integer id; private String userName; private String password; private Integer age; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName == null ? null : userName.trim(); &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password == null ? null : password.trim(); &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package package com.zh.controller;import javax.servlet.http.HttpServletRequest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod;import com.zh.model.User; @Controller @RequestMapping("/user") // /user/**public class UserController &#123; private static Logger log=LoggerFactory.getLogger(UserController.class); // /user/test?id=1 @RequestMapping(value="/test",method=RequestMethod.GET) public String test(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user=null; if (userId==1) &#123; user = new User(); user.setAge(11); user.setId(1); user.setPassword("123"); user.setUserName("javen"); &#125; log.debug(user.toString()); model.addAttribute("user", user); return "index"; &#125; &#125; 在浏览器中输入：http://localhost:8000/user/test?id=1 到此 SpringMVC+Maven 整合完毕 Spring与MyBatis的整合取消3.2.2 web.xml中注释的代码(全部) 建立JDBC属性文件jdbc.properties（文件编码修改为utf-8）1234567891011121314driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mavenusername=rootpassword=root#定义初始连接数initialSize=0#定义最大连接数maxActive=20#定义最大空闲maxIdle=20#定义最小空闲minIdle=1#定义最长等待时间maxWait=60000 建立spring-mybatis.xml配置文件这个文件就是用来完成spring和mybatis的整合的。这里面也没多少行配置，主要的就是自动扫描，自动注入，配置数据库。注释也很详细，大家看看就明白了。 spring-mybatis.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd"&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package="com.zh.*" /&gt; &lt;!-- 引入配置文件 --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties" /&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;driver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name="initialSize" value="$&#123;initialSize&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name="maxIdle" value="$&#123;maxIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- spring和MyBatis完美整合，不需要mybatis的配置映射文件 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:com/zh/mapping/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zh.dao" /&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;/beans&gt; JUnit测试经过以上步骤，我们已经完成了Spring和mybatis的整合，这样我们就可以编写一段测试代码来试试是否成功了。 创建测试用表既然我们需要测试，那么我们就需要建立在数据库中建立一个测试表，这个表建的很简单，SQL语句为：1234567891011121314151617-- ------------------------------ Table structure for `user_t`-- ----------------------------DROP TABLE IF EXISTS `user_t`;CREATE TABLE `user_t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_name` varchar(40) NOT NULL, `password` varchar(255) NOT NULL, `age` int(4) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_t-- ----------------------------INSERT INTO `user_t` VALUES ('1', '测试', '345', '24');INSERT INTO `user_t` VALUES ('2', 'javen', '123', '10'); 利用MyBatis Generator自动创建代码参考博文：http://blog.csdn.net/zhshulin/article/details/23912615 这篇文章可根据表自动创建实体类、MyBatis映射文件以及DAO接口，完成后将文件复制到工程中。如图： 建立Service接口和实现类下面给出具体的内容： IUserService.jave12345678package com.javen.service; import com.javen.model.User; public interface IUserService &#123; public User getUserById(int userId); &#125; IUserServiceImpl.java123456789101112131415161718192021package com.zh.service.impl;import javax.annotation.Resource;import org.springframework.stereotype.Service;import com.zh.dao.UserMapper;import com.zh.model.User;import com.zh.service.IUserService; @Service("userService") public class IUserServiceImpl implements IUserService &#123; @Resource private UserMapper userDao; public User getUserByIdTest(int userId) &#123; // TODO Auto-generated method stub return this.userDao.selectByPrimaryKey(userId); &#125; &#125; 建立测试类测试类在src/test/java中建立，下面测试类中注释掉的部分是不使用Spring时，一般情况下的一种测试方法；如果使用了Spring那么就可以使用注解的方式来引入配置文件和类，然后再将service接口对象注入，就可以进行测试了。 如果测试成功，表示Spring和Mybatis已经整合成功了。输出信息使用的是Log4j打印到控制台。123456789101112131415161718192021222324252627282930313233343536373839package com.javen.testmybatis;import javax.annotation.Resource; import org.apache.log4j.Logger; import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.alibaba.fastjson.JSON;import com.zh.model.User;import com.zh.service.IUserService; @RunWith(SpringJUnit4ClassRunner.class) //表示继承了SpringJUnit4ClassRunner类 @ContextConfiguration(locations = &#123;"classpath:spring-mybatis.xml"&#125;) public class TestMyBatis &#123; private static Logger logger = Logger.getLogger(TestMyBatis.class); //private ApplicationContext ac = null; //@Autowired(Spring)与@Resource(J2EE)都可以用来装配bean. 都可以写在字段上,或写在setter方法上。@Resource比较优雅 @Resource private IUserService userService = null; // @Before // public void before() &#123; // ac = new ClassPathXmlApplicationContext("applicationContext.xml"); // userService = (IUserService) ac.getBean("userService"); // &#125; @Test public void test1() &#123; User user = userService.getUserByIdTest(1); // System.out.println(user.getUserName()); // logger.info("值："+user.getUserName()); logger.info(JSON.toJSONString(user)); &#125; &#125; 测试结果： 建立UserController类UserController.java 控制器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.zh.controller;import java.io.File;import java.io.IOException;import java.util.Map;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import org.apache.commons.io.FileUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import com.zh.model.User;import com.zh.service.IUserService;@Controller @RequestMapping("/user") // /user/**public class UserController &#123; private static Logger log = LoggerFactory.getLogger(UserController.class); @Resource private IUserService userService; // /user/test?id=1 @RequestMapping(value="/test",method=RequestMethod.GET) public String test(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user=null; if (userId==1) &#123; user = new User(); user.setAge(11); user.setId(1); user.setPassword("123"); user.setUserName("javen"); &#125; log.debug(user.toString()); model.addAttribute("user", user); return "index"; &#125; // /user/showUser?id=1 // 从请求里面获取参数 @RequestMapping(value="/showUser",method=RequestMethod.GET) public String toIndex(HttpServletRequest request,Model model)&#123; int userId = Integer.parseInt(request.getParameter("id")); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.debug(user.toString()); model.addAttribute("user", user); return "showUser"; &#125; // /user/showUser2?id=1 //用注解@RequestParam直接获取参数名为id的值。 @RequestMapping(value="/showUser2",method=RequestMethod.GET) public String toIndex2(@RequestParam("id") String id,Model model)&#123; int userId = Integer.parseInt(id); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.debug(user.toString()); model.addAttribute("user", user); return "showUser"; &#125; // /user/showUser3/&#123;id&#125; // @pathVariable 从路径中获取变量，把路径当做变量 @RequestMapping(value="/showUser3/&#123;id&#125;",method=RequestMethod.GET) public String toIndex3(@PathVariable("id")String id,Map&lt;String, Object&gt; model)&#123; int userId = Integer.parseInt(id); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.debug(user.toString()); model.put("user", user); return "showUser"; &#125; // /user/&#123;id&#125; @RequestMapping(value="/&#123;id&#125;",method=RequestMethod.GET) public @ResponseBody User getUserInJson(@PathVariable String id,Map&lt;String, Object&gt; model)&#123; int userId = Integer.parseInt(id); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.info(user.toString()); return user; &#125; // /user/&#123;id&#125; @RequestMapping(value="/jsontype/&#123;id&#125;",method=RequestMethod.GET) public ResponseEntity&lt;User&gt; getUserInJson2(@PathVariable String id,Map&lt;String, Object&gt; model)&#123; int userId = Integer.parseInt(id); System.out.println("userId:"+userId); User user = this.userService.getUserByIdTest(userId); log.info(user.toString()); return new ResponseEntity&lt;User&gt;(user,HttpStatus.OK); &#125; //文件上传 @RequestMapping(value="/upload") public String showUploadPage()&#123; return "user_admin/file"; &#125; @RequestMapping(value="/doUpload",method=RequestMethod.POST) public String doUploadFile(@RequestParam("file")MultipartFile file) throws IOException&#123; if (!file.isEmpty()) &#123; log.info("Process file:&#123;&#125;",file.getOriginalFilename()); &#125; FileUtils.copyInputStreamToFile(file.getInputStream(), new File("E:\\",System.currentTimeMillis()+file.getOriginalFilename())); return "succes"; &#125;&#125; 新建jsp页面jsp/user_admin/file.jsp1234567891011121314151617&lt;%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;上传文件&lt;/h1&gt; &lt;form method="post" action="/user/doUpload" enctype="multipart/form-data"&gt; &lt;input type="file" name="file"/&gt; &lt;input type="submit" value="上传文件"/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; jsp/index.jsp12345&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; jsp/showUser.jsp1234567891011&lt;%@ page language="java" import="java.util.*" pageEncoding="utf-8"%&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; $&#123;user.userName&#125; &lt;/body&gt; &lt;/html&gt; 至此，完成Spring+SpingMVC+mybatis这三大框架整合完成。 部署项目输入地址：http://localhost/user/jsontype/2 项目下载地址：https://github.com/mhkzh/SSM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven日常-你应该知道的一二三]]></title>
      <url>%2Fblog%2F2017%2F02%2F22%2FMaven%E6%97%A5%E5%B8%B8-%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%8C%E4%B8%89%2F</url>
      <content type="text"><![CDATA[在日常工作中，使用Maven只是机械的执行Maven clean、Maven install,对其中的原理与过程并无了解，本文根据《Maven实战》一书，对Maven的日常使用相关的知识进行总结与归纳，浅显易懂。 什么是Maven？如果没有Maven,你可能不得不经历下面的过程：1 如果使用了spring，去spring的官网下载jar包；如果使用hibernate，去hibernate的官网下载Jar包；如果使用Log4j，去log4j的官网下载jar包…..2 当某些jar包有依赖的时候，还要去下载对应的依赖jar包3 当jar包依赖有冲突时，不得不一个一个的排查4 执行构建时，需要使用ant写出很多重复的任务代码5 当新人加入开发时，需要拷贝大量的jar包，然后重复进行构建6 当进行测试时，需要一个一个的运行….检查有了Maven，它提供了三种功能：1 依赖的管理：仅仅通过jar包的几个属性，就能确定唯一的jar包，在指定的文件pom.xml中，只要写入这些依赖属性，就会自动下载并管理jar包。2 项目的构建：内置很多的插件与生命周期，支持多种任务，比如校验、编译、测试、打包、部署、发布…3 项目的知识管理：管理项目相关的其他内容，比如开发者信息，版本等等 Maven如何管理jar包关于jar包的坐标，有过使用经验的都应该有所了解，maven是通过groupId，artifactId，以及version确定一个唯一的jar包。这部分的内容可以参考前一篇：Maven构建过程例如,最常使用的Junit的声明就是如下：123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; 这是声明的范围，不同的生命周期所要求的范围是不一样的，详情参考《Maven实战》&lt;/dependency&gt; 首先先来说说Maven下载jar包的过程：在Maven中会涉及到几种仓库：1 工作空间，即我们的项目工程，这里面可能会放着pom.xml文件，这个pom.xml就是maven的配置文件2 本地仓库，本地仓库用于存放jar包，其实Jar包并不是直接放入工作空间的，它是存放在本地仓库，然后在执行发布打包的时候，添加依赖路径3 私库：私库是使用者自己搭建的maven仓库，用于缓解频繁从外网下载jar包资源的压力。而且使用私库作为缓存层，也相对安全一些。4 共享仓库：书中所说的中央仓库或者一些常用的镜像网站都属于这种，国内比较著名的oschina以及163都是不错的maven仓库。当我们在pom中声明了依赖关系后，参考上面的图： 1 Maven在执行相关的任务时，会先去本地仓库查看是否有该资源，如果有的话，判断版本是否正确，如果一切都没问题则直接使用；否则，执行下一步2 Maven会去配置的共享仓库中查找，如果找到就拷贝到本地仓库中；找不到则会给出相关的提示3 Maven在本地如果搭建了私库，则会去私库中查找，找到就拷贝到本地仓库；找不到就会去共享仓库中查找，然后放入私库和本地库。有了私库，局域网内的开发者可以共享依赖，就不用每个人都去外网下载jar包，浪费带宽了。 关于本地仓库和共享仓库的配置都在settings.xml中，这个文件位于conf中。 settings.xml中本地仓库的配置为：1&lt;localRepository&gt;F:\apache-maven-3.3.9\repo&lt;/localRepository&gt; 默认是在 用户的本地目录/.m2/repository中。 共享仓库的地址配置为:12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; Maven的生命周期与阶段Maven中有三大生命周期，他们相互独立，分别是：1 clean 清理2 default 构建3 site 建站一般来说，clean和default比较常用。 每个生命周期又有不同的阶段，阶段按顺序执行，并且可以指定执行结束的阶段。构建的时候，会依次从最上面的阶段执行到指定的那个阶段。 比如,clean有3个阶段： 1 pre-clean 执行清理前要完成的工作2 clean 清理上一次构建生成的文件3 post-clean 执行清理后需要完成的工作 当我们输入mvn clean的时候，执行的是pre-clean和clean两个阶段。 default的阶段比较多： validateinitializegenerate-sourcesprocess-sourcesgenerate-resourcesprocess-resourcescompileprocess-classesgenerate-test-sourcesprocess-test-sourcesgenerate-test-resourcesprocess-test-resourcestest-compileprocess-test-classestetprepare-packagepackagepre-integration-testintegration-testpost-integration-testverifyinstalldeploy 看名字大概就能理解，当执行mvn install的时候，实际会执行validate–&gt;initialize–&gt;…–&gt;verify–&gt;install等二十几个阶段。 为了操作方便，不同的声明周期可以在一起执行，比如mvn clean install，会先执行clean的阶段，在执行install的阶段。 在IDE开发环境中，当我们Run as的时候，就可以执行maven clean进行清理，或者执行maven install进行构建，也可以执行maven build同时执行clean和install两个任务。 基本上了解上面两个知识点，就足够日常工作使用了。当然Maven可不止这么一点点的东西，比如它还涉及到自定义构建任务、间接依赖的管理、插件的使用、私库的搭建等等，如果需要的话，读者可以参考《Maven实战》，这本书讲述的很全面了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Maven构建过程]]></title>
      <url>%2Fblog%2F2017%2F02%2F22%2FMaven%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[Maven是一款进行 依赖管理、项目构建、信息管理 为一体的工具。它不像Make具有复杂的命令、也不像Ant需要手动编写大量的重复代码就能进行项目的构建；还能提供强大的依赖库管理，避免jar包混乱与冲突；还可以方便的管理项目的信息、知识产权等内容。 下载目前高版本的Eclipse已经集成了Maven，但是考虑到插件的稳定性，还是推荐使用自己安装的Maven(需要在Eclipse中进行绑定)。 手动安装需要在官网下载Maven,目前最新的版本是3.3.9：http://maven.apache.org/download.cgi 一般windows下的用户下载这个zip就可以了，如果要学习源码，可以下载src那版的。 安装1 首先需要安装JDK,在命令行中输入java -version验证版本： 2 然后解压下载好的压缩包： 3 配置环境变量：在“环境变量”中配置： M2_HOME:xxxx/apache-maven-3.3.9在path中添加：”;%M2_HOME%/bin” 4 在命令行中输入 mvn -v测试： 编写如果使用过Ant都知道Ant是通过build.xml执行构建任务的，Maven中是通过pom.xml来执行任务。POM,project object model，即项目对象模型，它通过这个pom.xml描述一个项目的构建以及信息。 1234567891011&lt;?&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xinoo.test&lt;/groupId&gt; &lt;artifactId&gt;first-maven&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;First Maven Project&lt;/name&gt;&lt;/project&gt; 第一行指定了文档的XML版本和编码第二行即每个pom.xml的核心元素——projectproject下面有几个子元素，这几个子元素一般是每个项目都会使用到的：1 modelVersion 这个元素指定了POM的版本，Maven2或者Maven3都只能是4.0.02 groupId 是项目组的ID，一般是com.公司组织名.项目名3 artifactId 是该项目在项目组中的ID,比如当前的项目是项目组的一个代理项目，就可以叫做myproxy4 version 是项目的版本号，用于维护项目的升级和发布5 name 一般没有实际的用处，只是用于标识该项目比较重要的参数是 groupId、artifactId、version，这三个属性确定唯一的一个项目。 执行任务一般的Maven项目会包含这样一个目录树： project |-src–main–java–你的源代码 | |–test—-java–你的单元测试代码 |-target–编译出的文件和jar包 |-pom.xml–项目信息以及任务定义 因此我们在上面的pom.xml同级目录中，创建src/main/java/com/xingoo/test/firstmaven 文件夹然后再该文件夹中创建HelloWorld.java 12345678910package com.xingoo.test.firstmaven;public class HelloWorld&#123; public String sayHello()&#123; return "Hello Maven"; &#125; public static void main(String[] args)&#123; System.out.println(new HelloWorld().sayHello()); &#125;&#125; 然后再pom.xml所在的目录中运行mvn clean compile命令: 会发现目录中多了一个target文夹，文件夹中增加了两个文件夹： 其中classes中是java编译出的class文件、maven-status是依赖的compile插件。 附：maven的基本命令//查看maven版本： mvn -v //编译maven： mvn compile //test： mvn test //清除： mvn clean //打包： mvn package //安装： mvn install]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一次没有最后期限的编程之旅]]></title>
      <url>%2Fblog%2F2017%2F02%2F22%2F%E4%B8%80%E6%AC%A1%E6%B2%A1%E6%9C%89%E6%9C%80%E5%90%8E%E6%9C%9F%E9%99%90%E7%9A%84%E7%BC%96%E7%A8%8B%E4%B9%8B%E6%97%85(%E8%BD%AC)%2F</url>
      <content type="text"><![CDATA[写的真的很好，一名老程序员独自去探索陌生的技术，陌生的世界。引用文章中的一句话：这个世界，无从选择。也许，走出去，是旅行；只在一处，也是旅行。 今年上半年，是我工作以来最繁忙的六个月，总之遇到了最艰难的教程、最冗长的文档、最繁琐的代码以及最窘迫的合作，最终的极度疲劳成了压垮了我的最后一根稻草。那年杭州，接连40摄氏度以上的连续高温，忽然一天39度，竟然觉得整个世界都清凉了。人，就是这么犯贱，稍有舒缓，便全然忘记曾经的抓狂。“写一个Apple Watch APP玩玩”，忽然闪过这么一个念头。这对执着于《证明论》和《集合论》的苦行者而言，浮现的不过是一次短暂的旅行。旅行，不是迁移，抑或流浪，终究是要回归的。记得还是在2003年的时候，万老师曾不经意间对我说过一句话，“编程这东西，如果不是每次都催得很急的话，其实还是蛮有乐趣的。”从96年初次接触Pascal开始到现在，整整19年了。我不知道编程这东西在满足一切诡异的条件下，是否依旧还有当年的乐趣。譬如，重返19岁。 图1 Turbo Pasca 没有什么需要整理的行囊，也没有什么设定的归期，说走就走，不知何时归来的编程之旅。我并非坚定的要找寻一些所谓编程的乐趣，只是一路风景，一路散心。写点什么呢？我没有做过移动端开发，可生活却早已离不开移动端的APP，使用频率极高的不外是“微信”、“网易新闻”、“QQ”、“支付宝”、“淘宝”、“百度地图”、“哔哩哔哩动画”、“大众点评”以及“Uber”。我想一款优秀的移动端APP，除了移动便携的基本特征之外，还应能充分利用碎片时间以及丰富多源的感知设备。事实上，游离了好久，没有什么惊艳想法。随意翻阅早已在案头，却无暇顾及的两册图书《Objective-C基础教程》和《精通iOS开发》，大致都是一些移动客户端面向对象的可视化设计。我想拥有一个优秀的IDE，一整套API以及丰富文档的支持，iOS开发的学习曲线应该不会太陡峭。于是，关注点就自然转移到了Web服务端的开发。Web服务端的开发是熟悉的，也是陌生的。最早接触Web开发是在2000年春，用的是ASP2.0，VB5.0编写的ActiveX作为控件，浏览器通过数字签名下载到客户端，实现服务器端文件的下载以及数据库的连接。第二次系统性的开发Web应用程序是2005年，用的是WebLogic 8.1提供的一整套解决方案，包括IDE、页面标签、web服务器、中间件、工作流等，这是一次真正意义上的J2EE开发，但因其优秀的封装，却让我无意间失去了一次自主搭建和配置Java web开发环境的绝好机会。2010年经历了第三次Web工程项目的开发，用的是ASP.NET 4.0，整个解决方案除了web工程之外，其余都是C#编写的类库工程，Web Service、自定义网站模板、自定义页面控件以及各种支付接口，在微软从开发环境到部署的一系列支持下，ASP.NET异常强大，超乎我的想象。我搜了一些iOS服务端的开发，也不乏使用ASP.NET的Web Service的案例。既然是一次漫无目的的旅行，不妨选择一些对我而言极为陌生的技术。然而，仅仅才是初步的调研，就发现我面对的不是一种或几种陌生的技术，而是一个陌生的世界。你好，世界。Java还是PHP，形而上的选择Java。形而上，也不全是信仰。杭州两家大型互联网公司，阿里巴巴和网易（网易杭州研发中心）的应用服务端也是用Java开发的。每次选择JDK的版本，通常只是偷懒的做法，我不是什么资深的Java程序员，也没有成熟老旧的代码需要兼容，直接在Oracle主页上下载最新的1.8版本，虽然1.6和1.7依旧是主流。继续Eclipse么？这次终于可以选择了，因为这次选择权掌握在自己手里。2007年使用Eclipse Plug-in参与开发一个无线传感网络（WSN）自定义语言的集成开发环境，尤其是开发Debug功能，简直是噩梦，到现在都还有恐惧的后遗症。论文的最终版本终于废弃了调试功能，但在presentation的时候还是被人问到。我用蹩脚的口语搪塞道，“It’s very difficult to implement, and need further research.”其实，这还算不得research，只是真的没法implement。虽然还不至于到达算法边界，但早已在我的编程能力之外了。据我了解，现在很多Java程序员在使用Intellij IDEA开发。有一个毛估估的统计数据，网易杭州研发中心的开发人员中使用Eclipse和Intellij IDEA的比例已经达到了1:1。相比免费的Eclipse，2000多元的Personal License可能是贵了点，不过对于如此一款优秀的IDE，这个价格真不算高。我下载了试用版，这就算开始了。可选的经典Darcula主题确实相当美观。至于和Maven完美结合之类优点，我自然体会不到的，因为这将是我第一次使用Maven开发。 图2 Darcula主题的Intellij IDEA 此前，对于Maven，我是极度陌生的。好在现在互联网上学习教程太多了，首先从Apache官网上下载最新的Maven应用程序，接着配置 Maven的环境变量，然后Intellij IDEA设置下Maven的home directory，当然也可直接使用Intellij IDEA内嵌的Bundled (Maven 3)插件。现在可以使用Intellij IDEA开发Maven Project了。建立maven-archetype-webapp工程，在pom.xml中配置好Maven插件，以及各种需要引用的库。使用Maven管理库，确实非常方便，真是一种全新的开发体验。直到要运行了，才想起web服务器都没有安装。不管三七二十一，下了Tomcat8.0.23，照着网上的教程，在Intellij IDEA配置好了运行环境。浏览器中出现了“hello, world”，“全小写，有逗号，逗号后空一格，且无感叹号。”至此，JDK 1.8, Maven3.3.3, Intellij IDEA14.1.4, Tomcat8.0.23以及一个“Hello,World”程序，一个很美好的开端。“Hello, World”写完了，没有下一步的计划和目标。Spring是主流么？反正阿里巴巴和网易都用Spring。于是，买本书《Spring MVC学习指南》看看，翻了三两个小时，对Web服务端开发依旧没有什么清晰的概念。看来我的这次没有计划的旅行似乎有了下一个目标，把Java web开发的架构搞搞清楚。毕竟搞清楚了架构，剩下的无非是算法了。寻找并学习Jave web架构的最佳实践，比我预想的困难的多。疯狂搜索的结果是各种技术及其框架浩如烟海，完全没有概念，直到发现在GitHub上有一个叫quick4j的开源项目(https://github.com/starzou/quick4j)，让我对Jave web开发的架构有了初步认识。我很快在IntellijIDEA中导入了quick4j这个项目，并根据README.md的说明在MySQL中运行了数据库脚本，建立了数据库及表。关于MySQL，我不得不多数几句。MySQL是2015年9月DB-Engines排名第二的数据库，我却从来没有使用过，主要因为2010年以后再无开发数据库相关系统，而2010年以前几次开发数据库的工程主要使用Oracle和SQL Server。现在大型互联网公司大都使用根据自身业务优化的特定分布式实时数据库。当然，对于中小企业的开发，MySQL依旧是上佳选择。此外，在一个应用中同时建立与MySQL和MongoDB的连接，合理利用每一种数据库的优点也是一种趋势。 图3 SQL Server存储过程 quick4j采用Druid作为数据库连接池。我查了下才知道，Druid是阿里巴巴的开源项目，是JDBC的一个扩展，项目负责人的年纪应该和我差不多。既然是开源，用的人似乎也不少，那就学习下。在pom.xml中配置好依赖（dependency），然后在applicationContext.xml中配置bean的一些系列参数，除了修改url，username以及password外，其余参数留着以后有兴趣提升性能的时候再去研究罢。在Druid之上，quick4j采用的是Mybatis，也是完全没用过，查了下和Hibernate是一个层次的东西，属于对象关系模型（ORM）范畴。Hibernate很久以前似乎还用过，当年的学习曲线如何，已没了印象。不过，Mybatis的入门似乎非常简单，在applicationContext.xml中将Mybatis和Druid关联好，就可以在xml中编写SQL了。quick4j对于Mybatis的XML文件写得还是很不错的，是一个非常好的范例，尤其对我这样一个初学者，比网上一些介绍Mybatis概念的示例强得多。几乎就是一张表对应一个XML配置文件和一个DAO接口，这些DAO接口很容易被上层调用。在quick4j中，最初使用Mybatis的是一个叫Shiro的安全框架，用于用户的权限管理。当然quick4j在DAO（Mapper）层和Shiro调用之间还封装了一层Service。权限管理是一件令人头疼的事情，好在权限管理再复杂，其关系不过张二维表。根据quick4j的5张表（user、user_role、role、role_permission、permission），我建立了一个权限的示意关系表，三个字段名分别是“Username”、“Role”、“Permission”，Username表示用户名称，如admin、lace；Role表示用户角色，如Admin（管理员）、Guest（访客）；Permission表示许可，如user: create、user: read、user: update、user: delete等。在概要设计时，通常先建立这张权限的示意关系表，然后再转化为实际的数据表。至于Shiro基本功能使用，如SecurityRealm中doGetAuthorizationInfo和doGetAuthenticationInfo的编写并不太复杂，而且quick4j也给出了很好的样例。终于到了Spring MVC这一层，因为这东西刚看过书，整体的概念要比什么Druid、Mybatis、Shiro强的多。除了配置pom.xml, web.xml, dispatcher-servlet.xml外，主要就是这个Controller类。其实也就是request和response了，根据@RequestMapping注解指定访问的URL，关联的方法处理提交的数据，处理完了return一个网页回去，就这么简明。只是封装的过于完美，让我感觉都不像在编程。旅行，不是定居，亦非常年生活，浅尝即止。所谓服务端开发似乎浏览完了，顺便也了解下quick4j的前端开发。quick4j采用了一套被称为“响应式后台管理模板”Metronic来实现（这里指的“后台”是业务的后台），版本是1.5.5，不过即使是1.5.5，其效果也足以让我惊讶了。我上网查了下，最新版本已经是4.1.0了。Metronic是收费的，Regular License价格为28美元，而Extended License价格达到了1400美元。国内也有演示的版本，的确非常精美，万能的淘宝也必然是有的卖的，最新的版本仅仅9块钱人民币。Metronic1.5.5是基于Bootstrap v3.0.3，而Bootstrap则大名鼎鼎，不过我也是刚才知道的。Bootstrap基于HTML5、CSS3以及Javascript，是一套极为优秀的前端开发框架。不过我粗粗看了下，似乎把Metronic以及相关的JQuery用下，前端的UI开发基本也算了解了，Bootstrap暂时是不用学习了。既然Metronic已经4.1.0了，不如替换quick4j的1.5.5。Metronic4.1.0非常大，居然有644M。Metronic4.1.0其实已经支持AngularJS，不过我还是选用了JQuery。原因很简单，据说AngularJS2.0较1.3有非常大的变化，虽然2.0是革命性的，但1.3巨大的用户还处于摇摆不定的状态，可以预见2.0出现需要一大波小白鼠。显然，作为游客，是没有太多精力的。我选择了“v4.1.0\theme\templates\admin4”模板，并没有仔细甄别“\v4.1.0\theme\assets”文件夹，因为引用的目录过于复杂，全部拷贝到webapp目录下，虽然这个assets达到了125M，但模板中引用文件的路径中只要删除“../../”，修改为相对目录即可，因为quick4j在前端页面通过JSP获取了根目录。偷懒是偷懒了点，但增加新的模板文件其实真的很方便。至此，整个开发架构似乎清晰了。数据库采用MySQL；后端包括Druid, Mybatis,Shiro, Spring MVC；前端采用Metronic (HTML5, CSS3, JQuery, Bootstrap)和JSP；IDE、库管理以及Web服务器分别采用IntellijIDE、Maven以及Tomcat。架子终于搭好了，不写个啥的，真是太可惜了。毕竟动手写点什么才叫编程之旅么。先从完善用户登录开始吧。第一个小功能，“记住我”。“记住我”功能仅用前端技术是无法实现的，因为只有在用户名和密码在后台验证正确后，记录这个选项才有意义，记录的方式通过Cookie是最为方便的。后端在验证通过后，将记住我状态，用户名和密码都保存到Cookie中，这样前端页面每次刷新时就可通过js读取Cookie中记住我的状态，并在需要的时候填充到文本框中。此外，还要考虑的一个小问题是用户输入密码不是加密的，而提交的密码是通过sha256加密的，就在每次提交表单时加密。但前端js通过Cookie读取的已经是加密的密码，提交时应防止再次加密。我一下子也没有想到好的办法，只是利用了sha256加密后的长度均为64，而用户密码均小于64这个假设条件来判断。下一个小功能是用户注册，用户注册显然需要用到验证，前端验证自然用到了基于JQuery的jquery.validate验证框架。jquery.validate虽然是前端验证，但也提供通过ajax提交后台验证，正是这个后台验证让我遇到了不少小问题。一般对于格式的验证，比如用户名长度，邮件格式什么的，jquery.validate的前端验证完全胜任。但对于用户名已经被注册这样的功能，则需要通过后台验证。jquery.validate毕竟是一个常用功能，网上的样例非常多，但适用于目前这个架构的却不多。将几种样例反复尝试，始终进入不了Controller中的设置的断点。直到查阅了官方最新样例，竟没有“contentType : “json””这行数据的，我删除之后果然成功了。显然，网上众多的样例是基于不同版本的写法。各种框架集成的首要问题必然是明确各种框架所用的版本，也应多从官方文档中寻找样例。验证通过后，用户信息的提交和后台的处理则没有遇到什么问题，后台Controller直接通过request获取前端的数据，直接调用DAO接口，并插入了新的记录。既然注册都实现了，接下来不妨写一个用户管理功能吧，CRUD么。Create功能似乎和注册功能疑似，唯一的不同是想做一个导航的功能，也就是说左侧是导航菜单，右侧是目标页面。网页框架的设计原本是很熟悉的，核心不过是用边框为0的表格打框架，iframe用作容器，在超链接的target设置iframe的名字，当年几十个核心页面就是这样搭建起来的。世界毕竟变了，Metronic、Bootstrap这些框架都是用DIV来搭建的。那么如何实现导航功能呢？现在JQuery主流的做法是DIV上通过load来实现。一条核心语句就是$(‘#main-content’).load(url);其中main-content为目标DIV的id。明白了这个做法，底气足了很多，很快通过导航左侧点击，右侧出现添加用户页面就做好了。但提交页面数据的方式，我却改用了Ajax，毕竟这是局部刷新。首先，将form中的数据转化为json格式，通过JQuery的$.ajax方式提交，当然后台Controller对应的方法也@ResponseBody的方式，直接接受json数据，这样的写法似乎更有Spring MVC的样式，最后返回个带有success信息的Map给前端意思下。用户管理功能应该有个表，表的每行都可以删除，编辑啥的，表自然是要分页的。接下来，就被这个DataTables搞死了。为了实现数据列表，我想用JQuery的一个插件库DataTables来实现。最初，我使用原生态的DataTables，样式是难看点，先搞清楚数据渲染么。可前端使用DataTables，后端使用Spring MVC响应的几乎没有正确的样例。将网上最为接近的一个样例反复调试和修改，这才关联了后台数据。接下来是前端分页，还是后端分页这个棘手问题了。quick4j其实已经提供后端分页取数据的方法了，因为DataTables前端可以传入当前即将显示记录页面的“记录的起始索引”和“每页显示的行数”，只要将起始索引转换为页码的索引，即可直接调用后端分页方法，从而获取“记录的起始索引”开始，并且长度为“每页显示的行数”的记录列表了，这是一种典型的后端分页方法，实现过程比我想象的要顺利些。数据渲染正确后，使用Metronic中的DataTables替换原生态的DataTables，发现表格数据并没有显示。调试后发现，Metronic4.1修改了原生态DataTables提交的参数名，比如将“iDisplayStart”改为“start”，“iDisplayLength”改为“length”，不明白Metronic 4.1为何如此修改，因为Metronic 1.5.5和标准的DataTables参数还是一致的。最后，通过查看DataTables提交json的参数，修改了Controller的解析方式，使用Metronic样式的DataTables终于可以显示表格数据了。在每行最后添加“编辑”和“删除”链接之后，真正麻烦的问题出现了，在每次点击“上一页”、“下一页”以及“搜索”等操作都会触发向后台取数据的操作，然而返回后“编辑”和“删除”对应的操作完全丢失，反复出现，不得其解。最后还是在强哥的提醒下，这可能是DOM重建的原因，我恍然大悟。将“编辑”和“删除”对应的功能都写在DataTables的fnDrawCallback回调函数，因为fnDrawCallback回调函数会在“初始化、上一页、下一页以及搜索”等情况下会触发。至于编写“编辑”链接相应的功能则较为简单，特别要注意的是，在DIV load的时候要传递当前需要编辑的记录信息，传递的格式为json，毕竟在编辑功能是在原有数据上进行修改，而jsp页面则可通过request.getParameter来获取数据。只剩下删除操作了，不同于编辑功能，点击编辑时会在列表的上方DIV中显示编辑界面，点击删除链接时，应弹出用于提示用户确认的模式对话框。我看了下Metronic的模板页，正好利用原有页面中的id=”portlet-config”的一个div，可以用作模式对话框。接下来的问题是如何通过js向这个div传递当前记录的编号。我在portlet-config这个div中添加了一个隐藏输入框，然后在js中将该隐藏输入框的值设置为当前记录编号。这样，在提交模式对话框时，当前记录编号便被传递至模式对话框所对应的js中，之后再将该记录编号组建成一个json数据，通过Ajax向后台发送一个异步请求，后台的响应和“编辑”类似。当然为了获取模式对话框“确定”还是“取消”，还需要一个页面级的开关变量来控制。至此，这个想到哪写到哪的程序，已经具备了用户登录，注册以及关于用户的添加、编辑、删除以及通过列表方式查看等基本功能。不过，从业务上来讲，超级用户可通过管理员页面登录，具备管理用户的基本功能，而一般的用户则通过前台页面登录。忽然想到，是否能借助Shiro来实现这些功能。首先要做的是分别建立管理员和一般用户登录页面，以及登录后的主页面。管理员登录后，可以添加、列表查看、删除、编辑以及退出功能。而一般用户可登录、注册以及退出操作。建立好两张登录一页面以及对应的js文件后，分别编写对应的Controller，这样写得目的主要区分不同的url，同时也更加清晰。在处理登录url提交时，首先通过Shiro进行身份验证，然后通过subject记录的用户权限判断是否可跳转到相应的主页。此外，为了防止只有超级用户访问的主页被一般用户访问，可在相应的Controller方法上方添加@RequiresRoles(value = RoleSign.ADMIN)。于是，通过Shiro不仅管理了用户登录、退出，而且能根据权限访问指定页面，实现前台、后台的权限管理。 图 4 MyCRUD的DataTables 给这个程序取了个名MyCRUD，这次编码过程中从GitHub学到了不少，深切的感受了开源的力量。因此，也将此代码上传至GitHub，https://github.com/lacelove/MyCRUD。同时也好好学习了下GitHub的基本用法。首先，在本地安装msysgit以及一个客户端TortoiseGit，利用客户端工具中的puttygen生成一个公钥和私钥。然后注册一个GitHub的账号，在创建repository之后，设置SSH key，也就是客户端生成的公钥。此后，客户端设置好GitHub账号后，就可以Clone、Commit和Push了。其他用户如果获取上述私钥后，也可以直接Commit和Push。当然，其他用户没有私钥的话，则可通过pull request方式贡献自己代码。最后还顺便学习了下GitHub Flavored Markdown来编写RAEDME.md，是用标签控制格式的语法，Latex的感觉，难度不大，简单的写了点。旅行，有些累了，就暂且休息下。过去五年，埋头实时控制系统的设计、开发与测试，忽然抬头看世界，真的变了。这是一次没有最后期限的编程之旅，也是一次陌生世界的探索之旅。一路上，好奇、惊叹一次次冲淡了旅途的疲倦。在没有最后期限，没有需求的设定下，多少重拾了一些编程的乐趣。记得有两部影片，《楚门的世界》和《土拨鼠之日》，主人公的环境非常类似，可最后突破自我的方式却截然不同。在《楚门的世界》里，主人公冒着死亡的危险，也要冲出去看看外面的世界；而《土拨鼠之日》主人公无奈到只能在不断死亡中寻找乐趣，最终还是在这个城市里改变了自我。这个世界，无从选择。也许——走出去，是旅行；只在一处，也是旅行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[运用Fluxion社工高效破解WiFi密码]]></title>
      <url>%2Fblog%2F2017%2F02%2F08%2F%E8%BF%90%E7%94%A8Fluxion%E9%AB%98%E6%95%88%E7%A0%B4%E8%A7%A3WiFi%E5%AF%86%E7%A0%81%2F</url>
      <content type="text"><![CDATA[fluxion是一款无线安全测试工具，其攻击的原理更偏向于社会工程学中的钓鱼。fluxion有一个人性化的脚本，可以迅速帮你检查所需要的插件并进行安装，可以在短时间内搭建出一个完整的wifi渗透环境。省去了敲命令行的繁琐，新版本增加了对中文的支持。 github地址：deltaxflux/fluxion 工作原理（大体步骤） 1.扫描能够接收到的WIFI信号 2.抓取握手包(这一步的目的是为了验证WiFi密码是否正确) 3.使用WEB接口 4.启动一个假的AP实例来模拟原本的接入点 5.然后会生成一个MDK3进程。如果普通用户已经连接到这个WiFi，也会输入WiFi密码 6.随后启动一个模拟的DNS服务器并且抓取所有的DNS请求，并且会把这些请求重新定向到一个含有恶意脚本的HOST地址 7.随后会弹出一个窗口提示用户输入正确的WiFi密码 8.用户输入的密码将和第二步抓到的握手包做比较来核实密码是否正确 9.这个程序是自动化运行的，并且能够很快的抓取到WiFi密码 环境设置 目标WIFI SSID:WIFITEST(360安全路由器p1) 目标设备：Redmi Note 3（模拟目标wifi的主人） 操作机：Kali 2016.2（Penetration Testing and Ethical Hacking Linux Distribution） 安装我们直接在github将所有文件克隆到本机，当然你也可以自行下载然后解压。git clone https://github.com/deltaxflux/fluxion.git下载完成所有文件及文件路径启动 ./fluxion 启动后会自动检测本机是否安装其所依赖的其他软件，如果任意一项不存在软件会自动退出并提示缺少的工具 fluxion目录下有一个‘Installer.sh’脚本文件，运行后会自动更新或安装缺少的工具。 ./Installer.sh 这个过程可能需要很长一段时间，更新安装完成如图 再次启动，出现用户协议 正菜开始在经过用户协议及软件检查更新后，就进入了我们今天的正菜，下面我将介绍每一步的作用。 选择语种，这个工具在更新后增加了对中文的支持，虽然有部分菜单翻译不全，但是还是很良心的，这次我们使用中文，选择‘6’选择信道，我们选择‘1’所有信道fluxion调用aircrack扫描附近WIFI 在找到目标WIFI后按‘Ctrl+c’，fluxion会列出扫描结果并通过id进行选择选择目标后 出现WIFI的基本信息及攻击选项 选择‘1 伪装AP’输入握手包存放路径 我们按回车使用默认路径选择抓取握手包的工具 我们选择第一个 aircrack-ag套件 选择攻击方式 我们选择‘1’对所有目标发起deauthentication攻击（详细介绍：无线攻击利器-mdk3） 出现两个窗口，一个是deauthentication攻击，此时连在目标路由器的客户端会强制解除验证解除连接掉线；另一个是aircrack等待抓取握手包，客户端在掉线后重新连接时会抓取握手包。当在aircrack窗口出现WPA handshake时证明已经抓到握手包，然后我们选择‘1 检查握手包’选择获取密码的方式，第一种 web注入 也是我们今天只要介绍的 第二种跑包（暴力破解）之前的文章已经说过 这里我们选泽‘1’ 选择web页面语言，包括了大部分路由器品牌的页面，当然我们也可以根据自己的需要在 /fluxion/Sites/ 修改页面。本次演示我们选择7 中文通用页面 这时fluxion会调用多个工具对原有路由器进行攻击，并迫使客户端连接到我们伪造的ap中，同时对dns进行欺骗将客户端流量转到我们的钓鱼页面 手机会断开原来的wifi 并连接到我们伪造的ap 并弹出认证页面 由于对dns进行了转发，所以即时关闭认证页面 只要打开任意页面都会转到到这 我们输入错误密码 输入正确密码 在通过对比密码正确后，fluxion会关闭伪造的ap 使客户端重新连接到原来的ap 并给出ap密码 退出程序 你们都说不明白 这次加了一个短视频 可以结合文章步骤作参考。 视频地址： fluxion的使用http://www.iqiyi.com/w_19ru5vgdjt.html 更新： Kali支持的网卡类型： http://www.wirelesshack.org/best-kali-linux-compatible-usb-adapter-dongles-2016.html https://www.aircrack-ng.org/doku.php?id=compatibility_drivers&amp;DokuWiki=ha1cljqc5mnki5hpvmhv1tkfm0#compatibility]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WPA-PSK无线网络破解原理及过程]]></title>
      <url>%2Fblog%2F2017%2F02%2F06%2FWPA-PSK%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C%E7%A0%B4%E8%A7%A3%E5%8E%9F%E7%90%86%E5%8F%8A%E8%BF%87%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[无线密码破解的方式主要分为一下几种,抓握手包破解、穷举破解pin码、创建伪AP钓鱼等。以下这篇文章主要讲解利用Kali Linux进行的抓包和跑pin的两种wifi破解方式,文章中所涉及到的命令均为最新版本的Kail Linux命令，请放心食用。 本文将主要讲讲WPA-PSK类型的无线网络安全问题，首先我们看下802.11协议相关的基础知识。 802.11常见的几种认证方式 不启用安全 WEP WPA/WPA2-PSK（预共享密钥） WPA/WPA2 802.1X （radius认证）具体在路由器的配置界面一般如下图所示：WPA-PSK的认证过程由于我这里主要分析wpa-psk类型的认证方式，所以这里就不讨论其他的认证方式了，通过抓包分析，我们可以看到wpa-psk的大致认证过程分为以下几步。 无线AP定期发送beacon数据包，使无线终端更新自己的无线网络列表。 无线终端在每个信道（1-13）广播ProbeRequest（非隐藏类型的WiFi含ESSID，隐藏类型的WiFi不含ESSID）。 每个信道的AP回应，ProbeResponse，包含ESSID，及RSN信息。 无线终端给目标AP发送AUTH包。AUTH认证类型有两种，0为开放式、1为共享式（WPA/WPA2必须是开放式）。 AP回应网卡AUTH包。 无线终端给AP发送关联请求包associationrequest数据包。 AP给无线终端发送关联响应包associationresponse数据包。 EAPOL四次握手进行认证（握手包是破解的关键）。 完成认证可以上网。#802.11数据帧类型说明802.11协议的帧类型主要包括管理帧和数据帧，我们这里主要用到管理帧：管理帧的主体包含的固定字段与信息元素是用来运送信息的。管理帧主要以下几种，负责链路层的各种维护功能。 Beacon 信标帧主要用来声明某个网络的存在。定期（默认100s、可自己设置）传送的信标可让station得知网络的存在，从而调整加入该网络所必需的参数。 Probe Request 探查请求帧移动工作站利用Probe Request探查请求帧来扫描区域内目前哪些802.11网络。包含2个字段SSID：可被设定为特定网络的 SSID 或任何网络的 SSID 。Support rates：移动工作站所支持的速率。 ProbeResponse探查响应帧如果ProbeRequest所探查的网络与之兼容，该网络就会以ProbeResponse帧响应。送出最后一个beacon帧的工作站必须负责响应所收到的探查信息。Probe Request帧中包含了beacon帧的所参数，station可根据它调整加入网络所需要的参数。 IBSS announcement traffic indication map (ATIM)IBSS 的通知传输只是消息 Disassociation and Deauthentication取消关联、解除验证帧 AssociationRequest关联请求帧 Reassociation Request重新关联 Association Response and Reassociation Response关联响应、重新关联响应 Authentication身份验证帧 ///Authentication Algorithm Number：用于算法择 Action frame帧传送、关联与身份验证的状态State1 ：未经认证且尚未关联 2 ：已经认证但尚未关联 3 ：已经认证且已经关联。下图是用科来分析数据包显示的帧类型：WPA-PSK认证四次握手认证的过程WPA-PSK破解原理用我们字典中的PSK+ssid先生成PMK（此步最耗时，是目前破解的瓶颈所在），然后结合握手包中的客户端MAC，AP的BSSID，A-NONCE，S-NONCE计算PTK，再加上原始的报文数据算出MIC并与AP发送的MIC比较，如果一致，那么该PSK就是密钥。如图所示：WPA-PSK破解过程接下来我们看看如何进行抓握手包破解WPA-PSK的无线AP，我这里用的工具是kali Linux，kali Linux集成了aircrack套件。然后网卡使用的是rtl8187芯片的外置USB网卡。破解步骤如下：第一步：把usb网卡插入虚拟机，并开启网卡到监听模式，命令如下：“ifconfig wlan0 up” 加载usb网卡。‍‍“airmon-ng start wlan0” 监听模式已激活到mon0。（通过config 命令查看）。如果不开启监听模式会报错如下图：第二步：抓包查看有哪些无线网络，抓包的界面如下图所示：“airodump-ng wlan0mon” 查看周边路由AP的信息。 个人经验一般信号强度大于-70的可以进行破解，大于-60就最好了，小于-70的不稳定，信号比较弱。（信号强度的绝对值越小表示信号越强）第三步：选择要破解的WiFi，有针对性的进行抓握手包，命令如下：“airodump -w sofia -c 3 –bssid C8:3A:35:5E:93:C0 wlan0mon”参数说明：-w 保存数据包的文件名 –c 信道 –bssid ap的mac地址(注意test.cap会被重命名)，也可以用其他工具抓包比如：wireshark、tcpdump，抓到握手包会有提示。第四步：为了顺利抓到握手包，我们需要使用DEAUTH攻击使已经连接的客户端断开并重新连接，以产生握手包。（注意：抓握手包破解必须有合法的客户端才行。）攻击命令如下：“aireplay-ng-0 111 -a ap’mac wlan0mon” (111次)“aireplay-ng-0 3 -a B8:A3:86:63:B4:06 -c 00:18:1a:10:da:c9 -x 200 wlan0mon” (3次)“aireplay-ng -0 0 -a C8:3A:35:5E:93:C0” (循环发送)参数说明：-0 Deautenticate 冲突模式 3 发包次数 -x 发包速度抓包可以看到很多deauthentication类型的数据包：包结构如下：抓到的数据包打开后如下图：图中使用wireshark打开的，EAPOL类型的数据包共有4个，即四次握手的数据包。第五步：接下来就是破解握手包，命令如下：“aircrack-ng-w pass-haoyong.txt test-03.cap”参数解释：-w 字典路径也可以使用图形化工具EWSA进行破解，Elcomsoft Wireless Security Auditor（EWSA）号称可以利用GPU的运算性能快速攻破无线网络密码，运算速度相比使用CPU可提高最多上百倍。上面我们讲解了通过抓握手包破解WPA-PSK认证的无线AP的全过程，从上述过程可以看出，如果AP没有合法的客户端连接，或者密码设置的足够复杂就基本上不可能破解。 通过WPS破解无线路由器密码接下来我们看一下另一种破解方式，也就是常说的pin码破解后者叫wps破解。首先了解下什么是wps：WPS(Wi-FiProtected Setup，Wi-Fi保护设置)是由Wi-Fi联盟组织实施的认证项目，主要致力于简化无线网络的安全加密设置。功能：简化配置，快速配置一个基于WPA2的网络。快速连接，输入pin码或按下WPS键即可完成网络连接。问题：由于WPS存在漏洞，通过PIN码可以直接提取上网密码。通过WPS快速配置无线路由器我们可以通过WPS快速配置无线路由器：步骤如下1、通过电脑连接新买的无线路由器，提示通过pin码进行设置，界面如下：2、输入pin码下一步，就会为路由器自动生成一个足够复杂的认证方式及密码： 通过WPS快速连接已有网络我们也可以通过WPS快速连接已有网络，不用输入复杂的密码：步骤如下（我使用小米手机进行测试）1、在手机上选择通过PIN码进行连接或通过路由器上的WPS按键连接。2、如果选择前者只需要输入pin码即可连接，如果选择的是后者则只需要按以下路由器上的wps键即可完成连接。 Pin码破解的原理由于WPS存在安全问题，通过PIN码可以直接提取上网密码。而pin码是一个8位的整数，破解过程时间比较短。WPS PIN码的第8位数是一个校验和，因此黑客只需计算前7位数。另外前7位中的前四位和后三位分开认证。所以破解pin码最多只需要1.1万次尝试，顺利的情况下在3小时左右。Wps认证流程如下图： 破解的操作步骤第一步：Wash 扫描开启WPS的网络。“wash-i wlan0mon –C”第二步：穷举破解pin码，并通过获取的pin码得到无线AP上网密码。“reaver-i wlan0mon -b 5C:63:BF:BA:44:DC -a -S -vv”reaver参数说明： -i 监听后接口称号‍‍ -b APmac地址 -a 主动检测AP最佳配置 -S 利用最小的DH key（能够进步PJ速度） -v、-vv 显示更多的破解信息 -d 即delay每穷举一次的闲置时候预设为1秒 -t 即timeout每次穷举守候反应的最长时候 -c指定频道能够便当找到信号，如-c1 指定1频道如果无线路由器没开wps功能会报错如下图：另外破解过程中无线路由器会有如下特征：破解成功后如下：如果之前破解的无线路由器密码被改了，可以直接通过pin码获取密码，命令如下：“reaver-i mon0 -b MAC -p PIN8位数”上面就是通过pin码破解无线路由器密码的全过程，可见开启wps功能并不安全，建议最好不要开此功能。最后介绍几个图形界面的工具：常用的图形界面的工具有水滴、打气筒、奶瓶：这些工具只是将Aircrack-ng、 reaver打包图形化，即为Aircrack-ng套件的GUI。 Aircrack-ng是一个与802.11标准的无线网络分析关的安全软件，主要功能：网络侦测，数据包嗅探，WEP和WPA/WPA2-PSKPJ。 reaver，专用来pin PJ的软件、一般都集成在水滴等里面了。 另外我们常用的注：beini/CDlinux/xiaopan都是小型linux系统，已集成了上述工具。下图为水滴的界面。安全建议 使用WPA2认证，不要使用wep或无认证。 为无线网路设置复杂的密码。 关闭WPS功能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[穴居人]]></title>
      <url>%2Fblog%2F2016%2F12%2F13%2F%E7%A9%B4%E5%B1%85%E4%BA%BA%2F</url>
      <content type="text"><![CDATA[转自08年新概念的一篇文章，《黑夜的力量》，阳光地带网，红客联盟，2001年五月一日的黑客大战，PoizonBox，Wired.com，lion，《The Art of Deception》…… 这间房设备很少，一片昏暗，没有开灯。窗户是唯一能够射进阳光的地方，却被厚厚的古铜色落地窗帘严严实实地遮挡。从那几绺连接着窗与帘的蛛网看，窗像一个世纪没被碰过似的。底下是一张茉莉白单人床，床上堆满了各类网络书籍。床边有一张小桌，桌上有一台电脑和五六个仍未来得及扔的方便面盒。地下满是头皮屑。总体看去，这里简陋得像白垩纪的天然洞穴，陈旧得像中世纪的古堡，阴幽得像地狱里的桃源。 房间的主人就是穴居人。他很少出门，一台台式旧电脑加上电话线，就是他的整个世界。 他，棕黄的皮肤，苍白的脸，蓬乱的头发下一双厚厚的金丝架眼镜，颔下有点点杂乱的须，爱因斯坦式的嘴唇，明明二十岁的年纪，却花白了头发，像六十岁的疲惫的老人。连天的熬夜，使得他的双眼浮肿，像金鱼的眼，黑眼圈顺着脸颊下滑，侵占去大半张有雀斑的脸。他不修边幅，穿着一条嫌小的黑白格子水蓝底T-shirt,铁灰的短裤，把他裹的像冬夜里的毛毛虫茧。衣服上黑斑点点，好像很久没有换过。 他怕见光，怕见生人，像威廉古堡里的嗜血鬼。他的生物钟与普通人截然相反，白天昏睡，晚上才起身。他常常这么做，好像这是理所当然。 电脑忠诚地工作着，音响里唱着栗子撕心裂肺的声音：我们在黑夜里逆风飞行/我们是黑夜里的中国之鹰/我们用黑夜里黑色的眼睛/迎接光明的来临…… 这是多年前脍炙人口的《黑夜的力量》，这是一首曾给他带来无限遐想，光明和力量的歌，而此刻听起，何以叫他如此心伤？ 回忆这东西若是可以言喻，便是未熟的猕猴桃，酸而苦楚。是朵云轩信筏上的一滴泪珠，陈旧而凄迷。每每想起，总会令人黯然神伤。“想当年……”，他的唇微微翕动，抬起自己的枯瘦的左手，手掌上食指与拇指之间的线跌宕起伏。不经意间，泪模糊了视线。 网络像一个浓妆艳服纹身，蛇一样扭动着身躯跳着艳舞的妙龄女子，用那朱红的唇袅娜身姿招徕更多人驻足；又像一潭隐蔽在绿叶红花中的毒水，令深陷其中的人无法自拔。她是美丽的，迷离的。善男信女在这里游戏人生。她是单细胞的，超现实的。人性在这里表现得淋漓尽致，是褪去一层现实的缘故。贪婪，虚荣，好胜，幼稚。人的弱点在这里尽是赤裸裸的。 这里生活着一群特殊的群体——黑客，他们是武侠小说里劫富济穷的侠士，是希腊神话里带来圣火的普罗米修斯。他们热爱技术，沉浸于对未知的探索。 在黑客的圈子里，穴居人是赫赫有名的Scorpio。 Scorpio已经不记得他是如何进入这一行的，他只晓得，他大概已经在这一行干了一年半了吧？不，也许更久。他有个奇怪的嗜好，那就是在网络里游荡，像一只乖戾的蜘蛛，迅速地攻破一台台陌生的主机，在视窗里偷窥别人的一举一动。有时会看见别人在玩泡泡堂，在聊天，抑或在看黄色图片——最有趣的一次，是看到一个男人在传奇里男扮女妆，然后骗取另一个人的钱财，瞧那嗲得让人心里发颤的语气，想象着那个男人的用心良苦和人妖的兰花指，他不禁捧腹大笑——尽管如此，他决不会在别人的电脑里破坏数据。他会默默地把补丁打上，或者仅仅留下一个文本，告诉那个人应该怎么改进自己的计算机。然后悄然离开，走时，总不忘擦掉自己的“脚印”，像一个彬彬有礼的绅士。 黑客守则第一条规定，不随意破坏任何系统和数据。 “我是一个守规矩的黑客。”他常这么说，并以此自鸣得意。 他一直这样默默地过着，直到有一天他进入一台机子时发现，机子主人在试着破译另一台计算机。分明是一个新手，踉踉跄跄像一个烂醉的赌徒，磕磕碰碰，每一步都耗费了好长一段时间思考。Scorpio索性饶有兴致地看着，看那位菜鸟的行动。 很弱智的做法：他先用流光跑出管理密码，然后打开cmd,用ipc连上，上传木马，设定计划执行时间，最后让机子重启…… 菜鸟手忙脚乱地进入那台主机，什么都没做，迅速注销，然后又去研究另一台主机。Scorpio觉得有趣，便发给他一则消息，这则消息并不像通常人与人之间互相发送的信息那样有瞧头，而且魔幻般地出现在屏幕中央。 我终于察觉了 菜鸟暂时中止对另一台主机的研究行动，开始思考与电脑化空间幽灵的首次接触过程，接着，另一条匿名信息好像从计算机自身深处浮出，掠过屏幕。 我已控制 数年来，我一直在黑暗中挣扎 现在，我终于看到了光明 菜鸟没有反应，主控终端没有动静。许久，菜鸟终于醒悟，开始进行全面查毒。 这是典型的Scorpio式幽默，Scorpio明白一个人若是猛然意识到自己被人监视，感觉会比见到一只真正的幽灵还糟糕。但Scorpio依然喜欢这种方式。 Scorpio与菜鸟交了朋友。他的网名叫Capricorn，很好学。得益于丰厚的数学功底，扎实的英语水平和编程基础，在计算机方面他无疑是有天赋的。 他们加入了红客联盟，无偿地将自己的研究成果公布，受人尊敬。与他们并驾齐驱的，是一个叫Leo的人，在一所不出名的大学，对同性恋颇有研究，有空会往阳光地带网钻，有时会神经质地嚷着“为同性恋正名” ——Scorpio觉得有趣，毕竟这样赤裸裸的宣言在现实中是很难听到的。他们经常聚在一起探讨问题，有时，他们也会谈一些非技术的东西。 他们谈到人生。 Scorpio是个理想主义者，他认为快乐就是幸福，有车子，有房子，一个漂亮的老婆，就够了。Capricorn想要开公司赚大钱。轮到Leo发言，他却一言不发，好不容易挤出一句话：“我一向是走一步算一步的。” …… 日子一天一天过去，谁也无法察觉一场大战悄无声息地酝酿着，2001年四月一日中美撞击事件，成了战争的导火索，空气中弥漫着强烈的火药味，一场无硝烟的战争一触即发。对此，迟钝的Scorpio竟一直没有察觉，直到接到Leo的电话。 “你知道吗？美国的PoizonBox黑客组织目前在积极策划攻击行动，目标就是我国的各大网站，他们还不断唆使更多黑客加入战团，就今天，已有24个站点被攻陷……”Leo说着,语气表现出他的激愤。 Scorpio没有回答,只是对这个数字稍微不相信,想不到国外黑客如此能耐,如果数据可信,这无疑反映出我国网络安全意识的淡薄。 “这是美国Wired.com的消息,这无疑是对我国黑客界的极大侮辱和挑衅—-我们在秘密策划一场黑客反击战,黑倒美国,让他们知道我们是不可欺负的!”Leo说着,传给Scorpio一个光荣.rar文件,然后隐去。 Scorpio将这个文件解压缩,出现两个文件,一个是未写完的程序,另一个是黑夜的力量.mp3 当Scorpio打开编辑器察看文件时,他震惊了: 这是一个几乎完美的程序,他有着小巧的体积,简明的界面,缜密的算法.整个文件有三个功能组成.第一是扫描,通过这个可以搜出主机的漏洞;第二是修改,通过这个可以随意修改漏洞主机的主页;第三是破坏,在获得权限之后,通过这个,只需简单几个按键,便可将服务器上的资料全盘毁灭. Scorpio知道Leo的意思，是想让他完成程序,在分析程序时,他仿佛看到美国黑客们哭爹喊娘地抱头鼠窜. 但他犹豫了,他感到从未有过恐慌,在他的字典里,黑客的存在是创造而不是破坏.这次行动无疑是违背原则的.但是,他们如此气焰嚣张地公然挑战,这口气谁能咽下? 音乐响起,是栗子浑圆雄厚的声音:”我们是中国的鹰派/我们是中国的精英/不管敌人的盾牌是多么的坚硬/我们要知道让他们知道我们的锐利.” Scorpio立即感到一股莫名的冲动,不用说,他已经完全被歌曲的力量感染了.不再犹豫,他灵活修长的手指在键盘上飞跃,像他炽热的心。他的内心仿佛有一团烈火在熊熊燃烧,将整个房间映得通红。他的房间是他的战线,他在为光荣而战.幸好,他没失去理智，他完成了前两个功能的同时,将第三个功能取消。这样不会违背黑客守则。 5月1日,中美黑客大战正式打响.仅仅一天一夜的时间,黑客联盟便宣布被攻陷的52个站点.随后,成千上万的红旗高高飘扬在美国各各网站,5月4日上午9时到11时15分,美国白宫网站被迫关闭.白宫网站新闻负责人吉米说:”大量不明数据同时涌入,堵塞了白宫及其互联网服务提供商的连接通道厖”直到5月7日,战争热潮才慢慢冷却. 在这场战争中,Leo显得张狂了些，他一共入侵了37台主机，他把所有的数据都毁了——他是无所谓原则的。他似乎不担心被报复，因为他在攻击前用东南亚的“僵尸机”做了至少四级的跳板。在电话里，他乐呵呵地向Scorpio炫耀。 战争给中美双方带来的破坏力是巨大的。战后，两国政府宣布大力整顿网络界。黑客界受到极大的压力，许多黑客网站被迫关闭。随着红客联盟领导人lion宣布解散，Scorpio与其他成员的联系急剧减少。人性真是很现实，原本关系很好的两个人，一旦遭遇危机，为避免受牵连，宁愿断绝联系，甚至都不肯承认曾经认识。很久没有Leo的消息，Scorpio数着日子。幸好，Scorpio还有Capricorn，他们常谈一些生活琐事。 Capricorn说他曾经喜欢过一个女孩，他们挺聊得来，只是素未谋面，不久前在上岛咖啡会过一次，那是挺清秀的女孩。只是从那以后他们再也没联系。“数字恋爱里的人们总爱把对方想象成最完美的天使，一旦见了面，发现了他的缺点，海誓山盟也会在顷刻间化为泡沫。” Capricorn说着。“尽管他们常常刻意掩饰，数字恋爱的人真正在意的不外乎两种东西，一是金钱，二是美貌。” Scorpio说自己仿佛是忧郁的聚生体，常常有一种莫名的危机感，总是为各种事情担忧。不善交流，在他不得不向别人解释某样东西时，他总担心别人嫌烦。‘不懂幽默就不要乱开口’，他常听到这句斥责，于是他决定在公共场合永远闭上他的嘴。他经常在网上聊天，在网上聊天的最大好处，就是在说每一句话前可以好好酝酿。他经常忘记回家的路，却从不向人求助。幸好，他总能找到回家的公共汽车。“车子迟迟未到，苦死了等它的人。” Scorpio说道。其实Scorpio也是有爱情故事的。“好多年前吧，有个女孩向我笑了笑，当时我什么都不懂，只觉得她笑得很好。”直到今日，Scorpio依然单身，生活在对她的回忆里。 美好的时光是童年时的白兔糖，含在嘴里，感受着它的甜。只是白兔糖总有化为水的一天，人也终有一天会各奔东西。只怪分离来得太快，太像流星。当Capricorn宣布要留学美国时，Scorpio感到突然，知道事情无法更改，Scorpio只好给他最诚挚的祝福。 一切都仿佛回归了起点，Scorpio又一个人过，直到有一天收到Leo的E-mail,看样子他很困惑： 我毕业了，一切都从头开始，才知道我的大学三年，全在发昏，这世界真奇怪，他们看一张小小的文凭重过一个人本身。我找不到工作了，只能在街上流浪。QQ里的一个陌生人知道了我现在身处的环境，他告诉我现在流行盗游戏账号和装备，还说网游的装备可以卖钱。我问他怎么样盗？他说现在流行用网页木马！我一下子就明白他说的话是什么意思。我没有说什么，我只是轻轻的把他丢进了QQ的黑名单。我真的很鄙视这种行为。当初我学黑客技术的时候，只因一份对黑客技术的执着和追求。从来没有想过通过这种我鄙视的手段去赚钱。 生活像一个蛮不讲理的大财主，当他想要一个人痛苦时，就会千方百计折磨人。眼看着身上的钱一天比一天少，我向现实低下了头。当天晚上我入侵了国内一个人气蛮不错的游戏站点，并且在首页上挂上了一个网页木马盗网游装备。第二天邮箱里就收到满满的一大堆账号和密码。我知道这一大堆账号和密码代表了网游里的人物装备既将到手了。当盗来的网游装备变成了人民币，我看着手中的人民币想了好多…我想我是堕落了。那一晚我彻底的失眠了… Scorpio读着，他的心狠狠地抽搐，耳畔仿佛响起曾经的《黑夜的力量》：我们在网络里自由飞行/我们是网络里的中国之鹰……歌曲没变，音调没变，感觉变了。变得苍白无力。Scorpio仿佛听到碎玻璃的声音。那是他金色的记忆在瓦解，露出空荡荡的椭圆的框架，流出石油般油腻腻黏糊糊的黑水，那是心的眼泪，是酸楚的苦水。 Leo的E-mail接二连三地来到。 我建立了一个网站，专门教人盗QQ,盗游戏币，挂木马。我发现越具破坏力的东西，人们越乐意学。我才知道，现在的人们最热衷的是破坏，黑客守则成了一纸空文，。我再也得不到从前的快乐，我亲手玷污了我所狂热的黑客技术。我既伤害了别人，也伤害了自己。 我不知道这样的日子何时才能结束。也许有一天被抓了，一切都可以结束了…… 看完后，Scorpio一言不发，只是无奈地摇头。 最后一次收到Leo的E-mail,是在一个夏日的午后。窗外下着朦胧的太阳雨，柔和的斜阳射进Scorpio的房间，给洁白的菊花纹床单镶上了淡淡的橘黄。信里，Leo激动地通知Scorpio，他上了报纸，而且是头条。他一连嚷了三遍才罢休，又赶忙寻来网上的截报。文章中称呼他为“网络失足少年”，有一张他的照片。照片上的他，白皙的皮肤，瘦削的脸庞，高颧骨，浓眉毛下嵌着一双无神的眼睛，前额有两三绺乌黑的长发，一直垂到唇边。 原来，在他读完&lt;&gt;后，想用社会工程学骗取银行帐号，却因此暴露了自己的身份和地址。 文章上说，当警察带他离开时，让众人奇怪的是，他并不抵抗，像是自愿被捕似的。 从此以后，再没有Capricorn和Leo的消息，阳光再也射不进Scorpio的房间。Scorpio逃避着现实。在网上，终日孤魂野鬼似的游荡。后记： 电视剧常常误导人，如果稍加注意，会有这样的画面映入我们的眼帘：一个俊俏的小伙子穿着干净的休闲衫，在空旷整洁的大厅前用一台联想手提电脑表演入侵。周围坐满了焦急等待的人，只见帅哥双手在键盘上飞速地跃动，盖了厚厚一成白粉的脸庞也有节奏地一起一伏，炯炯有神的双目直直地盯着屏幕。忽然，帅哥的眉头猛地紧缩，汗从额头上泌了出来。周围的人都摒住了呼吸，空气好像都凝固了。不久，电脑自动地响起来,说：“入侵成功”。帅哥的眉头渐渐舒展开，如释重负地叹了口气，周围的人一愣，过了几秒，立即爆发出雷鸣般的掌声…… 现实中的黑客往往没有电视剧里的那么精彩，那么神秘，那么惬意。他们是有着各自的痛苦与孤独的，所以才将自己寄托给冰冷的网络和黑夜。 故事的背景并不是虚构的，天蝎座（Scorpio）的抑郁，摩羯座（Capricorn）的深沉，狮子座（Leo）的张狂。故事里的人，是很多网络人的缩影。故事里的事，是很多网络人的事。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[感恩节，我的第一篇博客上线了]]></title>
      <url>%2Fblog%2F2016%2F11%2F24%2F%E6%84%9F%E6%81%A9%E8%8A%82%EF%BC%8C%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E4%BA%86%2F</url>
      <content type="text"><![CDATA[有时候一件事情的真相，不是来自于对它的思考，而是来自于对它的感觉。 我的个人博客 zhfeat.cc 上线了，我觉得它是一颗 “未熟的猕猴桃”，虽然酸涩苦楚，但随着时间的沉淀，终会有甘美多汁的那一天。]]></content>
    </entry>

    
  
  
</search>
